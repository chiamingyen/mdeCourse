.. @+leo-ver=5-thin
.. @+node:amd.20130514093510.2704: * @file cadp.txt
.. @@language rest
.. @@tabwidth -4

.. @+at @rst-options
..  call_docutils=False
..  code_mode=False
..  generate_rst=True
..  http_server_support = False
..  show_organizer_nodes=True
..  show_headlines=True
..  show_leo_directives=True
..  stylesheet_path=..\doc
..  write_intermediate_file = True
..  verbose=True
.. @@c

.. @+all
.. @+node:amd.20130514093510.2705: ** @rst document/cadp.html
#######################################
電腦輔助設計實習
#######################################

.. index:: 電腦輔助設計實習

.. contents::
    :depth: 3
.. @+node:amd.20130514093510.2706: *3* CADP 第一週
假如電腦輔助設計只是教導學生使用某套 MCAD(Mechanical Computer Aided Design), 例如 SolidWorks, Inventor, Creo, NX 或 Catia, 那麼未來將會短少很多高性能的創新性機械產品(包括工具與環境).

電腦輔助設計的本質在學習如何引導機械設計工程師利用電腦提高設計內涵、加速設計流程並有效整合志同道合的全球化設計趨勢.

- 利用電腦提高設計內涵, 電腦的基本功能在運算(正確且快速的計算)、模擬(讓模型在各種可能的情境中呈現結果)與資料處理(海量資料的處置與管理).

- 利用電腦加速設計流程, 透過高速且正確的運算得到可參考的數據, 利用擬真的模擬來降低開銷與風險, 利用電腦來處置管理複雜的資料, 讓海量資料成為有用數據進而成為設計團隊的知識.

- 有效整合志同道合的全球化設計, 利用電腦與網路架構來配置安全且可永續演化的協同設計環境.

因此電腦輔助設計就機械設計領域中的學習任務:

- 如何地用電腦執行正確且快速的計算: 建立模型執行運算, 既存運算套件的應用、打造各種運算套件

- 如何讓模型在各種情境與條件下呈現類真實的結果: 電腦 2D/3D 繪圖, 既存模擬套件的應用、打造各種模擬運算套件

- 如何處置海量資料, 如何管理海量資料: 電子資料處理、日誌建構、資料轉檔、內容管理

- 如何建立安全的網路使用環境: 單機、網路、隨身平台建構與維護

- 如何建立可永續演化的協同設計環境: 平台上的設計元件建構、既有套件的延伸、資料備援與典範轉移(當平台因各種因素而不復存在, 知識、技術與內容該如何轉移、如何延續)

課程基礎:

- 基本的機械設計概念

- 基本的程式語言基礎

- 基本的英文解讀能力

- 基本的自我閱讀能力
.. @+node:mde.20130604110320.2784: *4* MCAD 套件選擇
Mechanical Computer Aided Design(MCAD) 套件:

高端: Catia, NX, Creo

中端: SolidWorks, Solid Edge, Inventor

開源: FreeCAD

目前提供免費學生版的套件有:

AutoDesk Inventor, PTC Creo, Siemens Solid Edge, 其中又以 Solid Edge 的學生授權最為自由, 因此 2013 Fall 電腦輔助設計課程將採用 Solid Edge 與 FreeCAD, 而 Inventor 與 Creo 則用來輔助教學.
.. @+node:amd.20130514093510.2708: *3* CADP 第二週
電腦輔助使用案例:

使用者(音樂家)利用文字檔案輸入, 透過電腦程式轉換成專業的樂譜.

http://lilypond.org/
.. @+node:amd.20130514093510.2707: *3* CADP 第五週
利用演化方法從事設計

.. code-block:: python

    """Genetic Algorithmn Implementation
    see:
    http://www.obitko.com/tutorials/genetic-algorithms/ga-basic-description.php
    """
    import random
    
    class GeneticAlgorithm(object):
        def __init__(self, genetics):
            self.genetics = genetics
            pass
    
        def run(self):
            population = self.genetics.initial()
            while True:
                fits_pops = [(self.genetics.fitness(ch),  ch) for ch in population]
                if self.genetics.check_stop(fits_pops): break
                population = self.next(fits_pops)
                pass
            return population
    
        def next(self, fits):
            parents_generator = self.genetics.parents(fits)
            size = len(fits)
            nexts = []
            while len(nexts) < size:
                parents = next(parents_generator)
                cross = random.random() < self.genetics.probability_crossover()
                children = self.genetics.crossover(parents) if cross else parents
                for ch in children:
                    mutate = random.random() < self.genetics.probability_mutation()
                    nexts.append(self.genetics.mutation(ch) if mutate else ch)
                    pass
                pass
            return nexts[0:size]
        pass
    
    class GeneticFunctions(object):
        def probability_crossover(self):
            r"""returns rate of occur crossover(0.0-1.0)"""
            return 1.0
    
        def probability_mutation(self):
            r"""returns rate of occur mutation(0.0-1.0)"""
            return 0.0
    
        def initial(self):
            r"""returns list of initial population
            """
            return []
    
        def fitness(self, chromosome):
            r"""returns domain fitness value of chromosome
            """
            return len(chromosome)
    
        def check_stop(self, fits_populations):
            r"""stop run if returns True
            - fits_populations: list of (fitness_value, chromosome)
            """
            return False
    
        def parents(self, fits_populations):
            r"""generator of selected parents
            """
            gen = iter(sorted(fits_populations))
            while True:
                f1, ch1 = next(gen)
                f2, ch2 = next(gen)
                yield (ch1, ch2)
                pass
            return
    
        def crossover(self, parents):
            r"""breed children
            """
            return parents
    
        def mutation(self, chromosome):
            r"""mutate chromosome
            """
            return chromosome
        pass
    
    if __name__ == "__main__":
        """
        example: Mapped guess prepared Text
        """
        class GuessText(GeneticFunctions):
            def __init__(self, target_text,
                         limit=200, size=400,
                         prob_crossover=0.9, prob_mutation=0.2):
                self.target = self.text2chromo(target_text)
                self.counter = 0
    
                self.limit = limit
                self.size = size
                self.prob_crossover = prob_crossover
                self.prob_mutation = prob_mutation
                pass
    
            # GeneticFunctions interface impls
            def probability_crossover(self):
                return self.prob_crossover
    
            def probability_mutation(self):
                return self.prob_mutation
    
            def initial(self):
                return [self.random_chromo() for j in range(self.size)]
    
            def fitness(self, chromo):
                # larger is better, matched == 0
                return -sum(abs(c - t) for c, t in zip(chromo, self.target))
    
            def check_stop(self, fits_populations):
                self.counter += 1
                if self.counter % 10 == 0:
                    best_match = list(sorted(fits_populations))[-1][1]
                    fits = [f for f, ch in fits_populations]
                    best = max(fits)
                    worst = min(fits)
                    ave = sum(fits) / len(fits)
                    print(
                        "[G %3d] score=(%4d, %4d, %4d): %r" %
                        (self.counter, best, ave, worst,
                         self.chromo2text(best_match)))
                    pass
                return self.counter >= self.limit
    
            def parents(self, fits_populations):
                while True:
                    father = self.tournament(fits_populations)
                    mother = self.tournament(fits_populations)
                    yield (father, mother)
                    pass
                pass
    
            def crossover(self, parents):
                father, mother = parents
                index1 = random.randint(1, len(self.target) - 2)
                index2 = random.randint(1, len(self.target) - 2)
                if index1 > index2: index1, index2 = index2, index1
                child1 = father[:index1] + mother[index1:index2] + father[index2:]
                child2 = mother[:index1] + father[index1:index2] + mother[index2:]
                return (child1, child2)
    
            def mutation(self, chromosome):
                index = random.randint(0, len(self.target) - 1)
                vary = random.randint(-5, 5)
                mutated = list(chromosome)
                mutated[index] += vary
                return mutated
    
            # internals
            def tournament(self, fits_populations):
                alicef, alice = self.select_random(fits_populations)
                bobf, bob = self.select_random(fits_populations)
                return alice if alicef > bobf else bob
    
            def select_random(self, fits_populations):
                return fits_populations[random.randint(0, len(fits_populations)-1)]
    
            def text2chromo(self, text):
                return [ord(ch) for ch in text]
            def chromo2text(self, chromo):
                return "".join(chr(max(1, min(ch, 255))) for ch in chromo)
    
            def random_chromo(self):
                return [random.randint(1, 255) for i in range(len(self.target))]
            pass
    
        GeneticAlgorithm(GuessText("Formosa University")).run()
        pass
        
利用 TSP GA 演算法計算鑽孔的最短刀具路徑:

.. code-block:: python

    #coding: utf-8
    # https://github.com/bobozhengsir/Genetic-Algorithm
    
    import random
    import sys
    from math import sqrt 
    
    # 所謂的程式物件有名稱, 有 cid, 有 x 位置, 有 y 位置
    class City(object):
        """docstring for City"""
        def __init__(self, name, cid, x, y):
            self.name = name
            self.cid = cid
            self.x = x
            self.y = y
    
    # 所謂的路徑, 有路徑排列與路徑距離
    class Route(object):
        """docstring for Route"""
        def __init__(self, route, length):
            self.route = route 
            self.length = length
    
        def __str__(self):
            cityNames = []
            for c in self.route:
                cityNames.append(c.name)
            strCityNames = ",".join(cityNames)
            return strCityNames
    
        def getCityIds(self):
            # self.route 應該是個 list
            cityIds = [c.cid for c in self.route]
            return cityIds
    
        def __cmp__(self, other):
            otherLength = other.length
            if self.length > otherLength:
                return 1
            elif self.length < otherLength:
                return -1
            else:
                return 0
    
    class TspGA(object):
        """docstring for TspGA"""
        def __init__(self, data=None):
            #
            #
            self.POPULATION_SIZE = 10000;
            self.EVOLVING_POPULATION_SIZE = 1000;
            self.ELITISM_PCT = 0.1;
            self.NUMBER_OF_GENERATIONS = 100;
            self.MUTATION_RATE = 0.4;
            self.CROSSOVER_RATE = 0.9;
            self.TOURNAMENT_SIZE = 10;
    
            self.numCities = 0
            self.martix = []
            self.directory = {}
            self.routes = []
    
            self.crossover = self.PMXCrossover
            self.mutate = self.mutateRandomCitySwap
    
            if type(data).__name__ == 'list':
                self.data = data
                self.numCities = len(self.data)
    
        def loadCityData(self, path=''):
            """from the path load all cities data"""
            self.data = []
            self.directory = {}
            try:
                i = 0
                f = open(path)
                for line in f:
                    params = line.split(',')
                    if len(params) == 3:	
                        name = params[0].strip()
                        cid = i
                        x = float(params[1].strip())
                        y = float(params[2].strip())
                        c = City(name, cid, x, y)
                        self.data.append(c)
                        self.directory[cid] = c
                        i += 1
                self.numCities = len(self.data)
                self.createMartix()
            except Exception as e:
                raise e
            finally:
                f.close()
            self.numCities = len(self.data)
            self.createMartix()
    
        def createMartix(self):
            """create martix about cities' distances"""
            self.martix = [[0.0 for i in range(self.numCities)] for j in range(self.numCities)]
            for i in range(self.numCities - 1):
                self.martix[i][i] = 0.0
                city1 = self.data[i]
                for j in range(i + 1, self.numCities):
                    city2 = self.data[j]
                    delta_x = float(city1.x - city2.x)
                    delta_y = float(city1.y - city2.y)
                    distance = round(sqrt(delta_x**2 + delta_y**2))
                    self.martix[i][j] = distance
                    self.martix[j][i] = distance
            self.martix[self.numCities - 1][self.numCities - 1] = 0.0
    
        def calcRouteLength(self, cities=[]):
            # 終於找到錯誤, 因為原先程式沒有下一行
            self.cities = cities
            """calc route length"""
            distance = 0.0
            cid1 = self.cities[0].cid
            for i in range(1, self.numCities):
                cid2 = self.cities[i].cid
                distance += self.martix[cid1][cid2]
                cid1 = cid2
            # plus the distance between last city and first city
            distance += self.martix[cid1][self.cities[0].cid]
            return distance
    
        def nearestNeighborTour(self, city):
            """as a city and calc the nearest Neighbor tour 
            return a Route"""
            if type(city).__name__ == 'City':
                cityList = []
                citiesVisited = []
                for i in range(self.numCities):
                    cityList.append(city)
                    cid = city.cid
                    citiesVisited.append(cid)
                    minDist = 10E10 # select a big float number
                    index = 0
                    for x in range(self.numCities):
                        val = self.martix[cid][x]
                        if x not in citiesVisited and val < minDist:
                            minDist = val
                            index = x
                    city = self.directory[index]
                r = Route(cityList, self.calcRouteLength(cityList))
                return r
    
        def createPopulation(self):
            """first create the initial population of randomized routes.
            second pick the fittest routes to form the evolving population."""
            init_routes = []
            cities = self.data[:]
            for i in range(self.POPULATION_SIZE):
                random.shuffle(cities)
                r = Route(cities, self.calcRouteLength(cities))
                init_routes.append(r)
            for x in range(self.numCities):
                init_routes.append(self.nearestNeighborTour(self.data[x]))
            sort_init_routes = sorted(init_routes, key=lambda x: x.length)
            self.routes = sort_init_routes[:self.EVOLVING_POPULATION_SIZE]
    
        def solve(self):
            self.createPopulation()
            for i in range(self.NUMBER_OF_GENERATIONS):
                self.evolve()
    
        def evolve(self):
            """evolve operator"""
            generation_sizes = int(round((1 - self.ELITISM_PCT) * self.EVOLVING_POPULATION_SIZE))
            newChildren = []
            for x in range(generation_sizes):
                # Randomly select a set of routes to vie for the right to parent.
                possibleParents = []
                for i in range(self.TOURNAMENT_SIZE):
                    index = random.randrange(len(self.routes))
                    possibleParents.append(self.routes[index])
                possibleParents = sorted(possibleParents, key=lambda p: p.length)
                dad = possibleParents[0]
                mom = possibleParents[1]
                children = []
                if random.random() > self.CROSSOVER_RATE:
                    children = self.crossover(dad, mom)
                else:
                    children = [dad, mom]
                if random.random() <= self.MUTATION_RATE:
                    children = map(self.mutate, children)
                newChildren.extend(children)
            newChildren.extend(self.routes[:self.EVOLVING_POPULATION_SIZE - generation_sizes])
            newChildren = sorted(newChildren, key= lambda new : new.length)
            self.routes = []
            self.routes = newChildren[:self.EVOLVING_POPULATION_SIZE]
            
    
        def PMXCrossover(self, crossDad, crossMom):
            """partially mapped crossover"""
            childCityIds1 = []
            childCityIds2 = []
            x = random.randrange(self.numCities)
            y = random.randrange(self.numCities)
            if x > y:
                x,y = y,x
            dadCityIds = crossDad.getCityIds()
            #dadParts = []
            dadParts = dadCityIds[x:y+1]
            momCityIds = crossMom.getCityIds()
            #momParts =[]
            momParts = momCityIds[x:y+1]
            dadPartMap = dict(zip(dadParts, momParts))
            momPartMap = dict(zip(momParts, dadParts))
            # crossover and create one child
            for i in range(x):
                if dadCityIds[i] in momParts:
                    childCityIds1.append(momPartMap[dadCityIds[i]])
                else:
                    childCityIds1.append(dadCityIds[i])
            childCityIds1.extend(momParts)
            for j in range(y+1, self.numCities):
                if dadCityIds[j] in momParts:
                    childCityIds1.append(momPartMap[dadCityIds[j]])
                else:
                    childCityIds1.append(dadCityIds[j])
            # create two child
            for i in range(x):
                if momCityIds[i] in dadParts:
                    childCityIds2.append(dadPartMap[momCityIds[i]])
                else:
                    childCityIds2.append(momCityIds[i])
            childCityIds2.extend(dadParts)
            for j in range(y+1, self.numCities):
                if momCityIds[j] in dadParts:
                    childCityIds2.append(dadPartMap[momCityIds[j]])
                else:
                    childCityIds2.append(momCityIds[j])
            childCities1 = [self.directory[m] for m in childCityIds1]
            child1 = Route(childCities1, self.calcRouteLength(childCities1))
            childCities2 = [self.directory[n] for n in childCityIds2]
            child2 = Route(childCities2, self.calcRouteLength(childCities2))
            #print(child1, child2)
            return [child1, child2]
    
        def mutateRandomCitySwap(self, chromosome):
            """Randomly swap two cities in the route."""
            if type(chromosome).__name__ == 'Route':
                cityArray = chromosome.route
                cityArray = cityArray[:self.numCities]
                c1 = random.randrange(self.numCities)
                c2 = random.randrange(self.numCities)
                # cityArray[c1], cityArray[c2] = cityArray[c2], cityArray[c1]
                temp = cityArray[c1]
                cityArray[c1] = cityArray[c2]
                cityArray[c2] = temp
                newChromosome = Route(cityArray, self.calcRouteLength(cityArray))
                return newChromosome
    
    
    def main():
        """Run the algorithm a number of times and take the best result."""
        EVOLUTIONS = 50
        best = []
        tsp = TspGA()
        #tsp.loadCityData(sys.argv[1])
        tsp.loadCityData("cities.in")
        for x in range(EVOLUTIONS):	
            tsp.solve()
            tsp.routes.sort(key=lambda r : r.length)
            best.append(tsp.routes[0])
            print("Evolving %d :get the best length %f" % (x, tsp.routes[0].length))
        best = sorted(best, key=lambda l: l.length)
        print("EVOLUTIONS RESULTS:")
        for y in range(EVOLUTIONS):
            print(str(best[y]))
        print("The best result is %s " % str(best[0]))
        print("The min length is %f" % best[0].length)
    
    if __name__ == '__main__':
            main()	
    
    # 最短距離 57?
    '''
    cities.in
    A, 0, 0
    B, 1, 0
    C, 2, 0
    D, 3, 0
    E, 4, 30
    F, 5, 0
    G, 6, 0
    H, 7, 0
    I, 8, 20
    J, 9, 0
    K, 10, 0
    L, 11, 0
    M, 12, 0
    N, 13, 0
    O, 14, 0
    P, 15, 0
    Q, 15, 1
    R, 15, 2
    S, 15, 3
    T, 15, 4
    U, 15, 5
    V, 15, 6
    W, 15, 7
    X, 15, 8
    Y, 15, 9
    Z, 15, 10
    AA, 15, 11
    BB, 15, 12
    CC, 15, 13
    DD, 15, 14
    EE, 15, 15
    FF, 14, 15
    GG, 13, 15
    HH, 12, 15
    II, 11, 15
    JJ, 10, 15
    KK, 9, 15
    LL, 8, 15
    MM, 7, 15
    NN, 6, 15
    OO, 5, 15
    PP, 4, 15
    QQ, 3, 15
    RR, 2, 15
    SS, 1, 15
    TT, 0, 15
    UU, 0, 14
    VV, 0, 13
    WW, 0, 12
    XX, 0, 11
    YY, 0, 10
    ZZ, 0, 9
    AAA, 0, 8
    BBB, 0, 7
    CCC, 0, 6
    DDD, 0, 5
    EEE, 0, 4
    FFF, 0, 3
    GGG, 0, 2
    HHH, 0, 1
    '''

利用基因演算法進行產品的幾何約束設計:

.. code-block:: python

    #encoding=utf8
    # genetic.py
    #
    import random
    import operator
    MAXIMIZE, MINIMIZE = 11, 22
    class Individual:
        chromosome = None
        score = None
        # Here the size of var depends on var_number
        var = []
        var_number = 2
        for i in range(var_number):
            var.append(0)
        alleles = (0,1)
        # 以下為參數可負數時的編碼考量
        #前10為小數,後10為整數,第21則為正負號
        #0~9表示小數,10~19表示整數,而指標第20則表示第一數的正號或負號,若為0則表示正,若為1表示負號.
        #21~30表示第二數的小數部分,31~40則表示第二數的整數部分,第41指標則表示第二數的正號或負號
        #42~51表示第三數的小數部分,52~61則表示第二數的整數部分,第62指標則表示第三數的正號或負號
        # -1023 ~ 1023
        #length = 21*var_number,若接受負數參數,則必須同步修改 20->21
        length = 20*var_number
        seperator = ''
        optimization = MINIMIZE
        def __init__(self, chromosome=None):
            self.chromosome = chromosome or self._makechromosome()
            self.score = None  # set during evaluation
        def _getvar(self,chromosome=None):
            x = 0
            for i in range(0,self.var_number):
                for j in range(i*20,i*20+10):
                    x +=self.chromosome[j]<<(j-(i*20))
                if (x>999):
                    x=999
                x/=1000.
                for j in range(i*20+10,i*20+20):
                    x +=self.chromosome[j]<<(j-(i*20+10))
                self.var[i] = x
            return self.var
            ''' for -1023 ~ 1023,當設計變數可以接受負值時使用,每一變數使用21個 bit strings
    #for design variable -1023 ~1023
            for i in range(self.var_number):
                x = 0
                for j in range(i*21,i*21+10):
                    x +=self.chromosome[j]<<(j-(i*21))
                if (x>999):
                    x=999
                x/=1000.
                for j in range(i*(21)+10,i*(21)+20):
                    x +=self.chromosome[j]<<(j-(i*21+10))
                if(self.chromosome[i*(21)+20] == 1):
                    self.var[i] = -x
                else:
                    self.var[i] = x
                x = 0
            return self.var
            '''
        def _makechromosome(self):
            "makes a chromosome from randomly selected alleles."
            return [random.choice(self.alleles) for gene in range(self.length)]
        def evaluate(self, optimum=None):
            "this method MUST be overridden to evaluate individual fitness score."
            pass
        def crossover(self, other):
            "override this method to use your preferred crossover method."
            return self._twopoint(other)
        def mutate(self, gene):
            "override this method to use your preferred mutation method."
            self._pick(gene)
        # sample mutation method
        def _pick(self, gene):
            "chooses a random allele to replace this gene's allele."
            self.chromosome[gene] = random.choice(self.alleles)
        # sample crossover method
        def _twopoint(self, other):
            "creates offspring via two-point crossover between mates."
            left, right = self._pickpivots()
            def mate(p0, p1):
                chromosome = p0.chromosome[:] # 交配時,以p0的基因為基礎(複製整個 p0 的染色體內容
                chromosome[left:right] = p1.chromosome[left:right] # 接續上一個 p0 的染色體內容,將索引 left 至 right 的內容,替換成 p1 的基因
                #child = p1.__class__(chromosome) 這是原先的程式,但是應該子代要指向 p0 的內容才對
                child = p0.__class__(chromosome)
                child._repair(p0, p1)
                return child
            return mate(self, other), mate(other, self)
        # some crossover helpers ...
        def _repair(self, parent1, parent2):
            "override this method, if necessary, to fix duplicated genes."
            pass
        def _pickpivots(self):
            left = random.randrange(1, self.length-2)
            right = random.randrange(left, self.length-1)
            return left, right
        #
        # other methods
        #
        def __repr__(self):
            "returns string representation of self"
            '''
            return '<%s chromosome="%s" score=%s var=%s>' % \
                   (self.__class__.__name__,
                    self.seperator.join(map(str,self.chromosome)), self.score,self._getvar(self.chromosome))
            '''
            return '<%s score=%s var=%s>' % \
                   (self.__class__.__name__,self.score,self._getvar(self.chromosome))
        # since the __cmp__ special function is gone  use the __lt__ in stead
        # use the expression (a > b) - (a < b) as the equivalent for cmp(a, b)
        #def __cmp__(self, other):
        # these are for python 3
        def __cmp__(self, other):
            if self.optimization == MINIMIZE:
                #return cmp(self.score, other.score)
                return (self.score > other.score) - (self.score < other.score)
            else: # MAXIMIZE
                #return cmp(other.score, self.score)
                return (other.score > self.score) - (other.score < self.score)
                
        def __lt__(self, other):
            return self.__cmp__(other) < 0
        def __le__(self, other):
            return self.__cmp__(other) <= 0
        def __gt__(self, other):
            return self.__cmp__(other) > 0
        def __ge__(self, other):
            return self.__cmp__(other) >= 0 
        def copy(self):
            twin = self.__class__(self.chromosome[:])
            twin.score = self.score
            return twin
    class Environment(object):
        x = [0]
        y = [0]
        def __init__(self, kind, population=None, size=100, maxgenerations=100,
                     crossover_rate=0.90, mutation_rate=0.07, optimum=None):
            self.kind = kind
            self.size = size
            self.optimum = optimum
            self.population = population or self._makepopulation()
            for individual in self.population:
                individual.evaluate(self.optimum)
            self.crossover_rate = crossover_rate
            self.mutation_rate = mutation_rate
            self.maxgenerations = maxgenerations
            self.generation = 0
            self.report()
        def _makepopulation(self):
            return [self.kind() for individual in range(self.size)]
        def run(self):
            while not self._goal():
                self.step()
        def _goal(self):
            return self.generation > self.maxgenerations or \
                   self.best.score == self.optimum
        def step(self):
            # this sort is not working with python 3.0, modification is needed
            self.population.sort()
            self._crossover()
            self.generation += 1
            self.report()
            self.x.append(self.generation)
            # 設定為只附加所選定範圍的值,這裡只取大於或等於 0 的 score 值
            if self.best.score <=5:
                self.y.append(self.best.score)
            else:
                self.y.append(5)
        def _crossover(self):
            next_population = [self.best.copy()]
            while len(next_population) < self.size:
                mate1 = self._select()
                if random.random() < self.crossover_rate:
                    mate2 = self._select()
                    offspring = mate1.crossover(mate2)
                else:
                    offspring = [mate1.copy()]
                for individual in offspring:
                    self._mutate(individual)
                    individual.evaluate(self.optimum)
                    next_population.append(individual)
            self.population = next_population[:self.size]
        def _select(self):
            "override this to use your preferred selection method"
            return self._tournament()
        def _mutate(self, individual):
            for gene in range(individual.length):
                if random.random() < self.mutation_rate:
                    individual.mutate(gene)
        #
        # sample selection method
        #
        def _tournament(self, size=8, choosebest=0.90):
            competitors = [random.choice(self.population) for i in range(size)]
            competitors.sort()
            if random.random() < choosebest:
                return competitors[0]
            else:
                return random.choice(competitors[1:])
        def best():
            doc = "individual with best fitness score in population."
            def fget(self):
                return self.population[0]
            return locals()
        best = property(**best())
        def report(self):
            print ("="*70)
            print ("generation: ", self.generation)
            print ("best:       ", self.best)
    
    # 以上為 genetic.py 目前將兩者結合在一起
    #encoding=utf8
    # volume.py - useage example
    #
    # the fittest individual will have a chromosome consisting of 40 '1's
    #
    #
    #import genetic
    #此一加總函式在 volume 最大化中,並未使用
    def sum(seq):
        def add(x,y): return x+y
        return reduce(add, seq, 0)
    class Volume(Individual):
        optimization = MAXIMIZE
        def evaluate(self, optimum=None):
            SURFACE = 80
            # self.score is the fitness value
            # x 由0.001~1023.999,利用二位元的移位運算子<<進行計算
            # 第一階段,根據變數個數,自行計算整數與小數加總
            '''
            for j in range(10):
                x +=self.chromosome[j]<<(j-0)
            if (x>999):
                x=999
            x/=1000.
            for j in range(10,20):
                x +=self.chromosome[j]<<(j-10)
            # calculate y
            for j in range(20,30):
                y +=self.chromosome[j]<<(j-20)
            if (y>999):
                y=999
            y/=1000.
            for j in range(30,40):
                y +=self.chromosome[j]<<(j-30)
                
            z=(SURFACE - x*y)/(2.*(x+y))
            fitness_value = x*y*z
            #self.score = sum(self.chromosome[10:20])
            self.score = fitness_value
            #第二階段,將各變數計算以變數個數,利用迴圈進行運算
            x = 0
            for i in range(0,self.var_number):
                for j in range(i*20,i*20+10):
                    x +=self.chromosome[j]<<(j-(i*20))
                if (x>999):
                    x=999
                x/=1000.
                for j in range(i*20+10,i*20+20):
                    x +=self.chromosome[j]<<(j-(i*20+10))
                self.var[i] = x
            '''
            #第三階段,在實用上,將上述運算,寫進個別成員類別中,透過呼叫成員函式,取得各變數值
            self._getvar(self.chromosome)
            
            x = self.var[0]
            y = self.var[1]
            z=(SURFACE - x*y)/(2.*(x+y))
            fitness_value = x*y*z
            
            self.score = fitness_value
            
        def mutate(self, gene):
            self.chromosome[gene] = not self.chromosome[gene] # bit flip
       
    if __name__ == "__main__":
        env = Environment(Volume, size=500, maxgenerations=100)
        env.run()
.. @+node:amd.20130514093510.2710: *3* CADP 第六週
求動態機械系統的特徵值:

http://mbi-wiki.uni-wuppertal.de/en/python/feder-massen-systeme-ein-python-programm-fur-die-berechnung-der-eigenfrequenzen/
.. @+node:amd.20130514093510.2711: *3* CADP 第七週
https://github.com/Obijuan/Miniskybot

http://scipy-lectures.github.io/

http://pandas.pydata.org/

http://www.chronoengine.info/mediawiki/index.php/Unit_PYTHON

http://www.vectioneer.com/

https://github.com/Rod-Persky/pyIGES

http://code.google.com/p/robotics-toolbox-python/

http://garethrees.org/2011/07/04/strandbeest/strandbeest.html

virtual robot simulation

http://www.v-rep.eu/index.html

python for v-rep

http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm

http://humanoids.dem.ist.utl.pt/Iden_external/overview.html

https://github.com/CreativeMachinesLab/aracna
.. @+node:amd.20130515005753.3889: *3* CADP 第八週
.. @-all
.. @-leo
