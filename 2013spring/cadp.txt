.. @+leo-ver=5-thin
.. @+node:amd.20130514093510.2704: * @file cadp.txt
.. @@language rest
.. @@tabwidth -4

.. @+at @rst-options
..  call_docutils=False
..  code_mode=False
..  generate_rst=True
..  http_server_support = False
..  show_organizer_nodes=True
..  show_headlines=True
..  show_leo_directives=True
..  stylesheet_path=..\doc
..  write_intermediate_file = True
..  verbose=True
.. @@c

.. @+all
.. @+node:amd.20130514093510.2705: ** @rst document/cadp.html
#######################################
電腦輔助設計實習
#######################################

.. index:: 電腦輔助設計實習

.. contents::
    :depth: 3
.. @+node:amd.20130514093510.2706: *3* CADP 第一週
假如電腦輔助設計只是教導學生使用某套 MCAD(Mechanical Computer Aided Design), 例如 SolidWorks, Inventor, Creo, NX 或 Catia, 那麼未來將會短少很多高性能的創新性機械產品(包括工具與環境).

電腦輔助設計的本質在學習如何引導機械設計工程師利用電腦提高設計內涵、加速設計流程並有效整合志同道合的全球化設計趨勢.

- 利用電腦提高設計內涵, 電腦的基本功能在運算(正確且快速的計算)、模擬(讓模型在各種可能的情境中呈現結果)與資料處理(海量資料的處置與管理).

- 利用電腦加速設計流程, 透過高速且正確的運算得到可參考的數據, 利用擬真的模擬來降低開銷與風險, 利用電腦來處置管理複雜的資料, 讓海量資料成為有用數據進而成為設計團隊的知識.

- 有效整合志同道合的全球化設計, 利用電腦與網路架構來配置安全且可永續演化的協同設計環境.

因此電腦輔助設計就機械設計領域中的學習任務:

- 如何地用電腦執行正確且快速的計算: 建立模型執行運算, 既存運算套件的應用、打造各種運算套件

- 如何讓模型在各種情境與條件下呈現類真實的結果: 電腦 2D/3D 繪圖, 既存模擬套件的應用、打造各種模擬運算套件

- 如何處置海量資料, 如何管理海量資料: 電子資料處理、日誌建構、資料轉檔、內容管理

- 如何建立安全的網路使用環境: 單機、網路、隨身平台建構與維護

- 如何建立可永續演化的協同設計環境: 平台上的設計元件建構、既有套件的延伸、資料備援與典範轉移(當平台因各種因素而不復存在, 知識、技術與內容該如何轉移、如何延續)

課程基礎:

- 基本的機械設計概念

- 基本的程式語言基礎

- 基本的英文解讀能力

- 基本的自我閱讀能力
.. @+node:mde.20130609005025.2822: *4* 網際內容管理
有關 nginx 的 access control, 與 Apache .htaccess 的控管概念正好相反, Apache 先 deny 全部連線, 然後再 allow 例外的連線

nginx 則先 allow 相關連線, 然後再 deny 其它之外的"所有"連線, 以下 nginx.conf 設定, 只允許 127.0.0.1 連線

.. code-block:: none

    location / {
        root   html;
        index  index.html index.htm index.php;
        # This always returns a 403. Probably it isn't what you want.
        allow   127.0.0.1;
        # 允許 192.168.1.0 ~192.168.1.255 IP 連線
        allow 192.168.1.0/24;
        deny all;
    }
 
其他 CMSimple 與 nginx 結合使用的系統檔案保護設定:

.. code-block:: none

    # 保護 CMSimple 對應下的 cmsimple, template 與 content 目錄無法直接擷取檔案
    location ~ /(cmsimple``|templates|``content)/ {
        deny        all;
    }
    
CMSimple downloads 與 images 目錄則依賴 index.html 進行保護
.. @+node:mde.20130604110320.2784: *4* MCAD 套件選擇
Mechanical Computer Aided Design(MCAD) 套件:

高端: Catia, NX, Creo

中端: SolidWorks, Solid Edge, Inventor

開源: FreeCAD

目前提供免費學生版的套件有:

AutoDesk Inventor, PTC Creo, Siemens Solid Edge, 其中又以 Solid Edge 的學生授權最為自由, 因此 2013 Fall 電腦輔助設計課程將採用 Solid Edge 與 FreeCAD, 而 Inventor 與 Creo 則用來輔助教學.
.. @+node:mde.20130609005025.2829: *4* 參考資料
Exploring Creo Parametric

http://www.youtube.com/watch?v=Orbiquo2dOE

https://sites.google.com/a/mde.tw/service/2012_fall_cadp/Creo%20Exploring%20the%20Creo%20Parametric%20Interface.flv?attredirects=0&d=1

Creo Parametric 1.0 introduction

http://www.youtube.com/watch?v=xHKsoYFGlaY

Creo Overview

http://www.youtube.com/watch?v=qugde3gXaFg

Getting started with Creo Parametic

http://www.youtube.com/playlist?list=PL38B7CAC223A4859D

Design Productivity

http://www.youtube.com/watch?v=5gG9IeoZtrA

Assembly modeling

http://www.youtube.com/watch?v=Q_QhR53FjNE

http://www.youtube.com/watch?v=d7s9OD4p8CU

Exploding Assembly

http://www.youtube.com/watch?v=bHpAS4LQulo

Creating Part

http://www.youtube.com/watch?v=wEeiOnrLsTo

Helical sweep

http://www.youtube.com/watch?v=vReXjIITcj4

Parametric  Webnair

http://www.youtube.com/watch?v=4Hw6W5zO04w

http://www.youtube.com/watch?v=vVsMlvWNnVk

Large assembly

http://www.youtube.com/watch?v=qkZUrVkX8H8

Simulate Webnair

http://www.youtube.com/watch?v=osa76tUkZPc

http://www.youtube.com/watch?v=j8Kf-mM7tiU

Sheet Metal (more)

http://www.youtube.com/watch?v=sow4sK1AZS8

Sweep (static)

http://www.youtube.com/watch?v=R7NSEXvOrHw

Solid Modeling

http://www.youtube.com/watch?v=jd6Z12H6OC0

https://sites.google.com/a/mde.tw/service/2012_fall_cadp/5%20Cool%20Things%20in%20Creo%20Parametric.flv?attredirects=0&d=1

https://sites.google.com/a/mde.tw/service/2012_fall_cadp/Creo%20Adding%20Dimensions%20to%20a%20Sketch.flv?attredirects=0&d=1

https://sites.google.com/a/mde.tw/service/2012_fall_cadp/Creo%20Creating%20a%20Cube%20in%20Creo%20Parametric%201.0.flv?attredirects=0&d=1

https://sites.google.com/a/mde.tw/service/2012_fall_cadp/Creo%20Creating%20a%20Cube%20in%20Creo%20Parametric%201.0.flv?attredirects=0&d=1

https://sites.google.com/a/mde.tw/service/2012_fall_cadp/Creo%20Creating%20a%20Rod%20in%20Creo%20Parametric%201.0.flv?attredirects=0&d=1

https://sites.google.com/a/mde.tw/service/2012_fall_cadp/Creo%20Editing%20Features%20using%20Edit%20Definition.flv?attredirects=0&d=1

https://sites.google.com/a/mde.tw/service/2012_fall_cadp/Creo%20Introduction%20to%20the%20Sketch%20Tool-1.flv?attredirects=0&d=1

https://sites.google.com/a/mde.tw/service/2012_fall_cadp/Creo%20Sketching%20Rectangles%20and%20Parallelograms.flv?attredirects=0&d=1

https://sites.google.com/a/mde.tw/service/2012_fall_cadp/Creo%20Using%20the%20Measure%20Tools.flv?attredirects=0&d=1

https://sites.google.com/a/mde.tw/service/2012_fall_cadp/Creo%20Creating%20Driven%20Dimensions-1.m4v?attredirects=0&d=1

A driven dimension is created in a drawing.  The dimensions displayed value is based upon the geometry selected when the dimension is created. Driven dimensions are only displayed on the drawing that they were created in and can not be used update the geometry of the model. They are driven by the model's geometry when the model's geometry changes driven dimensions referencing that geometry will update accordingly. In this drawing the location of these two holes is defined by this fourteen dimension from the center of the hole to some location located near the center of the model. In order to manufacture this part a dimension needs to be added that references the right edge of the model. Something that can be referenced when locating the center of the hole. Before creating that dimension let's make this one into a reference dimension. To do this, select the dimension right clicked and select properties from the pop-up menu. In the display tab add a suffix of REF indicating that as a reference dimension. Note that the dimension could've also just be erased. To create the new dimension open the entity tab and in the annotaion tab click dimension new references. To define the driven dimension,  select the edge of the part and then the outer edge of the hole. Middle click here to place the dimensions value and then click center to define the dimensions attachment to the hole. In the annotations note of the top view notice that the driven dimension we created is listed as a draft dimension rather than a model dimension. This is because the dimension is created in displayed in the drawing not the model. Before finishing let's test the new dimension to make sure that it's driven by the geometry of the model. Edit the value of the model dimension and then regenerate the model. We can see that by changing the geometry the dimension that was just created has been changed to twenty. Driven dimensions ebable dimension schemes shown in your 2d drawing to be updated automatically.

https://sites.google.com/a/mde.tw/service/2012_fall_cadp/Creo%20Creating%20Solid%20Extrude%20Features-1.m4v?attredirects=0&d=1

https://sites.google.com/a/mde.tw/service/2012_fall_cadp/Creo%20Customizing%20the%20Ribbon%20Interface-1.m4v?attredirects=0&d=1

https://sites.google.com/a/mde.tw/service/2012_fall_cadp/Creo%20Parametric%20Creating%20Relations-1.m4v?attredirects=0&d=1

https://sites.google.com/a/mde.tw/service/2012_fall_cadp/Creo%20Showing%20Erasing%20and%20Deleting%20Annotations-1.m4v?attredirects=0&d=1

https://sites.google.com/a/mde.tw/service/2012_fall_cadp/Creo%20Understanding%20the%20Ribbon%20Interface-1.m4v?attredirects=0&d=1
.. @+node:amd.20130514093510.2708: *3* CADP 第二週
電腦輔助使用案例:

使用者(音樂家)利用文字檔案輸入, 透過電腦程式轉換成專業的樂譜.

http://lilypond.org/
.. @+node:mde.20130608155347.2811: *4* Creo 的二次開發
.. @+node:mde.20130608155347.2812: *5* J-Link
J-Link 程式環境設定:

. 安裝 Creo 時必須同時在 Parametric 模組設定安裝 JRE.

. 安裝最新的 JDK.

. start_kmol.bat 啟動檔案中, 必須設定下列與 Java 有關的環境變數:

REM 設定 Jdk 路徑, 特別注意 CLASSPATH 後的分號, 一定要有
set JAVA_HOME=%Disk%:\IDE\Java\jdk1.7.0_21
set CLASSPATH=.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;%Disk%:\pfc.jar;"D:\Creo2\Common Files\M040\i486_nt\obj\JRE\lib";
set PRO_JAVA_COMMAND=%Disk%:\IDE\Java\jdk1.7.0_21\bin\java
set jlink_java_command=%Disk%:\IDE\Java\jdk1.7.0_21\bin\java

. 確定 config.pro 中是否加入 regen_failure_handling resolve_mode 設定, 讓 Creo 配合程式自動更新.

. 使用 Creo 內建的 J-Link InstallTest 程式進行編譯後, 測試是否可以正確啟動.

同步 J-Link 應用程式

A synchronous J-Link application is started and managed by Creo Parametric.

Control belongs to either Creo Parametric or the application, but not both at the
same time.

非同步 J-Link 應用程式

An asynchronous application is started independent of Creo Parametric with
the option to start or connect to Creo Parametric processes.

Standalone Applications

You can start the J-Link application independently at any time, regardless of
which models are in session. A registry file contains key information regarding
the execution of the program.

Registry File

A registry file contains Creo Parametric-specific information about the standalone
application you want to load.

The registry file called creotk.dat is a simple text file, where each line
consists of one predefined keyword followed by a value. The standard form of
the creotk.dat file is as follows:

name     InstallTest
startup  java
java_app_class  StartInstallTest
java_app_start  start
java_app_stop   stop
allow_stop      true
delay_start     false
text_dir        ./text
end
.. @+node:mde.20130609005025.2810: *6* J-Link 程式範例
J-Link is a Java language API for Creo free-of-charge that is build on top of the Pro/TOOLKIT API.

It allows the development of Java programs to access the internal components of a Creo session, to customize models.

With J-Link being a object oriented programming tool, the Creo user gains a powerful tool for expanding, customizing and automating the functionality of Creo and Windchill. J-Link is part of the PTC Foundation Class (PFC) package.

Benefits Includes:

. No Separate or Additional Licensing

. Hardware Platform Independed

. Object Oriented Programming

. Object Reuse

. Create GUI easily

. Free Java IDE

. Seamlessly embeded custom process

. Fully Supported

. Asynchronous & Synchronous Application

A synchronous J-Link application is started and managed by Creo Parametric.
Control belongs to either Creo Parametric or the application, but not both at the
same time.

An asynchronous application is started independent of Creo Parametric with
the option to start or connect to Creo Parametric processes.

You can run synchronous J-Link programs as standalone applications or
model-specific programs.

Most of the required settings for these two programs are independent of the programs themselves. This enables you to convert an application program to a model program, or vice versa.

A registry file contains Creo Parametric-specific information about the standalone
application you want to load.

The registry file called protk.dat is a simple text file, where each line consists
of one predefined keyword followed by a value. The standard form of the
protk.dat file is as follows:

name   java_demo
startup java
java_app_class      MyJavaApp
java_app_start      start
java_app_stop        stop
allow_stop true
delay_start true
text_dir 
end

another registry file example:

name               JLinkHelloWorld-App
startup            java
java_app_class     JLinkHelloWorld
java_app_start     startApp
java_app_stop      stopApp
allow_stop         true
delay_start        false
text_dir           V:/apps/JLinkHelloWorld/text
java_app_classpath V:/apps/JLinkHelloWorld
end
 
.. code-block:: java

    // JLinkHelloWorld.java
    // Copyright 2009, MarcMettes@InversionConsulting.com
    // imports required
    import com.ptc.cipjava.*;
    import com.ptc.pfc.pfcCommand.*;
    import com.ptc.pfc.pfcGlobal.*;
    import com.ptc.pfc.pfcModel.*;
    import com.ptc.pfc.pfcSession.*;
    import java.io.*;
    public class JLinkHelloWorld {
        static JLinkHelloWorld App = null;
        String programName = null;
        Session session = null;
        FileWriter log = null;
        String msgFile = "msg_jlinkhelloworld.txt";
        String newline = null;
        // constructor
        //
        public JLinkHelloWorld () {
            programName = this.getClass().getName();
            try {
                log = new FileWriter(programName + ".log");
                newline = System.getProperty("line.separator");
            }
            catch (Exception e) {
                // couldn't create log file, ignore
            }
        }
        // Display message in Pro/Engineer
        //
        public void DisplayMessage ( String mesg ) throws Exception {
            stringseq seq = stringseq.create();
            seq.set(0, mesg);
            session.UIDisplayMessage(msgFile, "JLHW %s", seq);
            seq.clear();
            writeLog(mesg);
        }
        // Write text to log file
        //
        public void writeLog ( String mesg ) {
            try {
                if (log == null) { return; }
                log.write(mesg + newline);
                log.flush();
            }
            catch (Exception e) {
                // ignore
            }
        }
        // Close log file
        //
        public void closeLog () {
            try {
                if (log == null) { return; }
                log.close();
            }
            catch (Exception e) {
                // ignore
            }
        }
        // Called by Pro/Engineer when starting the application
        //
        public static void startApp () {
            try {
                App = new JLinkHelloWorld();
                App.startupApplication();
            }
            catch (Exception e) {
                App.writeLog("Problem running startupApplication method" + e.toString());
                return;
            }
        }
        // Called by Pro/Engineer when stopping the application
        //
        public static void stopApp () {
            try {
                App.shutdownApplication();
            }
            catch (Exception e) {
                App.writeLog("Problem running shutdownApplication method" + e.toString());
                return;
            }
        }
        // Perform some steps when shutting down the application
        //
        public void shutdownApplication () throws Exception {
            writeLog("Application '" + programName + "' stopped");
            closeLog();
        }
        // Perform some steps when starting the application
        //
        public void startupApplication () throws Exception {
            try {
                writeLog("Application '" + programName + "' started.");
                session = pfcGlobal.GetProESession();
            }
            catch (jxthrowable x) {
                writeLog("ERROR: Problem getting session object.");
                return;
            }
            UICommand btn1_cmd = null;
            try {
                // Define a UI command
                btn1_cmd = session.UICreateCommand(
                          "JLHW Btn1 Cmd", new JLHW_Btn1_CmdListener()
                      );
            }
            catch (jxthrowable x) {
                writeLog("ERROR: Problem creating uicmd.");
                return;
            }
            try {
                // Add UI command to 'Tools' menu
                session.UIAddButton(
                    btn1_cmd, "Utilities", null,
                    "JLHW Btn1 Label", "JLHW Btn1 Help",
                     "msg_jlinkhelloworld.txt"
                );
            }
            catch (jxthrowable x) {
                writeLog("ERROR: Problem creating menu: " + x.toString());
                return;
            }
            DisplayMessage(programName + " application started.");
        }
        // Callback for the 'Tools' menu button
        //
        public void Btn1_callback ( ) throws Exception {
            String mesg = null;
            Model model = session.GetCurrentModel();
            if (model == null) {
                mesg = "Hello!";
            }
            else {
                mesg = "Hello! The model is: " + model.GetFileName();
            }
            DisplayMessage(mesg);
        }
        // Inner class for UI Command Listener
        //
        public class JLHW_Btn1_CmdListener extends DefaultUICommandActionListener {
            // Handler for button push
            //
            public void OnCommand () {
                try {
                    Btn1_callback();
                }
                catch (Exception e) {
                    writeLog("Exception thrown by Btn1_callback method: " + e.toString());
                }
            }
        }
    }
    
For your asynchronous application to communicate with Creo Parametric, you
must set the environment variable PRO_COMM_MSG_EXE to the full path of the
executable pro_comm_msg.

On Windows systems, set PRO_COMM_MSG_EXE in the Environment section of
the System window that you access from the Control Panel.

To support the asynchronous mode, use the jar file pfcasync.jar in your CLASSPATH. This file is available at \Common Files\\text\java. This file contains all required classes for running with asynchronous J-Link.

You must add the asynchronous library, pfcasyncmt, to your environment that launches the J-Link application. This library is stored in \Common  Files\.

Asynchronous J-Link applications must load the library prior to calls made to the
asynchronous methods. This can be accomplished by adding the following line to
your application.

System.loadLibrary ("pfcasyncmt")

The sample code in the file pfcAsyncStartExample.java located at
/jlink_appls/jlinkasyncexamples

demonstrates how to use J-Link in asynchronous mode. The method starts Creo
Parametric asynchronously, retrieves a Session, and opens a model in Creo Parametric.

Supported Java Virtual Machine Versions

The machine information for the JVM versions supported by J-Link is available at

http://www.ptc.com/partners/hardware/current/jlink.htm

The Creo Parametric installation includes a default JVM shipped as a part of its
CD image. For synchronous J-Link applications, Creo Parametric uses the Creo
Parametric-supplied JVM by default.

Creo Parametric includes the ability to override the default JVM command used to
invoke J-Link applications. This allows you to:

. Use a non-standard JVM in your deployment, if that JVM has a feature or a fix
that is necessary for your application to work correctly.

. Apply command line flags to the Java invocation, thus allowing it to be used
for debugging or other customized purposes.

Overriding the Java command used by Synchronous J-Link

The JVM that is used can be overridden using one of the following mechanisms:

. The configuration option jlink_java_command, if set to the path to the
java executable, will determine the JVM be used to start synchronous J-Link
applications.

. The environment variable PRO_JAVA_COMMAND serves the same purpose as
the configuration option. The environment variable takes precedence over the
configuration option.

CLASSPATH Variables

Synchronous Mode

If you are using the default JVM and are running J-Link applications on your
machine, you need to add only your application classes to the classpath. The
mechanisms to accomplish this are:

. Setting the environment variable CLASSPATH.

. Using the java_app_classpath field in the registry file. This field has a
character limit of 2047 wide characters (wchar_t).

. Loading a user-specified Jar file through the user interface (only available
for a model program).

Creo Parametric will automatically add the J-Link archive pfc.jar to the CLASSPATH.

To compile J-Link applications, the environment variable CLASSPATH must include the path to the locations of classes and archives that you intend to use. 

Also, you must add J-Link archive pfc.jar to the CLASSPATH. This archive is located at \Common Files\\text\java\pfc.jar.

JAVA Options for Asynchronous Mode

Asynchronous mode applications are started by an external Java process. Thus
Creo Parametric does not have any control over them, and you may use any JVM
and command line to invoke them.

Note

Regardless of how the Java process is invoked, it must use the Java command
line flags specified for asynchronous mode under

For both running and compiling, the environment variable CLASSPATH must
point to the locations of the application classes and archives.

The CLASSPATH should also include the path to the J-Link asynchronous mode archive file  pfcasync.jar.

This archive is located at \Common Files\\text\java\pfcasync.jar.

http://www.ptc.com/partners/hardware/current/jlink.htm

protk.dat 檔案

name   InstallTest —該行為程序名，可以任意設定;

startup  java —該行表明為J-link應用程序;

java_app_class  StartInstallTest —該行為 J-link 程序的起始類名, 該類名必須與 J-link 項目的起始類名相一致;

java_app_start  start — 該行為 J-link 起始方法名, 也須與上述 StartInstallTest 類的方法成員名一致;

java_app_stop   stop — 該行為 J-link 結束方法名, 也須與上述StartInstallTest類的方法成員名一致;

allow_stop      true — 設置是否可以在程序運行期間中止, true 為可以中止, false 為不能在運行期間中止;

delay_start     true — 設置是否在 Creo 啟動時 J-link 程序自動運行, 設為 false 則自動運行; true 為不自動運行, 此時需要在 Creo 啟動之後手動執行程序. 

text_dir        ./text — 該行指向目錄, 該目錄包含程序中出現的一些提示信息和菜單按鈕信息文件;

end — 結束符號

系統變數

PRO_JAVA_COMMAND 設為 V:\jdk1.7.0_02\bin\java
jlink_java_command 設為 V:\jdk1.7.0_02\bin\java
.. @+node:mde.20130608155347.2813: *5* Pro/Web.Link
Creo Parametric 模組的程式延伸功能, 以 Object Toolkit 功能最多, 其次為 Toolkit(約 80%)、J-Link(約 65%)、Pro/Web.Link(約 50%) 與 VBapi(約 40%).

WebLink is a Javascript language API for Creo free-of-charge that is build on top of the Pro/TOOLKIT API.

It allows the development of Web Applets to access the internal components of a Creo session, to customize models through the Creo internal web browser.

WebLink is a object oriented programming tool and it can call other J-Link programs. A web configurator can be developed using WebLink.

Benefits Includes:

. No Separate or Additional Licensing

. Hardware Platform Independed

. Object Oriented Programming

. Object Reuse

. Create Web Pages easily

. Free JavaScripting IDE

. Seamlessly embeded custom process

. Fully Supported

. Synchronous Application


config.pro 設定項目分類

以設定項目前的圖標做為辨識

電腦 - 設置後必須重新啟動 Creo 後才會生效的項目.
閃電 - 設定修改後立即生效的項目.
火柴棒 - 只對設定後之新建模型, 工程圖等有效的項目.

Pro/Web.Link 程式執行的條件

1. Creo config.pro 中允許 Javascript 程式的執行, 並且開啟零件自動更新

使用者可以使用各自目錄下的 config.pro 或系統 (位於 Common Files\M0X0\text\ 目錄下) 中的 config.pro

支援網際執行 javascript 程式

web_enable_javascript on

設定 trail.txt 檔案位置 (內定為 Creo 啟動位置)

trail_dir C:\tmp

支援網際修改變數後, 能夠直接更新模型

regen_failure_handling resolve_mode

2.  網站程式可以連結 Pro/Web.Link 所提供的 Javascript 程式庫.

3. IE 瀏覽器信任所要連結, 用來執行 Pro/Web.Link 程式的網站.

允許  IE 啟動信任的網站中的 Active 程式:

Change the setting for Initialize and Script ActiveX controls not marked as safe under ActiveX controls and plugins to Enable.

ActiveX 控制項與插件->起始不標示為安全的 ActiveX 控制項->啟用

Change the setting for Active Scripting under Scripting to Enable.

指令碼處理->Active scripting->啟用

4. 零組件檔案中透過變數設定, 將變數與零組件中的尺寸進行連結對應.

Parameters, Relations, Switch Dimensions

變數格式應用
以下格式可以保證輸出為小數點 2 位數值, 以符合 Creo 系統中的變數 real number 格式.

number_format(floatval($data->var1),2)

.. @+node:mde.20130609005025.2809: *6* Pro/Web.Link 程式範例
.. code-block:: javascript

    <script src="jscript/weblink/pfcUtils.js">
    </script><script  src="jscript/weblink/pfcParameterExamples.js"></script><script  src="jscript/weblink/pfcComponentFeatExamples.js">
     document.writeln ("Error loading script!");
    </script><script language="JavaScript">
          if (!pfcIsWindows())
            netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
      var session = pfcGetProESession ();
    // for volume
      var solid = session.CurrentModel;
        try
            {
                createParametersFromArguments ();
                         solid.Regenerate(void null);   
                            properties = solid.GetMassProperty(void null);
                            alert("零件體積:"+properties.Volume);
            }
        catch (err)
            {
                alert ("Exception occurred: "+pfcGetExceptionType (err));
            }
    </script>

假如能夠從 Assembly 中將 part 的列表存進資料庫, 產品設計者能夠如何運用這些資料?

Pro/Web.Link 將 BOM 存到 Excel

http://inversionconsulting.blogspot.tw/2008/04/proweblink-sending-your-proengineer.html

1. 從一個 Assembly 中設法讀出 part list.

2. 利用重複廻圈取得各 part 的物理資料, 並由 BOM 中對應查詢各 part 所採用的 material.

3. 分別針對各 part 與材料, 計算成本與重量, 再將資料回存至資料庫.

4. 一旦產品設計流程中, 某一項內容進行設計變更, 則重複檢查 BOM, 材料查找, 以及後續的數值運算與應用.

以下 Pro/Web.Link 程式所使用的零組件:

https://sites.google.com/a/mde.tw/service/2013fall_cadp/lego_man.7z?attredirects=0&d=1

.. code-block:: javascript

    <script src="jscript/weblink/pfcUtils.js">
    </script><script src="jscript/weblink/wl_header.js">
    document.writeln ("Error loading Pro/Web.Link header!");
    </script><script language="JavaScript">
    if (!pfcIsWindows()) netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
    // 若第三輸入為 false, 表示僅載入 session, 但是不顯示
    // ret 為 model open return
     var ret = document.pwl.pwlMdlOpen("lego_body.prt", "c:/tmp", false);
    if (!ret.Status) {
        alert("pwlMdlOpen failed (" + ret.ErrorCode + ")");
    }
        //將 ProE 執行階段設為變數 session
        var session = pfcGetProESession();
        // 在視窗中打開零件檔案, 並且顯示出來
        var window = session.OpenFile(pfcCreate("pfcModelDescriptor").CreateFromFileName("lego_body.prt"));
        var solid = session.GetModel("lego_body.prt",pfcCreate("pfcModelType").MDL_PART);
        var d1,d2,myf,myn,i,j,volume,count,d1Value,d2Value;
        // 將模型檔中的 diameter 變數設為 javascript 中的 diameter 變數
        d1 = solid.GetParam("upper");
        // 將模型檔中的 height 變數設為 javascript 中的 height 變數
        d2 = solid.GetParam("lower");
    //改變零件尺寸
        //myf=20;
        //myn=20;
        volume=0;
        count=0;
        try
        {
                // 以下採用 URL 輸入對應變數
                //createParametersFromArguments ();
                // 以下則直接利用 javascript 程式改變零件參數
                for(i=0;i<=12;i++)
                {
                    //for(j=0;j<=2;j++)
                    //{
                        myf=0.7;
                        myn=0.7+i*0.1;
    // 設定變數值, 利用 ModelItem 中的 CreateDoubleParamValue 轉換成 Pro/Web.Link 所需要的浮點數值
             d1Value = pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myf);
             d2Value = pfcCreate ("MpfcModelItem").CreateDoubleParamValue(myn);
    // 將處理好的變數值, 指定給對應的零件變數
                        d1.Value = d1Value;
                        d2.Value = d2Value;
                        //零件尺寸重新設定後, 呼叫 Regenerate 更新模型
                        solid.Regenerate(void null);
                        //利用 GetMassProperty 取得模型的質量相關物件
                        properties = solid.GetMassProperty(void null);
                        //volume = volume + properties.Volume;
    volume = properties.Volume;
                        count = count + 1;
    alert("執行第"+count+"次,零件總體積:"+volume);
    // 將零件存為新檔案
    var newfile = document.pwl.pwlMdlSaveAs("lego_body.prt", "c:/tmp", "lego_body"+count+".prt");
    if (!newfile.Status) {
        alert("pwlMdlSaveAs failed (" + newfile.ErrorCode + ")");
    //}
                    }
                }
                //alert("共執行:"+count+"次,零件總體積:"+volume);
                //alert("零件體積:"+properties.Volume);
                //alert("零件體積取整數:"+Math.round(properties.Volume));
            }
        catch(err)
            {
                alert ("Exception occurred: "+pfcGetExceptionType (err));
            }
    </script>
    
.. code-block:: javascript

    <script src="jscript/weblink/pfcUtils.js">
    </script><script language="JavaScript">
          if (!pfcIsWindows())
    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
      var session = pfcGetProESession();
    // 建立擺放零件的位置矩陣
      var identityMatrix = pfcCreate ("pfcMatrix3D");
      for (var x = 0; x < 4; x++)
        for (var y = 0; y < 4; y++)
          {
        if (x == y)
          identityMatrix.Set (x, y, 1.0);
        else
          identityMatrix.Set (x, y, 0.0);
          }
      var transf = pfcCreate ("pfcTransform3D").Create (identityMatrix);
    // 取得目前的工作目錄
      var currentDir = session.getCurrentDirectory();
    // 以目前已開檔, 作為 model
      var model = session.CurrentModel;
    // 查驗有無 model, 或 model 類別是否為組立件
      if (model == void null || model.Type != pfcCreate ("pfcModelType").MDL_ASSEMBLY)
        throw new Error (0, "Current model is not an assembly.");
     
      var assembly = model;
     
      var descr =
        pfcCreate ("pfcModelDescriptor").CreateFromFileName ("link1.prt");
    // 若 link1.prt 在 session 則直接取用
      var componentModel = session.GetModelFromDescr (descr);
     
    // 若 link1.prt 不在 session 則從工作目錄中載入 session
      var componentModel = session.RetrieveModel(descr);
    // 若 link1.prt 已經在 session 則放入組立檔中
      if (componentModel != void null)
        {
      var asmcomp = assembly.AssembleComponent (componentModel, transf);
        }
    //  設定組立檔中的三個定位面, 注意內定名稱與 Pro/E WF 中的 ASM_D_FRONT 不同, 而是 ASM_FRONT
      var asmDatums = new Array ("ASM_FRONT", "ASM_TOP", "ASM_RIGHT");
    // 設定零件檔中的三個定位面, 名稱與 Pro/E WF 中相同
      var compDatums = new Array ("FRONT",
                      "TOP",
                      "RIGHT");
    // 建立約束條件變數
      var constrs = pfcCreate ("pfcComponentConstraints");
     
    // 利用迴圈分別約束組立與零件檔中的三個定位平面
      for (var i = 0; i < 3; i++)
        {
    // 設定組立參考面
          var asmItem =
        assembly.GetItemByName (pfcCreate ("pfcModelItemType").ITEM_SURFACE,
                    asmDatums [i]);
    // 若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
          if (asmItem == void null)
        {
          interactFlag = true;
          continue;
        }
    // 設定零件參考面
          var compItem =
        componentModel.GetItemByName (pfcCreate ("pfcModelItemType").ITEM_SURFACE,
                          compDatums [i]);
    // 若無對應的零件參考面, 則啟用互動式平面選擇表單 flag
          if (compItem == void null)
        {
          interactFlag = true;
          continue;
        }
    // 建立 ids 變數, intseq 為 sequence of integers 為資料類別, 使用者可以經由整數索引擷取此資料類別的元件, 第一個索引為 0
    var ids = pfcCreate ("intseq");
    // 建立路徑變數
          var path = pfcCreate ("MpfcAssembly").CreateComponentPath (assembly,
                                     ids);
    // 採用互動式設定相關的變數
          var MpfcSelect = pfcCreate ("MpfcSelect");
          var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, path);
          var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
          var constr = pfcCreate ("pfcComponentConstraint").Create (
                                    pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN);
          
          constr.AssemblyReference  = asmSel;
          constr.ComponentReference = compSel;
          
          constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (false, false);
    // 將互動選擇相關資料, 附加在程式約束變數之後
          constrs.Append (constr);
        }
    // 設定組立約束條件
    asmcomp.SetConstraints (constrs, void null);
            try
            {
                      document.write("目前 Creo 的工作目錄:<br />"+currentDir);
                }
        catch (err)
            {
                alert ("Exception occurred: "+pfcGetExceptionType (err));
            }
      assembly.Regenerate (void null);
      session.GetModelWindow (assembly).Repaint();
    </script>
    
.. code-block:: javascript

    <script src="jscript/weblink/pfcUtils.js">
    </script><script language="JavaScript">
          if (!pfcIsWindows())
    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
      var session = pfcGetProESession();
    // 設定 config option
    session.SetConfigOption("comp_placement_assumptions","no");
    // 建立擺放零件的位置矩陣
      var identityMatrix = pfcCreate ("pfcMatrix3D");
      for (var x = 0; x < 4; x++)
        for (var y = 0; y < 4; y++)
          {
        if (x == y)
          identityMatrix.Set (x, y, 1.0);
        else
          identityMatrix.Set (x, y, 0.0);
          }
      var transf = pfcCreate ("pfcTransform3D").Create (identityMatrix);
    // 取得目前的工作目錄
      var currentDir = session.getCurrentDirectory();
    // 以目前已開檔, 作為 model
      var model = session.CurrentModel;
    // 查驗有無 model, 或 model 類別是否為組立件
      if (model == void null || model.Type != pfcCreate ("pfcModelType").MDL_ASSEMBLY)
        throw new Error (0, "Current model is not an assembly.");
     
      var assembly = model;
      var descr =
        pfcCreate ("pfcModelDescriptor").CreateFromFileName ("link1.prt");
     for (var partnum = 0; partnum < 90; partnum++)
    {
    // 若 link1.prt 在 session 則直接取用
      var componentModel = session.GetModelFromDescr (descr);
    // 若 link1.prt 不在 session 則從工作目錄中載入 session
      var componentModel = session.RetrieveModel(descr);
    // 若 link1.prt 已經在 session 則放入組立檔中
      if (componentModel != void null)
        {
      var asmcomp = assembly.AssembleComponent (componentModel, transf);
        }
    // 取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
      var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
    var featID = components.Item(0).Id;
    document.write("目前 featID:"+featID);
    var ids = pfcCreate ("intseq");
    ids.Append(featID+partnum);
    // 在 assembly 模型中建立子零件所對應的路徑
    var subPath =
        pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
    document.write("id 為:"+subPath.ComponentIds(0));
          subassembly = subPath.Leaf;
    //  設定組立檔中的三個定位面, 注意內定名稱與 Pro/E WF 中的 ASM_D_FRONT 不同, 而是 ASM_FRONT
      var asmDatums = new Array ("A_3", "TOP", "ASM_RIGHT");
    // 設定零件檔中的三個定位面, 名稱與 Pro/E WF 中相同
      var compDatums = new Array ("A_4",
                      "BUTTOM",
                      "RIGHT");
    // 各參考組立關係陣列
      var relation = new Array (pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN, pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_MATE);
      var relationItem = new Array(pfcCreate("pfcModelItemType").ITEM_AXIS,pfcCreate("pfcModelItemType").ITEM_SURFACE);
    // 建立約束條件變數
      var constrs = pfcCreate ("pfcComponentConstraints");
     
    // 利用迴圈分別約束組立與零件檔中的三個定位平面
      for (var i = 0; i < 2; i++)
        {
    // 設定組立參考面
          var asmItem =
        subassembly.GetItemByName (relationItem[i],
                    asmDatums [i]);
    // 若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
          if (asmItem == void null)
        {
          interactFlag = true;
          continue;
        }
    // 設定零件參考面
          var compItem =
        componentModel.GetItemByName (relationItem[i],
                          compDatums [i]);
    // 若無對應的零件參考面, 則啟用互動式平面選擇表單 flag
          if (compItem == void null)
        {
          interactFlag = true;
          continue;
        }
    // 採用互動式設定相關的變數
          var MpfcSelect = pfcCreate ("MpfcSelect");
          var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
          var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
          var constr = pfcCreate ("pfcComponentConstraint").Create (relation[i]);
          
          constr.AssemblyReference  = asmSel;
          constr.ComponentReference = compSel;
    // static pfcConstraintAttributes Create (boolean Force, boolean Ignore) 
    // 必須 Force execution of this constraint 才會抑制 comp_placement_assumptions 為 yes 的作動?
          constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (true, false);
    // 將互動選擇相關資料, 附加在程式約束變數之後
          constrs.Append (constr);
        }
    // 設定組立約束條件
    asmcomp.SetConstraints (constrs, void null);
            try
            {
                      document.write("目前 Creo 的工作目錄:<br />"+currentDir);
                }
        catch (err)
            {
                alert ("Exception occurred: "+pfcGetExceptionType (err));
            }
    }
      assembly.Regenerate (void null);
      session.GetModelWindow (assembly).Repaint();
    </script>
.. @+node:mde.20130609005025.2824: *4* 電腦輔助創新設計
電腦輔助創新設計

直接利用電腦輔助的方式, 一旦程式的基本架構完成後 電腦就能在無需人力介入的情況下, 以高速的運算能力, 進行創新發明, 是具有最高價值的電腦輔助應用, 因為所可能產出的結果;

連人類也難以想像.

希望採用電腦輔助進行創新發明, 必須要弄清楚地球上生物的演化是如何進行的!

自然的演化依賴一個法則, 生物可以傳宗接代, 基因可以在世代間進行搭配交換, 並且依照隨機方式產生突變, 所產生的新物種則遵循一個簡單的原則:

優勝劣敗, 適者生存!

http://www.youtube.com/watch?v=mcAq9bmCeR0&list=PLF626DD5B2C1F0A87

電腦輔助設計可以加速人類的創新發明, 這些發明可以帶領人類走向永續未來, 或者, 加速地球滅亡所需的時間!

地球滅亡的定義是: 人類運用各種創新發明, 僅著重在人的物質感官, 絲毫無視其他物種與環境的消逝破壞, 一旦地球生態失去平衡, 就會加速滅亡.

最近由設計者所完成的創新雙輪車設計: 構想來自單輪車.

http://design-engine.com/products-reviews/the-bicymple-is-the-bicycle-simplified-literally

讓人從十座玉山的高度一躍而下, 所需要的創新設計(過去從來沒有人這樣做)

http://design-engine.com/events/the-technology-behind-the-red-bull-stratos-stunt-dive

合成方法

http://rd.springer.com/content/pdf/10.1007%2F978-1-4615-4331-2_3.pdf
.. @+node:mde.20130627222006.2980: *5* 創新方法論
創新設計方法

完整且長期系統化分門別類進行的內容管理

經常利用流程圖來整理內容管理系統中資料間的因果關係(UML 的應用)

收集資料後必須透過內容管理與流程圖來比較其間的差異, 並且從中找出可以發展的方向或項目(歸納, 引導與誘導)

向大自然學習, 亂數與隨機的應用 (演化)

效益放大, 力的放大, 省電的究極, 方便的追求, 整合範圍的擴大

落實起承轉合的研究步驟

不要放過發生異常的細節探究

始終提問, 持續回答, 專注永續價值增進

哲學化(love wisdom), 虛擬化與跨領域整合的落實

創新方法論參考: http://wiki.mbalib.com/zh-tw/%E5%88%9B%E6%96%B0%E6%96%B9%E6%B3%95%E8%AE%BA
.. @+node:mde.20130609005025.2825: *4* 電腦輔助概念設計
以 TRIZ 創新解題方法進行電腦輔助概念設計

TRIZ 是由一位俄國專利審查員, 在審查檢視數量很多的專利發明文件後, 以人力歸納出來的創新解題方法.

透過這些創新解題方法的提示與啟發, 可以利用電腦產生各種排列組合, 這些設計組合再與現存的產品或專利進行比較後, 找出具有創新價值或產品化的設計.

此一創新解題方法, 若能以電腦輔助方式"解讀"各種排列組合所產生的設計, 將可加速電腦輔助概念設計的速度與廣度.

Google 以搜索引擎及語意(Semantics)解讀電腦涉入全球的專利文件, 即希望在查詢者應用這些海量文件的"搜尋"路徑"(關鍵字與創新發明領域, 包含地域, 國別, 產品推動訊息, 企業併購訊息與其他經濟活動)中, 找出電腦輔助概念設計的相關蛛絲馬跡, 期望比對手先一步掌握先機.

電子書:

Modern TRIZ

A Practical Course with EASyTRIZ Technology (2012)

http://rd.springer.com/book/10.1007/978-3-642-25218-1/page/1

Inventive Thinking through TRIZ (2003)

http://rd.springer.com/book/10.1007/978-3-662-08013-9/page/1

Conceptual Design for Engineers (1999)

http://rd.springer.com/book/10.1007/978-1-4471-3627-9/page/1
.. @+node:mde.20130609005025.2826: *4* 電腦輔助配置設計
Computer Aided Configuration Design

先了解何謂 Configuration Design (配置設計)

1. 配置設計是設計方法的一種.

2. 進行配置設計時, 手上已經有一組已經定義的元件, 並且已經有一些固定的組合設計方式作為參考.

3. 配置設計的重點, 即在不跳脫這些元件範圍的情況下,  以重新配置組合的方式來達成產品所規範的需求與約束條件

4. 配置設計的任務:

4-1. 元件的選擇

4-2. 元件的配置

4-3 元件的組合方式設計

5. 配置設計所需專業知識:

5-1. 問題所涉之領域知識

5-2. 正確的輸入解讀 - 設計需求的認知, 約束條件的認知與相關技術的認知

5-3. 執行案例所累積經驗與知識

6. 配置設計所需的共通知識:

6-1. 執行案例所累積經驗與知識

6-2. 與領域有關但與方法無關的知識 (隨時間改變的法規, 各地的法規與不成文的習慣等)

6-3. 與方法有關的知識 (哪些方法可以實際套用到哪些設計問題, 由無先前成功案例, 有無先前失敗案例)

6-4. 搜尋控制知識 (了解如何搜尋, 到哪裡搜尋, 搜尋哪些關鍵字, 如何整理及辨識與產品設計有關或有用的知識)
.. @+node:mde.20130609005025.2827: *4* 電腦輔助參數設計
一旦產品設計到了需要決定設計尺寸時, 利用參數的導入, 讓各設計參數的組合與搭配, 無論如何調整控制, 都能完全符合設計需求與約束條件的設計, 就稱為參數設計.

由於參數設計牽涉將設計需求與約束條件轉化為數學方程式 (聯立方程式, 運動方程式加上各種約束方程式或條件), 可以採用數值分析或符號式運算分析的方式進行解題, 在不同條件下所解出的各設計參數即可自動修改電腦輔助設計元件與組件的尺寸, 並且依序進行其他的產品分析 (重量, 配置, 材料成本, 製造加工成本), 或進一步與其他系統元件進行整合的電腦輔助工程分析.

通常數值分析結果必須在設計範圍內製作成表格後, 可進一步製入產品的控制單元, 而符號運算式則可直接納入產品的控制單元中使用.
.. @+node:mde.20130609005025.2828: *4* 電腦輔助元件細部設計
此一設計通常是利用電腦在搜尋與處理文件的速度, 基本數學運算的速度, 由設計者編寫程式從事設計流程固定的設計運算與查表等流程.

幾乎每一套電腦輔助設計套件都提供類似的元件設計與挑選的功能, 目前的中端 MCAD (Mechanical Computer Aided Design) 套件, 以 AutoDesk Inventor 的 Engineer's Handbook (機械元件輔助設計便覽最為完整 (稱為 AutoDesk Inventor Design Accelerator 設計加速器), 但是使用者仍然必須利用二次開發或其他程式設計方法, 將公司常用或可以取得的機械元件數位型錄與這些元件設計程式結合, 才能選用符合不同產品領域元件細部設計)

範例: AutoDesk Inventor 套件中的 Design Accelerator

至於高端的 MCAD 套件則通常以領域別提供極為詳細的電腦輔助元件細部設計套件, 根據該產品的特性編寫非常特殊與詳細的工程設計流程選單, 然而各公司的機械設計部門導入前, 仍然必須針對特定的條件進行修飾改寫, 例如, 從事汽車設計業的各級機械設計公司若採用 NX 套件則通常會請原廠 (目前為 Siemens 德國西門子) 相關附屬配合技術公司, 協助導入汽車各部元件的機械元件輔助設計套件.

其他中高端輔助元件設計還包括模具設計 (塑膠模具, 鑄造模具, 鈑金與衝壓模具, 放電模具, 以及各式加工用的夾治具配置設計套件)

這些輔助元件細部設計通常還必須與 CAPP (電腦輔助製程規劃), CIMS (電腦整合製造系統) 等系統配合, 例如, 該公司擁有幾台幾軸的加工機, 換刀庫容量, 不同時期的製造容量, 各式輔助製造的機器人有幾種幾台等製造相關資料後, 再配合這些約束條件進行套件編寫, 這些程式不僅與 MCAD 有關, 還必須配合 CAE 進行輔助工程分析, 電腦輔助製造規劃, 並且在過程中將各種資料與企業資源管理系統, 產品資料管理系統與產品生命週期管理系統進行整合.

換言之, 上述的電腦輔助元件細部設計系統, 除採用各 MCAD, MCAE 與 MCAM 的二次開發程式設計規範外, 還必須整合企業的其他資料庫 (接單, 庫存, 財物, 製造, 行銷, 型錄, 人事, 設計研發), 才能真正發揮電腦輔助設計的功效, 否則設計人員選擇的標準元件, 其數量無法在需求期間取得, 或許必須改採替代件或配合替代廠商所能提供的其他規格替代件, 若製造與行銷在一定期間批量產生問題, 則必須由產品失效尾端, 往前尋找問題徵結, 找出問題, 並且及時進行設計變更(創新變更, 概念變更, 配置變更, 參數變更或元件選用變更等, 並且搭配後續的製造規劃變更, 接單變更, 庫存變更, 行銷變更, 型錄變更等.)
.. @+node:mde.20130609005025.2823: *3* CADP 第三週
設計是一種創造性的活動.
 
創造性 - 從無到有的過程
 
設計的目的在建構具有多面向質感的物件、流程或服務, 及其生命週期相關之系統.

設計就是以假定之觀念及思維先行處理後, 透過某種表述方法, 訂定其擬施行之策略.

機械就是具有可變動組件, 且經過精密構思與巧妙安排之器械.
 
設計要面面俱到, 無法企及的部分要透過說明界定範圍 (設計必須呈現系統化的結果, 因此要有假設, 要有條件, 要有範圍, 要有規劃, 要有功能, 並且要能達成目的)
 
設計包含物件、流程或服務的設想、規劃、執行與驗證
 
設計所完成的物件為一具有生命週期的系統化物件

設計所完成的流程為一具有生命週期的系統化物件

設計所完成的服務為一具有生命週期的系統化服務
 
所謂具有生命週期, 表示有規劃、製造、應用、回收等過程
 
所謂系統, 表示在界定範圍及條件下, 由多元件組成具有特定功能所組成之單元.
 
汽車的傳動系統、煞車系統、懸吊系統
 
所謂系統化, 表示採在界定範圍與條件的假設下, 設法納入能彼此配合之元件組合, 使其在整體運作下達成特定功能之方法.
 
設計的類別:
 
1. 創新設計 - 完成前所未有的關鍵技術設計 Inventive or Innovative Design
 
自行車的創新設計 - 前輪可由方向握把控制方向, 動力由中置曲柄帶動鏈輪, 並由鏈條帶動後輪. (最早的自行車, 無法控制左右方向, 初期無動力踏板, 隨後改為由前輪或後輪的直接驅動踏板, 之後經過創新設計才產生目前的自行車設計)
 
隨後, 以內齒輪組的搭配, 創新出變速自行車
 
參考: 以電腦輔助的方式進行創新發明
 
2. 概念設計 Conceptual Design
 
前輪與方向握把的傳動方式 - 直接驅動由手控制, 由身體傾斜度控制,  由意念間接控制, 由路況控制
鏈條傳動可以改為哪些其他的不同設計, 有哪些不同的座椅與騎乘方式概念設計
 
根據上述自行車的現代造型, 以圖表展示可以隨身的摺疊自行車概念設計, 可以轉型為行李推車的概念設計, 可以轉型為行動發電機的概念設計, 可以水路空三用的自行車概念設計...
 
概念設計是設法針對假定功能, 給予前瞻落實的一種藝術, 也是新思路的建立與探索. 因其緊密與功能結合, 而有別於概念藝術.

因其僅勾勒出設計的可行性, 無需確實可以運作, 而有別於設計.

概念設計屬概念藝術之分支, 藉以將新想法或新產品架構出來, 而不僅像影片動畫或電動遊戲, 只提供最終產品的視覺展示.
 
概念設計可由下列方法加以定義, "概念表達遠重於直覺功能的一種活動", "不僅執著產品, 概念設計師在設計情境, 令其與現況衝擊, 使人在日常活動中不經意地有所感知其設計.

3. 配置設計 Configuration Design
 
概念一, 應該透過哪些元件, 如何配置才可達成此概念
 
4. 參數設計 Parametric Design
 
在概念一的元件配置下, 各元件的尺寸大小應該如何才能有效達成功能
 
5. 細部設計 - 元件的具體配合設計 Detailed Design
 
在概念一的元件尺寸下, 應該加上哪些元件, 其公差該如何配合, 該選用哪些標準零件, 該設計哪些特有零件, 該如何組合, 各元件如何製造(夾治具), 各零件的詳細工程圖, 各裝配件的材料表 (BOM), 各零件選用規格與廠牌與可替代零件方案,
.. @+node:mde.20130609005025.2841: *3* CADP 第四週
剛體運動學

http://rd.springer.com/content/pdf/10.1007%2F978-1-4614-3475-7_5.pdf

剛體動力學

http://rd.springer.com/content/pdf/10.1007%2F978-1-4614-3475-7_6.pdf

風力渦輪機設計

http://rd.springer.com/content/pdf/10.1007%2F978-3-642-22938-1_3.pdf

Virtual Reality and Animation for MATLAB and Simulink Users

Visualization of Dynamic Models and Control Simulations (2012)

http://rd.springer.com/book/10.1007/978-1-4471-2330-9/page/1

影像處理

http://rd.springer.com/content/pdf/10.1007%2F978-1-84996-169-1_19.pdf

數值分析

http://rd.springer.com/content/pdf/10.1007%2F978-3-642-14019-8_7.pdf

2D 桁架 FEM 分析

http://rd.springer.com/content/pdf/10.1007%2F978-1-4020-9200-8_4.pdf

Analysis of Timoshenko beams

http://rd.springer.com/content/pdf/10.1007%2F978-1-4020-9200-8_10.pdf

General Tables (單位換算程式編寫)

http://rd.springer.com/content/pdf/10.1007%2F978-3-540-30738-9_18.pdf
.. @+node:amd.20130514093510.2707: *3* CADP 第五週
利用演化方法從事設計

.. code-block:: python

    """Genetic Algorithmn Implementation
    see:
    http://www.obitko.com/tutorials/genetic-algorithms/ga-basic-description.php
    """
    import random
    
    class GeneticAlgorithm(object):
        def __init__(self, genetics):
            self.genetics = genetics
            pass
    
        def run(self):
            population = self.genetics.initial()
            while True:
                fits_pops = [(self.genetics.fitness(ch),  ch) for ch in population]
                if self.genetics.check_stop(fits_pops): break
                population = self.next(fits_pops)
                pass
            return population
    
        def next(self, fits):
            parents_generator = self.genetics.parents(fits)
            size = len(fits)
            nexts = []
            while len(nexts) < size:
                parents = next(parents_generator)
                cross = random.random() < self.genetics.probability_crossover()
                children = self.genetics.crossover(parents) if cross else parents
                for ch in children:
                    mutate = random.random() < self.genetics.probability_mutation()
                    nexts.append(self.genetics.mutation(ch) if mutate else ch)
                    pass
                pass
            return nexts[0:size]
        pass
    
    class GeneticFunctions(object):
        def probability_crossover(self):
            r"""returns rate of occur crossover(0.0-1.0)"""
            return 1.0
    
        def probability_mutation(self):
            r"""returns rate of occur mutation(0.0-1.0)"""
            return 0.0
    
        def initial(self):
            r"""returns list of initial population
            """
            return []
    
        def fitness(self, chromosome):
            r"""returns domain fitness value of chromosome
            """
            return len(chromosome)
    
        def check_stop(self, fits_populations):
            r"""stop run if returns True
            - fits_populations: list of (fitness_value, chromosome)
            """
            return False
    
        def parents(self, fits_populations):
            r"""generator of selected parents
            """
            gen = iter(sorted(fits_populations))
            while True:
                f1, ch1 = next(gen)
                f2, ch2 = next(gen)
                yield (ch1, ch2)
                pass
            return
    
        def crossover(self, parents):
            r"""breed children
            """
            return parents
    
        def mutation(self, chromosome):
            r"""mutate chromosome
            """
            return chromosome
        pass
    
    if __name__ == "__main__":
        """
        example: Mapped guess prepared Text
        """
        class GuessText(GeneticFunctions):
            def __init__(self, target_text,
                         limit=200, size=400,
                         prob_crossover=0.9, prob_mutation=0.2):
                self.target = self.text2chromo(target_text)
                self.counter = 0
    
                self.limit = limit
                self.size = size
                self.prob_crossover = prob_crossover
                self.prob_mutation = prob_mutation
                pass
    
            # GeneticFunctions interface impls
            def probability_crossover(self):
                return self.prob_crossover
    
            def probability_mutation(self):
                return self.prob_mutation
    
            def initial(self):
                return [self.random_chromo() for j in range(self.size)]
    
            def fitness(self, chromo):
                # larger is better, matched == 0
                return -sum(abs(c - t) for c, t in zip(chromo, self.target))
    
            def check_stop(self, fits_populations):
                self.counter += 1
                if self.counter % 10 == 0:
                    best_match = list(sorted(fits_populations))[-1][1]
                    fits = [f for f, ch in fits_populations]
                    best = max(fits)
                    worst = min(fits)
                    ave = sum(fits) / len(fits)
                    print(
                        "[G %3d] score=(%4d, %4d, %4d): %r" %
                        (self.counter, best, ave, worst,
                         self.chromo2text(best_match)))
                    pass
                return self.counter >= self.limit
    
            def parents(self, fits_populations):
                while True:
                    father = self.tournament(fits_populations)
                    mother = self.tournament(fits_populations)
                    yield (father, mother)
                    pass
                pass
    
            def crossover(self, parents):
                father, mother = parents
                index1 = random.randint(1, len(self.target) - 2)
                index2 = random.randint(1, len(self.target) - 2)
                if index1 > index2: index1, index2 = index2, index1
                child1 = father[:index1] + mother[index1:index2] + father[index2:]
                child2 = mother[:index1] + father[index1:index2] + mother[index2:]
                return (child1, child2)
    
            def mutation(self, chromosome):
                index = random.randint(0, len(self.target) - 1)
                vary = random.randint(-5, 5)
                mutated = list(chromosome)
                mutated[index] += vary
                return mutated
    
            # internals
            def tournament(self, fits_populations):
                alicef, alice = self.select_random(fits_populations)
                bobf, bob = self.select_random(fits_populations)
                return alice if alicef > bobf else bob
    
            def select_random(self, fits_populations):
                return fits_populations[random.randint(0, len(fits_populations)-1)]
    
            def text2chromo(self, text):
                return [ord(ch) for ch in text]
            def chromo2text(self, chromo):
                return "".join(chr(max(1, min(ch, 255))) for ch in chromo)
    
            def random_chromo(self):
                return [random.randint(1, 255) for i in range(len(self.target))]
            pass
    
        GeneticAlgorithm(GuessText("Formosa University")).run()
        pass
        
利用 TSP GA 演算法計算鑽孔的最短刀具路徑:

.. code-block:: python

    #coding: utf-8
    # https://github.com/bobozhengsir/Genetic-Algorithm
    
    import random
    import sys
    from math import sqrt 
    
    # 所謂的程式物件有名稱, 有 cid, 有 x 位置, 有 y 位置
    class City(object):
        """docstring for City"""
        def __init__(self, name, cid, x, y):
            self.name = name
            self.cid = cid
            self.x = x
            self.y = y
    
    # 所謂的路徑, 有路徑排列與路徑距離
    class Route(object):
        """docstring for Route"""
        def __init__(self, route, length):
            self.route = route 
            self.length = length
    
        def __str__(self):
            cityNames = []
            for c in self.route:
                cityNames.append(c.name)
            strCityNames = ",".join(cityNames)
            return strCityNames
    
        def getCityIds(self):
            # self.route 應該是個 list
            cityIds = [c.cid for c in self.route]
            return cityIds
    
        def __cmp__(self, other):
            otherLength = other.length
            if self.length > otherLength:
                return 1
            elif self.length < otherLength:
                return -1
            else:
                return 0
    
    class TspGA(object):
        """docstring for TspGA"""
        def __init__(self, data=None):
            #
            #
            self.POPULATION_SIZE = 10000;
            self.EVOLVING_POPULATION_SIZE = 1000;
            self.ELITISM_PCT = 0.1;
            self.NUMBER_OF_GENERATIONS = 100;
            self.MUTATION_RATE = 0.4;
            self.CROSSOVER_RATE = 0.9;
            self.TOURNAMENT_SIZE = 10;
    
            self.numCities = 0
            self.martix = []
            self.directory = {}
            self.routes = []
    
            self.crossover = self.PMXCrossover
            self.mutate = self.mutateRandomCitySwap
    
            if type(data).__name__ == 'list':
                self.data = data
                self.numCities = len(self.data)
    
        def loadCityData(self, path=''):
            """from the path load all cities data"""
            self.data = []
            self.directory = {}
            try:
                i = 0
                f = open(path)
                for line in f:
                    params = line.split(',')
                    if len(params) == 3:	
                        name = params[0].strip()
                        cid = i
                        x = float(params[1].strip())
                        y = float(params[2].strip())
                        c = City(name, cid, x, y)
                        self.data.append(c)
                        self.directory[cid] = c
                        i += 1
                self.numCities = len(self.data)
                self.createMartix()
            except Exception as e:
                raise e
            finally:
                f.close()
            self.numCities = len(self.data)
            self.createMartix()
    
        def createMartix(self):
            """create martix about cities' distances"""
            self.martix = [[0.0 for i in range(self.numCities)] for j in range(self.numCities)]
            for i in range(self.numCities - 1):
                self.martix[i][i] = 0.0
                city1 = self.data[i]
                for j in range(i + 1, self.numCities):
                    city2 = self.data[j]
                    delta_x = float(city1.x - city2.x)
                    delta_y = float(city1.y - city2.y)
                    distance = round(sqrt(delta_x**2 + delta_y**2))
                    self.martix[i][j] = distance
                    self.martix[j][i] = distance
            self.martix[self.numCities - 1][self.numCities - 1] = 0.0
    
        def calcRouteLength(self, cities=[]):
            # 終於找到錯誤, 因為原先程式沒有下一行
            self.cities = cities
            """calc route length"""
            distance = 0.0
            cid1 = self.cities[0].cid
            for i in range(1, self.numCities):
                cid2 = self.cities[i].cid
                distance += self.martix[cid1][cid2]
                cid1 = cid2
            # plus the distance between last city and first city
            distance += self.martix[cid1][self.cities[0].cid]
            return distance
    
        def nearestNeighborTour(self, city):
            """as a city and calc the nearest Neighbor tour 
            return a Route"""
            if type(city).__name__ == 'City':
                cityList = []
                citiesVisited = []
                for i in range(self.numCities):
                    cityList.append(city)
                    cid = city.cid
                    citiesVisited.append(cid)
                    minDist = 10E10 # select a big float number
                    index = 0
                    for x in range(self.numCities):
                        val = self.martix[cid][x]
                        if x not in citiesVisited and val < minDist:
                            minDist = val
                            index = x
                    city = self.directory[index]
                r = Route(cityList, self.calcRouteLength(cityList))
                return r
    
        def createPopulation(self):
            """first create the initial population of randomized routes.
            second pick the fittest routes to form the evolving population."""
            init_routes = []
            cities = self.data[:]
            for i in range(self.POPULATION_SIZE):
                random.shuffle(cities)
                r = Route(cities, self.calcRouteLength(cities))
                init_routes.append(r)
            for x in range(self.numCities):
                init_routes.append(self.nearestNeighborTour(self.data[x]))
            sort_init_routes = sorted(init_routes, key=lambda x: x.length)
            self.routes = sort_init_routes[:self.EVOLVING_POPULATION_SIZE]
    
        def solve(self):
            self.createPopulation()
            for i in range(self.NUMBER_OF_GENERATIONS):
                self.evolve()
    
        def evolve(self):
            """evolve operator"""
            generation_sizes = int(round((1 - self.ELITISM_PCT) * self.EVOLVING_POPULATION_SIZE))
            newChildren = []
            for x in range(generation_sizes):
                # Randomly select a set of routes to vie for the right to parent.
                possibleParents = []
                for i in range(self.TOURNAMENT_SIZE):
                    index = random.randrange(len(self.routes))
                    possibleParents.append(self.routes[index])
                possibleParents = sorted(possibleParents, key=lambda p: p.length)
                dad = possibleParents[0]
                mom = possibleParents[1]
                children = []
                if random.random() > self.CROSSOVER_RATE:
                    children = self.crossover(dad, mom)
                else:
                    children = [dad, mom]
                if random.random() <= self.MUTATION_RATE:
                    children = map(self.mutate, children)
                newChildren.extend(children)
            newChildren.extend(self.routes[:self.EVOLVING_POPULATION_SIZE - generation_sizes])
            newChildren = sorted(newChildren, key= lambda new : new.length)
            self.routes = []
            self.routes = newChildren[:self.EVOLVING_POPULATION_SIZE]
            
    
        def PMXCrossover(self, crossDad, crossMom):
            """partially mapped crossover"""
            childCityIds1 = []
            childCityIds2 = []
            x = random.randrange(self.numCities)
            y = random.randrange(self.numCities)
            if x > y:
                x,y = y,x
            dadCityIds = crossDad.getCityIds()
            #dadParts = []
            dadParts = dadCityIds[x:y+1]
            momCityIds = crossMom.getCityIds()
            #momParts =[]
            momParts = momCityIds[x:y+1]
            dadPartMap = dict(zip(dadParts, momParts))
            momPartMap = dict(zip(momParts, dadParts))
            # crossover and create one child
            for i in range(x):
                if dadCityIds[i] in momParts:
                    childCityIds1.append(momPartMap[dadCityIds[i]])
                else:
                    childCityIds1.append(dadCityIds[i])
            childCityIds1.extend(momParts)
            for j in range(y+1, self.numCities):
                if dadCityIds[j] in momParts:
                    childCityIds1.append(momPartMap[dadCityIds[j]])
                else:
                    childCityIds1.append(dadCityIds[j])
            # create two child
            for i in range(x):
                if momCityIds[i] in dadParts:
                    childCityIds2.append(dadPartMap[momCityIds[i]])
                else:
                    childCityIds2.append(momCityIds[i])
            childCityIds2.extend(dadParts)
            for j in range(y+1, self.numCities):
                if momCityIds[j] in dadParts:
                    childCityIds2.append(dadPartMap[momCityIds[j]])
                else:
                    childCityIds2.append(momCityIds[j])
            childCities1 = [self.directory[m] for m in childCityIds1]
            child1 = Route(childCities1, self.calcRouteLength(childCities1))
            childCities2 = [self.directory[n] for n in childCityIds2]
            child2 = Route(childCities2, self.calcRouteLength(childCities2))
            #print(child1, child2)
            return [child1, child2]
    
        def mutateRandomCitySwap(self, chromosome):
            """Randomly swap two cities in the route."""
            if type(chromosome).__name__ == 'Route':
                cityArray = chromosome.route
                cityArray = cityArray[:self.numCities]
                c1 = random.randrange(self.numCities)
                c2 = random.randrange(self.numCities)
                # cityArray[c1], cityArray[c2] = cityArray[c2], cityArray[c1]
                temp = cityArray[c1]
                cityArray[c1] = cityArray[c2]
                cityArray[c2] = temp
                newChromosome = Route(cityArray, self.calcRouteLength(cityArray))
                return newChromosome
    
    
    def main():
        """Run the algorithm a number of times and take the best result."""
        EVOLUTIONS = 50
        best = []
        tsp = TspGA()
        #tsp.loadCityData(sys.argv[1])
        tsp.loadCityData("cities.in")
        for x in range(EVOLUTIONS):	
            tsp.solve()
            tsp.routes.sort(key=lambda r : r.length)
            best.append(tsp.routes[0])
            print("Evolving %d :get the best length %f" % (x, tsp.routes[0].length))
        best = sorted(best, key=lambda l: l.length)
        print("EVOLUTIONS RESULTS:")
        for y in range(EVOLUTIONS):
            print(str(best[y]))
        print("The best result is %s " % str(best[0]))
        print("The min length is %f" % best[0].length)
    
    if __name__ == '__main__':
            main()	
    
    # 最短距離 57?
    '''
    cities.in
    A, 0, 0
    B, 1, 0
    C, 2, 0
    D, 3, 0
    E, 4, 30
    F, 5, 0
    G, 6, 0
    H, 7, 0
    I, 8, 20
    J, 9, 0
    K, 10, 0
    L, 11, 0
    M, 12, 0
    N, 13, 0
    O, 14, 0
    P, 15, 0
    Q, 15, 1
    R, 15, 2
    S, 15, 3
    T, 15, 4
    U, 15, 5
    V, 15, 6
    W, 15, 7
    X, 15, 8
    Y, 15, 9
    Z, 15, 10
    AA, 15, 11
    BB, 15, 12
    CC, 15, 13
    DD, 15, 14
    EE, 15, 15
    FF, 14, 15
    GG, 13, 15
    HH, 12, 15
    II, 11, 15
    JJ, 10, 15
    KK, 9, 15
    LL, 8, 15
    MM, 7, 15
    NN, 6, 15
    OO, 5, 15
    PP, 4, 15
    QQ, 3, 15
    RR, 2, 15
    SS, 1, 15
    TT, 0, 15
    UU, 0, 14
    VV, 0, 13
    WW, 0, 12
    XX, 0, 11
    YY, 0, 10
    ZZ, 0, 9
    AAA, 0, 8
    BBB, 0, 7
    CCC, 0, 6
    DDD, 0, 5
    EEE, 0, 4
    FFF, 0, 3
    GGG, 0, 2
    HHH, 0, 1
    '''

利用基因演算法進行產品的幾何約束設計:

.. code-block:: python

    #encoding=utf8
    # genetic.py
    #
    import random
    import operator
    MAXIMIZE, MINIMIZE = 11, 22
    class Individual:
        chromosome = None
        score = None
        # Here the size of var depends on var_number
        var = []
        var_number = 2
        for i in range(var_number):
            var.append(0)
        alleles = (0,1)
        # 以下為參數可負數時的編碼考量
        #前10為小數,後10為整數,第21則為正負號
        #0~9表示小數,10~19表示整數,而指標第20則表示第一數的正號或負號,若為0則表示正,若為1表示負號.
        #21~30表示第二數的小數部分,31~40則表示第二數的整數部分,第41指標則表示第二數的正號或負號
        #42~51表示第三數的小數部分,52~61則表示第二數的整數部分,第62指標則表示第三數的正號或負號
        # -1023 ~ 1023
        #length = 21*var_number,若接受負數參數,則必須同步修改 20->21
        length = 20*var_number
        seperator = ''
        optimization = MINIMIZE
        def __init__(self, chromosome=None):
            self.chromosome = chromosome or self._makechromosome()
            self.score = None  # set during evaluation
        def _getvar(self,chromosome=None):
            x = 0
            for i in range(0,self.var_number):
                for j in range(i*20,i*20+10):
                    x +=self.chromosome[j]<<(j-(i*20))
                if (x>999):
                    x=999
                x/=1000.
                for j in range(i*20+10,i*20+20):
                    x +=self.chromosome[j]<<(j-(i*20+10))
                self.var[i] = x
            return self.var
            ''' for -1023 ~ 1023,當設計變數可以接受負值時使用,每一變數使用21個 bit strings
    #for design variable -1023 ~1023
            for i in range(self.var_number):
                x = 0
                for j in range(i*21,i*21+10):
                    x +=self.chromosome[j]<<(j-(i*21))
                if (x>999):
                    x=999
                x/=1000.
                for j in range(i*(21)+10,i*(21)+20):
                    x +=self.chromosome[j]<<(j-(i*21+10))
                if(self.chromosome[i*(21)+20] == 1):
                    self.var[i] = -x
                else:
                    self.var[i] = x
                x = 0
            return self.var
            '''
        def _makechromosome(self):
            "makes a chromosome from randomly selected alleles."
            return [random.choice(self.alleles) for gene in range(self.length)]
        def evaluate(self, optimum=None):
            "this method MUST be overridden to evaluate individual fitness score."
            pass
        def crossover(self, other):
            "override this method to use your preferred crossover method."
            return self._twopoint(other)
        def mutate(self, gene):
            "override this method to use your preferred mutation method."
            self._pick(gene)
        # sample mutation method
        def _pick(self, gene):
            "chooses a random allele to replace this gene's allele."
            self.chromosome[gene] = random.choice(self.alleles)
        # sample crossover method
        def _twopoint(self, other):
            "creates offspring via two-point crossover between mates."
            left, right = self._pickpivots()
            def mate(p0, p1):
                chromosome = p0.chromosome[:] # 交配時,以p0的基因為基礎(複製整個 p0 的染色體內容
                chromosome[left:right] = p1.chromosome[left:right] # 接續上一個 p0 的染色體內容,將索引 left 至 right 的內容,替換成 p1 的基因
                #child = p1.__class__(chromosome) 這是原先的程式,但是應該子代要指向 p0 的內容才對
                child = p0.__class__(chromosome)
                child._repair(p0, p1)
                return child
            return mate(self, other), mate(other, self)
        # some crossover helpers ...
        def _repair(self, parent1, parent2):
            "override this method, if necessary, to fix duplicated genes."
            pass
        def _pickpivots(self):
            left = random.randrange(1, self.length-2)
            right = random.randrange(left, self.length-1)
            return left, right
        #
        # other methods
        #
        def __repr__(self):
            "returns string representation of self"
            '''
            return '<%s chromosome="%s" score=%s var=%s>' % \
                   (self.__class__.__name__,
                    self.seperator.join(map(str,self.chromosome)), self.score,self._getvar(self.chromosome))
            '''
            return '<%s score=%s var=%s>' % \
                   (self.__class__.__name__,self.score,self._getvar(self.chromosome))
        # since the __cmp__ special function is gone  use the __lt__ in stead
        # use the expression (a > b) - (a < b) as the equivalent for cmp(a, b)
        #def __cmp__(self, other):
        # these are for python 3
        def __cmp__(self, other):
            if self.optimization == MINIMIZE:
                #return cmp(self.score, other.score)
                return (self.score > other.score) - (self.score < other.score)
            else: # MAXIMIZE
                #return cmp(other.score, self.score)
                return (other.score > self.score) - (other.score < self.score)
                
        def __lt__(self, other):
            return self.__cmp__(other) < 0
        def __le__(self, other):
            return self.__cmp__(other) <= 0
        def __gt__(self, other):
            return self.__cmp__(other) > 0
        def __ge__(self, other):
            return self.__cmp__(other) >= 0 
        def copy(self):
            twin = self.__class__(self.chromosome[:])
            twin.score = self.score
            return twin
    class Environment(object):
        x = [0]
        y = [0]
        def __init__(self, kind, population=None, size=100, maxgenerations=100,
                     crossover_rate=0.90, mutation_rate=0.07, optimum=None):
            self.kind = kind
            self.size = size
            self.optimum = optimum
            self.population = population or self._makepopulation()
            for individual in self.population:
                individual.evaluate(self.optimum)
            self.crossover_rate = crossover_rate
            self.mutation_rate = mutation_rate
            self.maxgenerations = maxgenerations
            self.generation = 0
            self.report()
        def _makepopulation(self):
            return [self.kind() for individual in range(self.size)]
        def run(self):
            while not self._goal():
                self.step()
        def _goal(self):
            return self.generation > self.maxgenerations or \
                   self.best.score == self.optimum
        def step(self):
            # this sort is not working with python 3.0, modification is needed
            self.population.sort()
            self._crossover()
            self.generation += 1
            self.report()
            self.x.append(self.generation)
            # 設定為只附加所選定範圍的值,這裡只取大於或等於 0 的 score 值
            if self.best.score <=5:
                self.y.append(self.best.score)
            else:
                self.y.append(5)
        def _crossover(self):
            next_population = [self.best.copy()]
            while len(next_population) < self.size:
                mate1 = self._select()
                if random.random() < self.crossover_rate:
                    mate2 = self._select()
                    offspring = mate1.crossover(mate2)
                else:
                    offspring = [mate1.copy()]
                for individual in offspring:
                    self._mutate(individual)
                    individual.evaluate(self.optimum)
                    next_population.append(individual)
            self.population = next_population[:self.size]
        def _select(self):
            "override this to use your preferred selection method"
            return self._tournament()
        def _mutate(self, individual):
            for gene in range(individual.length):
                if random.random() < self.mutation_rate:
                    individual.mutate(gene)
        #
        # sample selection method
        #
        def _tournament(self, size=8, choosebest=0.90):
            competitors = [random.choice(self.population) for i in range(size)]
            competitors.sort()
            if random.random() < choosebest:
                return competitors[0]
            else:
                return random.choice(competitors[1:])
        def best():
            doc = "individual with best fitness score in population."
            def fget(self):
                return self.population[0]
            return locals()
        best = property(**best())
        def report(self):
            print ("="*70)
            print ("generation: ", self.generation)
            print ("best:       ", self.best)
    
    # 以上為 genetic.py 目前將兩者結合在一起
    #encoding=utf8
    # volume.py - useage example
    #
    # the fittest individual will have a chromosome consisting of 40 '1's
    #
    #
    #import genetic
    #此一加總函式在 volume 最大化中,並未使用
    def sum(seq):
        def add(x,y): return x+y
        return reduce(add, seq, 0)
    class Volume(Individual):
        optimization = MAXIMIZE
        def evaluate(self, optimum=None):
            SURFACE = 80
            # self.score is the fitness value
            # x 由0.001~1023.999,利用二位元的移位運算子<<進行計算
            # 第一階段,根據變數個數,自行計算整數與小數加總
            '''
            for j in range(10):
                x +=self.chromosome[j]<<(j-0)
            if (x>999):
                x=999
            x/=1000.
            for j in range(10,20):
                x +=self.chromosome[j]<<(j-10)
            # calculate y
            for j in range(20,30):
                y +=self.chromosome[j]<<(j-20)
            if (y>999):
                y=999
            y/=1000.
            for j in range(30,40):
                y +=self.chromosome[j]<<(j-30)
                
            z=(SURFACE - x*y)/(2.*(x+y))
            fitness_value = x*y*z
            #self.score = sum(self.chromosome[10:20])
            self.score = fitness_value
            #第二階段,將各變數計算以變數個數,利用迴圈進行運算
            x = 0
            for i in range(0,self.var_number):
                for j in range(i*20,i*20+10):
                    x +=self.chromosome[j]<<(j-(i*20))
                if (x>999):
                    x=999
                x/=1000.
                for j in range(i*20+10,i*20+20):
                    x +=self.chromosome[j]<<(j-(i*20+10))
                self.var[i] = x
            '''
            #第三階段,在實用上,將上述運算,寫進個別成員類別中,透過呼叫成員函式,取得各變數值
            self._getvar(self.chromosome)
            
            x = self.var[0]
            y = self.var[1]
            z=(SURFACE - x*y)/(2.*(x+y))
            fitness_value = x*y*z
            
            self.score = fitness_value
            
        def mutate(self, gene):
            self.chromosome[gene] = not self.chromosome[gene] # bit flip
       
    if __name__ == "__main__":
        env = Environment(Volume, size=500, maxgenerations=100)
        env.run()

利用實數編碼基因演算法進行最佳化運算:

參考資料: http://cyber.felk.cvut.cz/research/theses/papers/123.pdf

.. code-block:: python

    # https://github.com/flukeskywalker/PyRGA
    # 原始程式為 Python2 修改為 Python3 格式
    # 除了原先的最大化適應值外, 增加最小化方法設定
    import numpy as np
    import random
    import math
    
    # 請注意各代族群數必須為 4 的倍數
    class GA: # popsize must be multiple of 4
        def __init__(self, obj, dim, popsize, ngen, pc, pm, etac, etam, min):
            self.EPSILON = 10e-6
            self.INFINITY = 10e6
            self.pop = []
            self.fits = []
            self.obj = obj
            self.dim = dim
            self.popsize = popsize
            self.ngen = ngen
            self.pc = pc
            self.pm = pm
            self.etac = etac
            self.etam = etam
            # min = 1 表最小化, min = -1 表最大化
            self.min = min
            self.RIGID = 0
            self.lowb = -self.INFINITY*np.ones(self.dim)
            self.highb = self.INFINITY*np.ones(self.dim)
            self.tourneylist = range(0, self.popsize)
            self.tourneysize = 2 # works for 2 for now
            self.bestmemyet = np.zeros(self.dim)
            # 若是求最大值
            if self.min == -1:
                self.bestfityet = -np.inf
            else:
            # 若是求最小值
                self.bestfityet = np.inf
            self.pop_init()
    
        def pop_init(self):
            self.pop = [np.random.rand(self.dim) for _ in range(self.popsize)]
            for member in self.pop:
                for i in range(self.dim):
                    member[i] = self.lowb[i] + member[i]*(self.highb[i]-self.lowb[i])
            self.fits = [self.obj(member) for member in self.pop]
            #self.pop_print()
            return
    
        def setbounds(self, lows, highs):
            for i in range(self.dim):
                self.lowb[i] = lows[i]
                self.highb[i] = highs[i]
            self.pop_init()
            return
    
        def run(self):
            for gen in range(self.ngen):
                print("Generation ", gen)
                self.pop = self.getnewpop()
                self.eval_pop()
                #self.pop_print()
            return [self.bestmemyet, self.bestfityet]
    
        def getnewpop(self):
            newpop = []
            #self.tourneylist = range(0, self.popsize)
            random.shuffle(list(self.tourneylist))
            self.tourneypos = 0
            for i in range(0, self.popsize, 2):
                [p1, p2] = self.getparents() #return parents, not just indices
                [c1, c2] = self.xover(p1, p2) #return children, not just indices
                c1 = self.mutate(c1)
                c2 = self.mutate(c2)
                newpop.append(c1)
                newpop.append(c2)
            return newpop
    
        def getparents(self):
            if (self.popsize - self.tourneypos) < self.tourneysize:
                random.shuffle(list(self.tourneylist))
                self.tourneypos = 0
            if self.min == -1:
                if (self.fits[self.tourneylist[self.tourneypos]]>self.fits[self.tourneylist[self.tourneypos+1]]):
                    p1 = self.pop[self.tourneylist[self.tourneypos]]
                else:
                    p1 = self.pop[self.tourneylist[self.tourneypos+1]]
            else:
                if (self.fits[self.tourneylist[self.tourneypos]]<self.fits[self.tourneylist[self.tourneypos+1]]):
                    p1 = self.pop[self.tourneylist[self.tourneypos]]
                else:
                    p1 = self.pop[self.tourneylist[self.tourneypos+1]]
            self.tourneypos += self.tourneysize
    
            if self.min == -1:
                if (self.fits[self.tourneylist[self.tourneypos]]>self.fits[self.tourneylist[self.tourneypos+1]]):
                    p2 = self.pop[self.tourneylist[self.tourneypos]]
                else:
                    p2 = self.pop[self.tourneylist[self.tourneypos+1]]
            else:
                if (self.fits[self.tourneylist[self.tourneypos]]<self.fits[self.tourneylist[self.tourneypos+1]]):
                    p2 = self.pop[self.tourneylist[self.tourneypos]]
                else:
                    p2 = self.pop[self.tourneylist[self.tourneypos+1]]
            self.tourneypos += self.tourneysize
            return [p1, p2]
    
        def xover(self, p1, p2): # Here p1 and p2 are pop members
            c1 = np.zeros_like(p1)
            c2 = np.zeros_like(p2)
            if random.random()<=self.pc: # do crossover
                for i in range(p1.size):
                    if random.random()<0.5: # 50% variables crossover
                        [c1[i], c2[i]] = self.crossvars(p1[i], p2[i], self.lowb[i], self.highb[i])
                    else:
                        [c1[i], c2[i]] = [p1[i], p2[i]]
            else:
                c1 = p1
                c2 = p2
            return [c1, c2]
    
        def crossvars(self, p1, p2, low, high): # Here p1 and p2 are variables
            if p1>p2:
                p1, p2 = p2, p1 # p1 must be smaller
            mean = (p1+p2)*0.5
            diff = (p2-p1)
            dist = max(min(p1-low, high-p2), 0)
            if (self.RIGID and diff > self.EPSILON):
                alpha = 1.0 + (2.0*dist/diff)
                umax = 1.0 - (0.5/pow(alpha, (self.etac+1.0)))
                seed = umax*random.random()
            else:
                seed = random.random()
            beta = self.getbeta(seed)
            if (abs(diff*beta) > self.INFINITY):
                beta = self.INFINITY/diff
            c2 = mean + beta*0.5*diff
            c1 = mean - beta*0.5*diff
            c1 = max(low, min(c1, high))
            c2 = max(low, min(c2, high))
            return [c1, c2]
    
        def getbeta(self, seed):
            if (1 - seed) < self.EPSILON:
                seed = 1 - self.EPSILON
            seed = max(0.0, seed)
            if seed < 0.5:
                beta = pow(2.0*seed, (1.0/(self.etac+1.0)))
            else:
                beta = pow((0.5/(1.0-seed)), (1.0/(self.etac+1.0)))
            return beta
    
        def getdelta(self, seed, delta_low, delta_high):
            if seed >= 1.0 - (self.EPSILON/1e3):
                return delta_high
            if seed <= (self.EPSILON/1e3):
                return delta_low
            if seed <= 0.5:
                dummy = 2.0*seed + (1.0 - 2.0*seed)*pow((1+delta_low), (self.etam+1.0))
                delta = pow(dummy, (1.0/(self.etam+1.0))) - 1.0
            else:
                dummy = 2.0*(1.0 - seed) + 2.0*(seed - 0.5)*pow((1-delta_high), (self.etam+1.0))
                delta = 1.0 - pow(dummy, (1.0/(self.etam+1.0)))
            return delta
    
        def mutate(self, member):
            mut_member = np.zeros_like(member)
            for i in range(member.size):
                low = self.lowb[i]
                high = self.highb[i]
                if random.random() <= self.pm: # pm is simply the prob of a variable to mutate
                    if self.RIGID:
                        value = member[i]
                        delta_low = max((low-value)/(high-low), -1.0)
                        delta_high = min((high-value)/(high-low), 1.0)
                        if abs(delta_low)<abs(delta_high):
                            delta_high = -delta_low
                        else:
                            delta_low = -delta_high
                    else:
                        delta_low = -1.0
                        delta_high = 1.0
                    seed = random.random()
                    delta = self.getdelta(seed, delta_low, delta_high)*(high-low)
                    mut_member[i] = max(low, min(member[i] + delta, high))
                else:
                    mut_member[i] = member[i]
            return mut_member
    
        def eval_pop(self):
            self.fits = [self.obj(member) for member in self.pop]
            # 若是最大化適應值題目者
            if self.min == -1:
                # 將所有適應值中最大者, 指向 bestindex
                bestindex = np.argmax(self.fits)
            else:
                # 將所有適應值中最大者, 指向 bestindex
                bestindex = np.argmin(self.fits)
            bestmember = self.pop[bestindex]
            bestfitness = self.fits[bestindex]
            # self.min = -1 for maximization, self.min = 1 for minimization
            if self.min == -1:
                # 若是在族群中的最佳適應值大於目前為止最佳的適應值
                if bestfitness > self.bestfityet:
                    # 則將此最大適應值指為目前為止最佳適應值
                    self.bestfityet = bestfitness
                    # 並且將最佳族群成員指向目前最佳成員
                    self.bestmemyet = bestmember
            else:
                if bestfitness < self.bestfityet:
                    self.bestfityet = bestfitness
                    self.bestmemyet = bestmember
            print("Current best: ", bestfitness, "Best yet: ", self.bestfityet)
    
        def pop_print(self):
            for i in range(self.popsize):
                print(self.pop[i], self.fits[i])
            return
    
    # 若單獨存在則需導入 GA 所有方法
    #import GA
    #from GA import *
    import numpy as np
    
    def square(x):
        term1 = (x[0]*x[0]+x[1]-11.0)*(x[0]*x[0]+x[1]-11.0)
        term2 = (x[0]+x[1]*x[1]- 7.0)*(x[0]+x[1]*x[1]- 7.0)
        term3 = term1+term2
        return term3
    
    # 最大化體積題目
    def volume(x):
        surface = 80.0
        z = (surface-x[0]*x[1])/(2.0*(x[0]+x[1]))
        volume = x[0]*x[1]*z
        return volume
    
    
    def miniex1(x):
        '''Minimizing Beale's function (optimal value f(3, 0.5) = 0):
        ga=GA(miniex1, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.3, etac=2, etam=100, min=1)
        ga.setbounds(np.zeros(10), 10*np.ones(10))
        '''
        term1 = 1.5 - x[0] + x[0]*x[1]
        term2 = 2.25 - x[0] + x[0]*x[1]*x[1]
        term3 = 2.625 - x[0] + x[0]*x[1]*x[1]*x[1]
        return term1*term1 + term2*term2 + term3*term3
    
    def miniex2(x):
        '''Schaffer function #2. Minimium at (0,0), equal to 0
        ga=GA(miniex2, dim=2, popsize=100, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1)
        ga.setbounds(np.zeros(10), 10*np.ones(10))
        '''
        return 0.5 + (math.pow(math.sin(x[0]*x[0]-x[1]*x[1]), 2) - 0.5)/math.pow(1+0.001*(x[0]*x[0]+x[1]*x[1]), 2)
    
    #ga=GA(square, dim=2, popsize=40, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=-1)
    # min = -1 表示要最大化適應方程式的值, 若 min = 1 表示要最小化
    #ga=GA(volume, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.1, etac=2, etam=100, min=-1)
    ga=GA(miniex1, dim=2, popsize=100, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1)
    ga.setbounds(np.zeros(10), 10*np.ones(10))
    #ga.setbounds(-10*np.ones(10), 10*np.ones(10))
    #ga.pop_init()
    print(ga.run())

.. @+node:amd.20130514093510.2710: *3* CADP 第六週
求動態機械系統的特徵值:

http://mbi-wiki.uni-wuppertal.de/en/python/feder-massen-systeme-ein-python-programm-fur-die-berechnung-der-eigenfrequenzen/
.. @+node:amd.20130514093510.2711: *3* CADP 第七週
https://github.com/Obijuan/Miniskybot

http://scipy-lectures.github.io/

http://pandas.pydata.org/

http://www.chronoengine.info/mediawiki/index.php/Unit_PYTHON

http://www.vectioneer.com/

https://github.com/Rod-Persky/pyIGES

http://code.google.com/p/robotics-toolbox-python/

http://garethrees.org/2011/07/04/strandbeest/strandbeest.html

virtual robot simulation

http://www.v-rep.eu/index.html

python for v-rep

http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm

http://humanoids.dem.ist.utl.pt/Iden_external/overview.html

https://github.com/CreativeMachinesLab/aracna
.. @+node:amd.20130515005753.3889: *3* CADP 第八週
基因演算設計

.. code-block:: python

    import random
    import array
    from deap import base
    from deap import benchmarks
    from deap import creator
    from deap import tools
    # Problem dimension, 最大化紙箱 volume
    NDIM = 2
    # minimization problem
    # create(name, base, attributes)
    '''
    The weights are used in the fitness comparison. They are shared among all fitnesses of the same type. When subclassing Fitness, the weights must be defined as a tuple where each element is associated to an objective. A negative weight element corresponds to the minimization of the associated objective and positive weight to the maximization.
    '''
    # weights 為 1.0 表示最大化 fitness
    creator.create("FitnessMax", base.Fitness, weights=(1.0,))
    '''
    Evolution strategies individuals are slightly different as they contain generally two list, one for the actual individual and one for its mutation parameters. This time instead of using the list base class we will inherit from an array.array for both the individual and the strategy. Since there is no helper function to generate two different vectors in a single object we must define this function our-self. The initES() function receives two classes and instantiate them generating itself the random numbers in the intervals provided for individuals of a given size.
    '''
    creator.create("Individual", array.array, typecode='d', fitness=creator.FitnessMax)
    toolbox = base.Toolbox()
    # for sphere
    #toolbox.register("attr_float", random.uniform, -3, 3)
    '''
    toolbox.register("attr_int", random.randint, INT_MIN, INT_MAX)
    toolbox.register("attr_flt", random.uniform, FLT_MIN, FLT_MAX)
    toolbox.register("individual", tools.initCycle, creator.Individual,
                     (toolbox.attr_int, toolbox.attr_flt), n=N_CYCLES)
    '''
    toolbox.register("attr_float", random.uniform, 0, 5)
    toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, NDIM)
    toolbox.register("population", tools.initRepeat, list, toolbox.individual)
    # selection method
    toolbox.register("select", tools.selRandom, k=3)
    # fitness function is benchmarks.sphere
    # for sphere
    #toolbox.register("evaluate", benchmarks.sphere)
    '''
    SURFACE = 80, 最大化 volume
    z =(SURFACE - x*y)/(2.*(x+y));
        volume=x*y*z;
    '''
    def evalVolume(individual):
        SURFACE = 80.0
        x = individual[0]
        y = individual[1]
        # 確保 x 與 y 都是正值
        if x < 0 or y < 0:
            return -1000,
        z =(SURFACE - x*y)/(2.0*(x+y))
        volume = x*y*z
        return volume,
    
    #toolbox.register("evaluate", benchmarks.ackley)
    toolbox.register("evaluate", evalVolume)
    
    def main():
        # Differential evolution parameters
        CR = 0.25
        F = 1 
        MU = 300
        NGEN = 100
         
        pop = toolbox.population(n=MU);
        hof = tools.HallOfFame(1)
        stats = tools.Statistics(lambda ind: ind.fitness.values)
        stats.register("avg", tools.mean)
        stats.register("std", tools.std)
        stats.register("min", min)
        stats.register("max", max)
         
        logger = tools.EvolutionLogger(["gen", "evals"] + list(stats.functions.keys()))
        logger.logHeader()
         
        # Evaluate the individuals
        fitnesses = toolbox.map(toolbox.evaluate, pop)
        for ind, fit in zip(pop, fitnesses):
            ind.fitness.values = fit
         
        stats.update(pop)
         
        logger.logGeneration(gen=0, evals=len(pop), stats=stats)
         
        for g in range(1, NGEN):
            for k, agent in enumerate(pop):
                a,b,c = toolbox.select(pop)
                y = toolbox.clone(agent)
                index = random.randrange(NDIM)
                for i, value in enumerate(agent):
                    if i == index or random.random() < CR:
                        y[i] = a[i] + F*(b[i]-c[i])
                y.fitness.values = toolbox.evaluate(y)
                if y.fitness > agent.fitness:
                    pop[k] = y
            hof.update(pop)
            stats.update(pop)
             
            logger.logGeneration(gen=g, evals=len(pop), stats=stats)
        print ("Best individual is ", hof[0], hof[0].fitness.values[0])
         
    if __name__ == "__main__":
        main()
.. @-all
.. @-leo
