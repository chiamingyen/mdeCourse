.. @+leo-ver=5-thin
.. @+node:amd_yen.20130308210411.2387: * @file c2.txt
.. @@language rest
.. @@tabwidth -4

.. @+at @rst-options
..  call_docutils=False
..  code_mode=False
..  generate_rst=True
..  http_server_support = False
..  show_organizer_nodes=True
..  show_headlines=True
..  show_leo_directives=True
..  stylesheet_path=..\doc
..  write_intermediate_file = True
..  verbose=True
.. @@c

.. @+all
.. @+node:amd_yen.20130308210411.2388: ** @rst document\c2.html
########################
程式語言(二)
########################

.. index:: 程式語言(二)

.. contents::
    :depth: 3
.. @+node:amd_yen.20130308210411.2390: *3* C2 第一週
讓學員自行建構可攜 portableKMOL 的目的在練習網際程式框架的基本組成 (程式開發環境、內容管理系統、全球資訊網伺服器、以及各類相關工具), 學員熟悉此流程後, 可以自行修改框架並且配合需要進行各模組的改版.

.. Note:: 這裡的程式化文書處理內容是第一次放入 C2 的課程內容中, 主要的著眼點在於利用程式方法進行協同文書處理.

1. 利用程式進行文書處理

    需要安裝 docutils 模組

    也可以利用 Sphinx 模組將 rst 檔案轉為 html 與 tex, 然後再以 MikeTeX 將 tex 轉為 pdf 檔案

2. 利用程式進行分析運算與設計檔案轉換

以安裝 Python33 所使用的各模組, 各舉出應用範例, 並以機械設計相關應用為考量

.. 為何選擇 Python:: http://www.stat.washington.edu/~hoytak/blog/whypython.html

    Python 3.3 版與相關模組安裝:
    
    Python 3.3 本體
    
    http://www.python.org/download/
    
    安裝後 C:\Python33 約佔 33 MB
    
    distribute (Python 的 module  installer, 可利用 easy_install 安裝所需模組)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#distribute
    
    安裝後 C:\Python33 約佔 37 MB
    
    pip (Python 的 module installer, 安裝後可利用 "pip install 模組名稱" 完成模組安裝
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#pip
    
    安裝後 C:\Python33 約佔 38 MB
    
    win32com (Python 與 Windows COM 物件的連結模組, 可以利用 win32com 來連結 SolidWorks, Inventor, Word, Excel 等 Windows 應用程式物件)
    
    http://sourceforge.net/projects/pywin32/files/pywin32/Build%20218/
    
    安裝後 C:\Python33 約佔 64 MB
    
    PIL (Python 的 Image library, 可以處理 2D 影像檔案)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#pil
    
    安裝後 C:\Python33 約佔 67 MB
    
    matplotlib (Python 類似 matlab 的 plot library)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#matplotlib
    
    安裝後 C:\Python33 約佔 91 MB
    
    numpy (Python 的 numerical library, 用於數值分析運算)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy
    
    安裝後 C:\Python33 約佔 138 MB
    
    sympy (Python 的 Symbolic manipulation 模組, 用於符號式運算 (相對於數值分析))
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#sympy
    
    安裝後 C:\Python33 約佔 175 MB
    
    scipy (Python 的 Scientific library)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy
    
    安裝後 C:\Python33 約佔 292 MB
    
    PyQt (Python 連結 Qt (nokia 的開源 GUI 程式庫, 更自由的對應類似版本為 Pyside) 的程式庫, 可用來開發圖形介面單機程式, 例如: Leo editor 就是採用 PyQt 開發)
    
    http://www.riverbankcomputing.com/software/pyqt/download
    
    安裝後 C:\Python33 約佔 374 MB
    
    docutils (Python 的 document utility, 可將 rst 格式檔案轉為 html)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#docutils
    
    安裝後 C:\Python33 約佔 383 MB
    
    Leo editor (以 Python 編寫的 outliner 與 IDE)
    
    http://www.greygreen.org/leo/
    
    安裝後 C:\Python33 約佔 401 MB
    
    以C:\Python33\Scripts\pip install sphinx
    
    安裝後 C:\Python33 約佔 413 MB

單機模式

網際模式

結合 IPython 與 Leo Editor 的基本用法:

http://webpages.charter.net/edreamleo/IPythonBridge.html

3. 利用程式進行協同設計

網際機械設計流程 - 以 Pyforum + brython 為範例, 可以開發 html5 網際程式

網際內容管理 - django based CMS

網際專案管理 - OpenPLM - http://wiki.openplm.org/trac/wiki/Credits

OpenERP/PLM - http://www.openerpplm.eu/

利用程式進行資料處理範例:

產生虛擬學員名單程式:

.. literalinclude:: ../c2/generate_stud.py
   :language: python
   
上課學員分組程式:

.. literalinclude:: ../c2/grouping.py
   :language: python



.. @+node:amd_yen.20130310161901.1488: *4* Leo editor 與外部檔案
External files: Any outline node (and its descendants) can be "connected" to any file on your file system. Several kinds of connections exist. The three most common kinds are:

1. @edit: Leo reads the entire external file into the @edit node's body text.

採用 @edit 指令, Leo 會將外部檔案的內容讀進該節點的內文區.

2. @auto: Leo parses the external file and creates an outline that shows the structure of the external file, just as in typical class browsers.

採用 @auto 則會解讀外部檔案, 並且根據該檔案的架構組成大綱模式.

3. @file: Leo makes a two way connection between the @file node (and its descendants) and the external file. You can update the external file by writing the Leo outline connected to it, or you can update the outline by changing the external file. Moreover, you can easily control how Leo writes nodes to the file: you can rearrange how Leo writes nodes. To do all this Leo uses comments in the external file called sentinels that represent the outline structure in the external file itself.

假如採用 @file, 則使用者可以直接在節點的內文區編輯內容, 或直接編輯外部檔案, Leo 會以雙向的方式處理檔案的內容變更.

All of these connections allow you to share external files with others in a collaborative environment. With @file, you can also share outline structure with others. Thus, a single Leo outline can contain an entire project with dozens or even hundreds of external files. Using Leo, you never have to open these files by hand, Leo does so automatically when it opens the Leo outline. Leo is a unique new kind of IDE.

而這個模式可以再與網際的上傳檔案結合, 假設對應到某一節點的 @file 檔案, 使用者可以由瀏覽器上傳檔案, 一旦開啟 Leo, 所有檔案內容就會整合進 Leo 的編輯區.
.. @+node:amd_yen.20130308210411.2391: *3* C2 第二週
使用 docutils 模組:

docutils 範例1

下列範例利用網路上的一份 rst 格式檔案, 利用 Python 的 urllib.request 模組開啟檔案後, 將原本為數位格式的資料編碼為文字格式資料後, 再利用 docutils.core 函式庫中的 publish_string 函式, 將 rst 檔案轉為 html 格式, 最後再利用可攜的 Chrome 開啟此一 html 檔案.

.. literalinclude:: ../c2/docutils_ex1.py
    :language: python
    :linenos:

.. Note:: 請注意, 上面程式碼採用 literalinclude, 但是卻無法讓 linenos 顯示行號的屬性運作, 結果不僅沒有 python 程式 highlight, 內容雙跳行, 而且沒有行號.

docutils 範例2

下列範例與範例 1 類似, 唯一的差別為文件中需要一個 image.png 圖檔, 利用 urllib.request.urlopen(影像檔案url ).read() 讀取影像網址中的數位檔案後, 直接存檔. 隨後再利用 docutils.core 函式庫中的 publish_string 函式, 將 rst 檔案轉為 html 格式的同時, 導入 image.png 檔案.

.. literalinclude:: ../c2/docutils_ex2.py
    :language: python
    :linenos:

.. Note:: 請注意, 上面程式碼採用 literalinclude, 但是卻無法讓 linenos 顯示行號的屬性運作, 結果不僅沒有 python 程式 highlight, 內容雙跳行, 而且沒有行號.

練習:

1. 請各組員分別在各自的 www 主機中建立 rst 檔案與影像檔, 再由其他組員以 urllib.request_ 與 publish_string_ 等函式功能, 將其他組員的 rst 檔案合併, 並轉換為 html 檔案格式.

.. _urllib.request: http://docs.python.org/3.0/library/urllib.request.html

.. _publish_string: http://docutils.sourceforge.net/docs/api/publisher.html
.. @+node:amd_yen.20130308214521.2437: *3* C2 第三週
Sphinx 相關


.. @+node:amd_yen.20130308214521.2438: *4* Sphinx 教學
利用 Leo Editor 與 Sphinx 開發手冊的範例:

1. 與 nginx 有關的線上參考書

    http://tengine.taobao.org/book/

    參考書原始碼: http://code.taobao.org/p/nginx_book/src/trunk/

2. 用 Sphinx 寫書

    http://hyry.dip.jp/tech/book/page/sphinx
    
    編輯環境下載: http://hyry.dip.jp/files/books.zip
    
    寫書工具介紹: http://hyry.dip.jp:8000/files/scipybook-tools.pdf
    
其他利用 Sphinx 進行電子書開發的範例:

http://itindex.net/detail/13288-restructuredtext-sphinx

Sphinx 簡介

source directory

conf.py

sphinx-quickstart script to setup the initial source directory and create default conf.py

sphinx-build
.. @+node:amd_yen.20130313165007.1509: *5* nginx 手冊實作
必備工具:

    portableKMOL 可攜套件 (Sphinx 與 portableLatex)
    http://code.taobao.org/p/nginx_book/src/trunk/ 中的 rst 檔案
    
實作目的:

    讓學員了解如何以程式方法產生 html 與 pdf 格式的電子手冊
    
專案檔案:

    https://github.com/chiamingyen/nginxProject
    
執行步驟:

    1. 啟動 portableKMOL 後, 在"命令提示字元區", 以 V:\mkdir nginx_project 建立電子手冊專用目錄.
    
    2. 下載 `portable subversion client_`, 利用 Repository->Checkout, 簽出 `nginx book_` 的資料.
    
    3. 在命令列中 cd nginx_project 目錄, 並且參考 `First step with sphinx_` 中的說明, 執行 
    
.. code-block:: none

   sphinx-quickstart
   
並且依序回答相關提問.
    
    4. 以 SciTE 編輯 index.rst, 導入下載自  `nginx book_` 資料中的 .rst 檔案:
    
.. code-block:: none

    .. cmsimple documentation master file, created by
       sphinx-quickstart on Wed Mar 13 19:31:14 2013.
       You can adapt this file completely to your liking, but it should at least
       contain the root `toctree` directive.
    
    Welcome to cmsimple's documentation!
    ====================================
    
    Contents:
    
    .. toctree::
       :maxdepth: 2
    
       chapter_2
       chapter_3
       chapter_4
       chapter_5
       chapter_6
       chapter_7
       chapter_11
       chapter_12
       example_1
    
    Indices and tables
    ==================
    
    * :ref:`genindex`
    * :ref:`modindex`
    * :ref:`search`

將上列 chapter_2.rst ~ example_1.rst 等檔案放入 index.rst 所屬目錄中.

    5. 編輯 conf.py:
    
.. code-block:: python
    :linenos:
    
    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-
    #
    # cmsimple documentation build configuration file, created by
    # sphinx-quickstart on Wed Mar 13 19:31:14 2013.
    #
    # This file is execfile()d with the current directory set to its containing dir.
    #
    # Note that not all possible configuration values are present in this
    # autogenerated file.
    #
    # All configuration values have a default; values that are commented out
    # serve to show the default.
    
    import sys, os
    
    # If extensions (or modules to document with autodoc) are in another directory,
    # add these directories to sys.path here. If the directory is relative to the
    # documentation root, use os.path.abspath to make it absolute, like shown here.
    #sys.path.insert(0, os.path.abspath('.'))
    
    # -- General configuration -----------------------------------------------------
    
    # If your documentation needs a minimal Sphinx version, state it here.
    #needs_sphinx = '1.0'
    
    # Add any Sphinx extension module names here, as strings. They can be extensions
    # coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
    extensions = ['sphinx.ext.pngmath', 'sphinx.ext.mathjax']
    
    # Add any paths that contain templates here, relative to this directory.
    templates_path = ['_templates']
    
    # The suffix of source filenames.
    source_suffix = '.rst'
    
    # The encoding of source files.
    #source_encoding = 'utf-8-sig'
    
    # The master toctree document.
    master_doc = 'index'
    
    # General information about the project.
    project = 'cmsimple'
    copyright = '2013, the author'
    
    # The version info for the project you're documenting, acts as replacement for
    # |version| and |release|, also used in various other places throughout the
    # built documents.
    #
    # The short X.Y version.
    version = '1.0'
    # The full version, including alpha/beta/rc tags.
    release = '1.0'
    
    # The language for content autogenerated by Sphinx. Refer to documentation
    # for a list of supported languages.
    language = 'zh_TW'
    
    # There are two options for replacing |today|: either, you set today to some
    # non-false value, then it is used:
    #today = ''
    # Else, today_fmt is used as the format for a strftime call.
    #today_fmt = '%B %d, %Y'
    
    # List of patterns, relative to source directory, that match files and
    # directories to ignore when looking for source files.
    exclude_patterns = []
    
    # The reST default role (used for this markup: `text`) to use for all documents.
    #default_role = None
    
    # If true, '()' will be appended to :func: etc. cross-reference text.
    #add_function_parentheses = True
    
    # If true, the current module name will be prepended to all description
    # unit titles (such as .. function::).
    #add_module_names = True
    
    # If true, sectionauthor and moduleauthor directives will be shown in the
    # output. They are ignored by default.
    #show_authors = False
    
    # The name of the Pygments (syntax highlighting) style to use.
    pygments_style = 'sphinx'
    
    # A list of ignored prefixes for module index sorting.
    #modindex_common_prefix = []
    
    
    # -- Options for HTML output ---------------------------------------------------
    
    # The theme to use for HTML and HTML Help pages.  See the documentation for
    # a list of builtin themes.
    html_theme = 'default'
    
    # Theme options are theme-specific and customize the look and feel of a theme
    # further.  For a list of options available for each theme, see the
    # documentation.
    #html_theme_options = {}
    
    # Add any paths that contain custom themes here, relative to this directory.
    #html_theme_path = []
    
    # The name for this set of Sphinx documents.  If None, it defaults to
    # "<project> v<release> documentation".
    #html_title = None
    
    # A shorter title for the navigation bar.  Default is the same as html_title.
    #html_short_title = None
    
    # The name of an image file (relative to this directory) to place at the top
    # of the sidebar.
    #html_logo = None
    
    # The name of an image file (within the static path) to use as favicon of the
    # docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
    # pixels large.
    #html_favicon = None
    
    # Add any paths that contain custom static files (such as style sheets) here,
    # relative to this directory. They are copied after the builtin static files,
    # so a file named "default.css" will overwrite the builtin "default.css".
    html_static_path = ['_static']
    
    # If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
    # using the given strftime format.
    #html_last_updated_fmt = '%b %d, %Y'
    
    # If true, SmartyPants will be used to convert quotes and dashes to
    # typographically correct entities.
    #html_use_smartypants = True
    
    # Custom sidebar templates, maps document names to template names.
    #html_sidebars = {}
    
    # Additional templates that should be rendered to pages, maps page names to
    # template names.
    #html_additional_pages = {}
    
    # If false, no module index is generated.
    #html_domain_indices = True
    
    # If false, no index is generated.
    #html_use_index = True
    
    # If true, the index is split into individual pages for each letter.
    #html_split_index = False
    
    # If true, links to the reST sources are added to the pages.
    #html_show_sourcelink = True
    
    # If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
    #html_show_sphinx = True
    
    # If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
    #html_show_copyright = True
    
    # If true, an OpenSearch description file will be output, and all pages will
    # contain a <link> tag referring to it.  The value of this option must be the
    # base URL from which the finished HTML is served.
    #html_use_opensearch = ''
    
    # This is the file name suffix for HTML files (e.g. ".xhtml").
    #html_file_suffix = None
    
    # Output file base name for HTML help builder.
    htmlhelp_basename = 'cmsimpledoc'
    
    
    # -- Options for LaTeX output --------------------------------------------------
    TITLE = "nginx 電子書"
    
    latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    #'papersize': 'letterpaper',
    
    # The font size ('10pt', '11pt' or '12pt').
    #'pointsize': '10pt',
    "maketitle": r"""
    \maketitle
    \renewcommand\contentsname{目 錄}
    \renewcommand\partname{部分} 
    \renewcommand{\chaptermark}[1]{\markboth{\textnormal{第 \thechapter\ 章 \hspace{4mm} #1}}{}}
    \renewcommand{\sectionmark}[1]{\markright{\textnormal{\thesection \hspace{2mm} #1}}{}}
    \renewcommand{\figurename}{\textsc{圖}}
    \renewcommand{\tablename}{\textsc{表}}
    """,
    "tableofcontents": r"""
    \tableofcontents
    \chapter*{前言}
    \addcontentsline{toc}{chapter}{前言}
    \fancyhead[LE,RO]{%s}
    """ % TITLE,
    # Additional stuff for the LaTeX preamble.
    'preamble': r"""
    % \pdfpagewidth 195mm
    % \pdfpageheight 271mm
    % \textwidth 6.0in
    % \textheight 8.8in
    % \oddsidemargin -0.1in
    % \evensidemargin -0.1in
    
    \textwidth 6.8in
    \oddsidemargin -0.2in
    \evensidemargin -0.3in
    
    \usepackage{pdfpages}
    \usepackage[BoldFont,CJKchecksingle]{xeCJK}
    
        \usepackage{fancyvrb} % for frame on Verbatim
        \usepackage{fancyhdr}
        \usepackage[T1]{fontspec}               %設定字體用
    
    \usepackage{float}
    \usepackage{ccaption}
    \usepackage{pifont}
    % \usepackage{fancybox}
    \usepackage{fontspec,xunicode,xltxtra}
    
    \setsansfont{Times New Roman}
    \setmainfont{Times New Roman}
    \setmonofont{Times New Roman}
    
    \setCJKsansfont[BoldFont={新細明體},ItalicFont={新細明體}]{新細明體}
    \setCJKromanfont[BoldFont={新細明體},ItalicFont={新細明體}]{新細明體}
    \setCJKmainfont[BoldFont={新細明體},ItalicFont={新細明體}]{新細明體}
    \setCJKmonofont[BoldFont={新細明體},ItalicFont={新細明體}]{新細明體}
    
        \makeatletter
        \def\verbatim@font{\rmfamily\small}     %為了讓 verbatim 註解中能夠加入中文, 採用 roman family 字體
        \makeatother
    
    \XeTeXlinebreaklocale "zh"  %讓中文自動換行
    \XeTeXlinebreakskip = 0pt plus 1pt
    \renewcommand{\baselinestretch}{1.3} 
    \setcounter{tocdepth}{3}
    \captiontitlefont{\small\sffamily}
    \captiondelim{ - }
    \renewcommand\today{\number\year年\number\month月\number\day日}      
    \makeatletter
    \renewcommand*\l@subsection{\@dottedtocline{2}{2.0em}{4.0em}}
    \renewcommand*\l@subsubsection{\@dottedtocline{3}{3em}{5em}}
    \makeatother
    \titleformat{\chapter}[display]
    {\bfseries\Huge}
    {\filleft \Huge 第 \hspace{2 mm} \thechapter \hspace{4 mm} 章}
    {4ex}
    {\titlerule
    \vspace{1ex}%
    \filright}
    [\vspace{1ex}%
    \titlerule]
    %\definecolor{VerbatimBorderColor}{rgb}{0.2,0.2,0.2}
    \definecolor{VerbatimColor}{rgb}{0.95,0.95,0.95}
    """,
    }
    
    # Grouping the document tree into LaTeX files. List of tuples
    # (source start file, target name, title, author, documentclass [howto/manual]).
    latex_documents = [
      ('index', 'cmsimple.tex', 'cmsimple Documentation',
       'the author', 'manual'),
    ]
    
    # The name of an image file (relative to this directory) to place at the top of
    # the title page.
    #latex_logo = None
    
    # For "manual" documents, if this is true, then toplevel headings are parts,
    # not chapters.
    #latex_use_parts = False
    
    # If true, show page references after internal links.
    #latex_show_pagerefs = False
    
    # If true, show URL addresses after external links.
    #latex_show_urls = False
    
    # Documents to append as an appendix to all manuals.
    #latex_appendices = []
    
    # If false, no module index is generated.
    #latex_domain_indices = True
    
    
    # -- Options for manual page output --------------------------------------------
    
    # One entry per manual page. List of tuples
    # (source start file, name, description, authors, manual section).
    man_pages = [
        ('index', 'cmsimple', 'cmsimple Documentation',
         ['the author'], 1)
    ]
    
    # If true, show URL addresses after external links.
    #man_show_urls = False
    
    
    # -- Options for Texinfo output ------------------------------------------------
    
    # Grouping the document tree into Texinfo files. List of tuples
    # (source start file, target name, title, author,
    #  dir menu entry, description, category)
    texinfo_documents = [
      ('index', 'cmsimple', 'cmsimple Documentation',
       'the author', 'cmsimple', 'One line description of project.',
       'Miscellaneous'),
    ]
    
    # Documents to append as an appendix to all manuals.
    #texinfo_appendices = []
    
    # If false, no module index is generated.
    #texinfo_domain_indices = True
    
    # How to display URL addresses: 'footnote', 'no', or 'inline'.
    #texinfo_show_urls = 'footnote'

::

    6. 進入 nginx_project 目錄, 執行:
    
.. code-block:: none

   make html

就可以在 build/html 目錄中產生對應的 html 格式電子書檔案.

.. code-block:: none

   make latex
   
就可以在 build/latex 目錄中產生對應的 latex 格式電子書檔案.

為了將 .tex 檔案轉換為 pdf 格式, 以 SciTE 編輯 makepdf.bat, 放入 latex 目錄中.

.. code-block:: none

    V:/extensions/portableLatex/MiKTeX/texmf/miktex/bin/xelatex.exe -interaction=nonstopmode %1
    V:/extensions/portableLatex/MiKTeX/texmf/miktex/bin/xelatex.exe -interaction=nonstopmode %1

在 latex 目錄中, 執行 (必須配合設定時所使用的專案名稱, 例如: nginx.tex):

.. code-block:: none

   makepdf nginx.tex
   
就可以順利產生 pdf 格式的電子書檔案.

.. _portable subversion client: http://portableapps.com/node/6767

.. _nginx book: http://code.taobao.org/p/nginx_book/src/trunk/

.. _First step with sphinx: http://sphinx-doc.org/tutorial.html
    
    
    
.. @+node:amd_yen.20130308214521.2439: *4* Leo 的文書處理
先以空標題進行架構區分
然後進入章節標題, 也是用來區分架構, 沒有內文資料

接著再利用 @file 將章節標題以下的內容存成 .txt, 位置在文書處理目錄的上位目錄, 此一內容應該是類似內容備份用

實際的 rest 格式內容則是利用 @rst 產生, 由於標題檔案名稱會被 rst 模組自動加上 .txt

而且此基本的 suffix 必須填入 conf.py 中, 也就是 source_suffix 變數

# The suffix of source filenames.
source_suffix = '.html.txt'

其中也必須在 conf.py 中宣告最重要的合併處理檔案, 也就是 master_doc 變數, master_doc 會自動被 Sphinx 冠上 suffix, 因此宣告時無須加上 prefix

# The master toctree document.
master_doc = 'leo_toc' # don't use any prefix.

位於 leo_toc.html.txt 中最重要的就是 toctree 指令, 其下為合併處理的章節檔案名稱.

例如:

    .. toctree::
       :maxdepth: 1
       :glob:

以下則列出要加入 toc 處理的各檔案名稱.

glob 參數則表示 Sphinx 會自動根據所提供的檔案名稱搜尋要加入個別檔案.

若在 index.rst 中所要加入的檔案為數眾多, 則可根據規律以程式產生, 在整合文書處理環境下, 也可以利用程式產生所需要的 index.rst 檔案.

.. code-block:: python

    #coding: utf-8
    學號頭碼 = "401231"
    
    for i in range(1,57):
        if len(str(i)) == 1:
            尾碼 = "0"+str(i)
        else:
            尾碼 = str(i)
        print(學號頭碼+尾碼)
.. @+node:amd_yen.20130308214521.2440: *4* SciTE 設定
為了讓 SciTE 可以在開啟檔案內容變更時, 自動在編輯區內反應最新變更後的內容, 必須修改

SciTEGlobal.properties 中的設定值:

.. code-block:: none

   load.on.activate=1
   save.on.deactivate=1

詳細說明如下:

The load.on.activate property causes SciTE to check whether the current file has been updated by another process whenever it is activated. This is useful when another editor such as a WYSIWYG HTML editor, is being used in conjunction with SciTE.

The save.on.deactivate property causes SciTE to save the file whenever the SciTE application loses focus. This is useful when developing web pages and you want to often check the appearance of the page in a browser.
.. @+node:amd_yen.20130308214521.2441: *5* @url SciTE 設定說明
http://www.scintilla.org/SciTEDoc.html

SciTE 線上說明文件
.. @+node:amd_yen.20130309155804.1712: *3* C2 第四週
Python 3.3 本體的基本運算功能範例

pip 的模組安裝指令

Python 的 Windows COM 應用
    Python 與 SolidWorks
    Python 與 Word
    Python 與 Excel
    Python 與 Inventor

Python 的 PIL 應用範例

Python 的 matplotlib 應用範例

Python 的 numpy 與 scipy 應用範例

機械設計與製造加工的最佳化問題

    平面上的特定鑽孔最短路徑 `Travelling salesman problem`_
    
    材料切割最佳化 `Knapsack problem`_
    
    其他設計最佳化 (滿足約束條件下) Volume maximization
    
        已知 SURFACE = 80
        且 z=(SURFACE - x*y)/(2.*(x+y))
        最大化 x*y*z
        
        數值分析方法 (Numerical analysis)
        
        符號式分析方法 (Symbolic analysis)

分散式演化框架: `DEAP`_

仿生智能運算框架: `INSPYRED`_

.. _Travelling salesman problem: http://en.wikipedia.org/wiki/Travelling_salesman_problem

.. _Knapsack problem: http://en.wikipedia.org/wiki/Knapsack_problem

.. _DEAP: https://code.google.com/p/deap/

.. _INSPYRED: https://pypi.python.org/pypi/inspyred

Python 的 sympy 應用範例

Python 的 PyQT 應用範例

Python 的 CherryPy 應用程式開發
.. @+node:amd_yen.20130317002834.1537: *4* @url Python3 基本功能
http://en.wikibooks.org/wiki/Non-Programmer's_Tutorial_for_Python_3

這是一份有關 Python3 基本功能介紹的資料.

機械設計工程師需要程式作甚麼?

網路上的一段有趣提問:

http://www.engineergirl.org/Engineers/Directory/2929/9759/570.aspx

Question: Hi, I was wondering what is mechanical engineering and what they do? I am considering becoming a mechanical engineer after I become a computer programmer. Also does computer programming help in mechanical engineering? Does taking the International Baccalaureate program help in the engineering field? Also I am entering highschool and am going to be taking the IB program.

posted by Tierra, MD on March 30, 2012

Answer 1 by Dr. Karen Thole

Dear Tierra from Md: 

It is very exciting to hear of your interest in mechanical engineering. I will attempt to address a few of your questions: It is difficult to say what mechanical engineers do not do in terms of jobs. Our Penn State mechanical engineers do so many things: they work on designing new hospital buildings, new airplanes, new wind turbines, new surgical instruments, energy efficient buildings, comfortable chairs, and so much more. 

We have some mechanical engineers who are now designing a kindle for the blind! Mechanical engineers not only design many exciting products, they also venture into managing large projects and companies; become patent attorneys; research exciting breakthroughs such as those needed in energy storage; and even become medical doctors! And, yes, mechanical engineers do a significant amount of computer programming, which they use as a tool to predict things like how fast our stomach dissolves medication, how to design better airplane wings, and how to make cars that require less fuel. 

MEs do lots of computer programing, but with an intention of making predictions for better products. Finally, I'm not exactly sure what you mean by an IB degree. As an aside, we do not require this, but do have a strong emphasis in our program on making sure the MEs that we educate have a global view of engineering. For example, our Penn State ME students are now working with students in China, Singapore, and Korea to come up with better designs requested by many companies. This is an exciting program and our students are getting a much better view of the world through working in multi-national teams. I hope this is helpful and I wish you the very best of success. Hopefully, I will see you at Penn State one day enrolled as an ME student! Professor Thole

Answer 2 by Miss Marita Cheng

Hi Tierra, A mechanical engineer uses physics and material science to solve real-world problems, such as working on car engines, rockets and planes; manufacturing plants, and medical devices. Doing computer programming before doing engineering will definitely help, especially in the field of robotics, and anything that requires a system to be programmed. 

Having a degree in both computer programming and mechanical engineering will definitely give you an edge in the field. The IB is a great program to do if you want to study engineering, as the IB encourages students to think outside of the box, which is something engineers have to do everyday. Engineering is a great field to study, as there are so many opportunities for you to travel around the world, but more importantly, to improve the lives of millions of people. Good luck with your studies! Regards, Marita

另外一份則是有關機械設計領域的要求:

http://www.fvtc.edu/public/academics/degree.aspx?plan=10-606-1

Program Outcomes

Mechanical Design Technology graduates will be able to:

Use appropriate problem-solving methods to identify, analyze and solve problems in an engineering environment.

Select and utilize various CAD and other engineering application software.

Continue their own personal goals through achieving additional technical skills.

Prepare mechanical drawings which communicate design and details for fabrication and/or assembly.

Design products in accordance with customer specifications.

Communicate design ideas using a variety of communication methods.

Function effectively and productively within a team-focused work group.

Provide a base for life-long learning.

泛機械工程師的基本要求:

http://www.wisegeek.com/what-skills-are-needed-for-mechanical-engineer-employment.htm

Mechanical engineers research, design, and build machines and equipment of all types. They can specialize in designing engines, automobiles, consumer products, electronics, or heavy machinery, among other areas. There are several important technical and personal skills that an individual looking for employment in this field should possess. A successful engineer is creative, efficient, detail-oriented, and mechanically inclined. He or she must be a master of computer design and have specialized knowledge of physics and electricity in order to produce efficient, reliable machines.

Many different personal traits and skills are necessary to secure mechanical engineer employment. Professionals need to have strong problem-solving skills in order to invent and test new designs. Creativity and perseverance are essential in trial-and-error experiments with prototypes. Most engineers need strong communication skills as well, as they are frequently required to work in teams with other engineers and correspond with management and patent office workers. They also need strong educational backgrounds in math and physics to help them calculate statistics and determine the most efficient ways of putting machines together.

機械工程師的基本能力要求:

http://www10.hrsdc.gc.ca/English/ShowProfile.aspx?v=232

其中, 對於電腦應用方面的能力要求:

H. Computer Use

Tasks Complexity Level

Examples

Typical 2 to 3

Most Complex 4 to 5

Mechanical Engineers

use databases. For example, they consult vendor databases in Access for equipment specifications to identify models that meet their needs. They also access client contact information, project histories, maintenance services performed and problems encountered by using search features of customer management software programs. (2)

use financial software. For example, they may prepare project and annual operating budgets using the basic features of financial software programs such as QuickBooks. (2)

use communications software. For example, they may use Outlook to exchange e-mail with attached documents with co-workers, colleagues and clients. (2)

use word processing software. For example, they use Word to write letters to clients, vendors and contractors using standard templates. They also write analysis reports and books of specifications containing tables of contents, heading levels, tables, graphs, imported pictures and bulleted lists. (3)

use graphics software. For example, they use PowerPoint to present the results of analysis reports by using text, tables, graphs, pictures and animations. (3)

use spreadsheet software. They set-up or create spreadsheets such as Excel to collect data and create schedules and budgets. For example, they plan project budgets, complete expense reports, monitor project expenditures, project schedules and person-hours worked. They may create models to solve complicated math equations by using advanced features of spreadsheet software. (3)

use statistical analysis software. For example, they may conduct reliability studies and data analyses using the advanced features of statistical analysis software such as SPSS. (3)

use computer-assisted design, manufacturing and machining software. For example, they may draw mechanical plans using AutoCAD. They create three-dimensional models using advanced features of three-dimensional modelling software and enter data of the architectural and engineering plans and of existing structures into the software before drawing the mechanical structures. (3)

use Internet software. For example, they use Internet Explorer to find information on new products and technologies using search engines. They may also move large electronic files to customers using Internet file transfer protocol. Mechanical engineers may access web servers remotely using virtual private network protocols. For example, they access and analyze vibration monitoring data at customer locations via the Internet. They also download data from customer sites to their servers for further analysis. (3)

may use other software. For example, they may plan, schedule and monitor projects using the advanced features of project management software. They may view digital site photographs using image viewer software. They may use various specialized software to identify the preventive maintenance required for machinery and equipment, conduct vibration analysis of machines and develop reports of thermal imaging and measurement. (3)

may do programming, system and software design. For example, they may program robots using Programmable Logic Controllers such that the robots can interface with other robots and existing equipment. (5)

Computer Use Summary

The symbol √ is explained in the Use of Symbols section.

.. code-block:: none

    √  Use word processing. (運用文書處理系統)
    √  Use graphics software. (運用圖形處理軟體)
    √  Use a database. (運用資料庫)
    √  Use a spreadsheet. (運用試算表)
    √  Use financial software. (運用財務軟體)
    √  Use statistical analysis software. (運用統計分析軟體)
    √  Do programming or systems and software design. (執行程式或系統與軟體設計)
    √  Use computer-assisted design, manufacture or machining. (運用電腦輔助設計製造或加工)
    √  Use communications software. (運用通訊軟體)
    √  Use Internet (運用網際網路)
    √  Other
.. @+node:amd_yen.20130317094520.1538: *4* 機械設計工程師的 Python3
以下資料為 mp3 考試的題目來源之一:

Introduction to programming

The intent of this text is to introduce you to computer programming using the Python
programming language. Learning to program is a bit like learning to play piano, although
quite a bit easier since we won't have to program while keeping time according to a time
signature. Programming is a creative process so we'll be working on developing some
creative skills. At the same time, there are certain patterns that can be used over and over
again in this creative process. The goal of this text and the course you are taking is to get
you familiar with these patterns and show you how they can be used in programs. After
working through this text and studying and practicing you will be able to identify which
of these patterns are needed to implement a program for a particular task and you will be
able to apply these patterns to solve new and interesting problems.

As human beings our intelligent behavior hinges on our ability to match patterns. We
are pattern-matchers from the moment we are born. We watch and listen to our parents
and siblings to learn how to react to situations. Babies watch us to learn to talk, walk, eat,
and even to smile. All these behaviors are learned through pattern matching. Computer
Science is no different. Many of the programs we create in Computer Science are based
on just a few patterns that we learn early in our education as programmers. Once we've
learned the patterns we become effective programmers by learning to apply the patterns
to new situations. As babies we are wired to learn quickly with a little practice. As we
grow older we can learn to use patterns that are more abstract. That is what Computer
Science is all about: the application of abstract patterns to solve new and interesting prob-
lems.

PRACTICE is important. There is a huge difference between reading something in this
text or understanding what is said during a lecture and being able to do it yourself. At times
this may be frustrating, but with practice you will get better at it. As you read the text make
sure you take time to do the practice exercises. Practice exercises are clearly labeled with
a gray background color. These exercises are your chance to use a concept that you have
just learned. Answers to practice exercises are included at the end of each chapter so you
can check your answers.

What is Python?

Python is an interpreted, interactive, object-oriented programming language. It incorporates modules, exceptions, dynamic typing, very high level dynamic data types, and classes. Python combines remarkable power with very clear syntax.  It has interfaces to many system calls and libraries, as well as to various window systems, and is extensible in C or C++.  It is also usable as an extension language for applications that need a programmable interface. Finally, Python is portable: it runs on many Unix variants, on the Mac, and on Windows 2000 and later.

Are there copyright restrictions on the use of Python?

You can do anything you want with the source, as long as you leave the copyrights in and display those copyrights in any documentation about Python that you produce. If you honor the copyright rules, it's OK to use Python for commercial use, to sell copies of Python in source or binary form (modiﬁed or unmodiﬁed), or to sell products that incorporate Python in some form. We would still like to know about all commercial use of Python, of course.

Why was Python created in the ﬁrst place?

Here's a very brief summary of what started it all, written by Guido van Rossum:

I had extensive experience with implementing an interpreted language in the ABC group at CWI,
and from working with this group I had learned a lot about language design.  This is the origin of
many Python features, including the use of indentation for statement grouping and the inclusion of
very-high-level data types (although the details are all different in Python).

I had a number of gripes about the ABC language, but also liked many of its features. It was impos-
sible to extend the ABC language (or its implementation) to remedy my complaints – in fact its lack
of extensibility was one of its biggest problems. I had some experience with using Modula-2+ and
talked with the designers of Modula-3 and read the Modula-3 report. Modula-3 is the origin of the
syntax and semantics used for exceptions, and some other Python features.

I was working in the Amoeba distributed operating system group at CWI. We needed a better way to
do system administration than by writing either C programs or Bourne shell scripts, since Amoeba
had its own system call interface which wasn't easily accessible from the Bourne shell.  My expe-
rience with error handling in Amoeba made me acutely aware of the importance of exceptions as a
programming language feature.

It occurred to me that a scripting language with a syntax like ABC but with access to the Amoeba
system calls would ﬁll the need.  I realized that it would be foolish to write an Amoeba-speciﬁc
language, so I decided that I needed a language that was generally extensible.

During the 1989 Christmas holidays, I had a lot of time on my hand, so I decided to give it a try. Dur-
ing the next year, while still mostly working on it in my own time, Python was used in the Amoeba
project with increasing success, and the feedback from colleagues made me add many early improve-
ments.

In February 1991, after just over a year of development, I decided to post to USENET. The rest is in
the Misc/HISTORY ﬁle.

What is Python good for?

Python is a high-level general-purpose programming language that can be applied to many different classes of problems.

The language comes with a large standard library that covers areas such as string processing (regular expressions, Unicode, calculating differences between ﬁles), Internet protocols (HTTP, FTP, SMTP, XML-RPC, POP, IMAP, CGI programming), software engineering (unit testing, logging, proﬁling, parsing Python code), and operating system interfaces (system calls, ﬁlesystems, TCP/IP sockets).  Look at the table of contents for library-index to get an idea of what's available.  A wide variety of third-party extensions are also available.

其他參考資料:

http://nematodes.org/martin/teaching/introduction-to-python-for-biologists/

introduction to python for mechanical design engineers

機械設計工程師的 Python 程式簡介

applied python for mechanical design engineers

機械設計工程師的 Python 程式應用

applied python 1 - python3 and engineering calculation

>>> import math

>>> math . exp (1.0)

2.7182818284590451

Using the dir function, we can see the directory of objects available in the math module:

>>> dir ( math )

[ ' __doc__ ' , ' __file__ ' , ' __name__ ' , ' acos ' , ' asin ' , ' atan ' , ' atan2 ' ,
' ceil ' , ' cos ' , ' cosh ' , ' degrees ' , 'e ' , ' exp ' , ' fabs ' , ' floor ' ,
' fmod ' , ' frexp ' , ' hypot ' , ' ldexp ' , ' log ' , ' log10 ' , ' modf ' , ' , ' pi ' ,
' pow ' , ' radians ' , ' sin ' , ' sinh ' , ' sqrt ' , ' tan ' , ' tanh ']

>>> math . pi

3.1415926535897931

>>> math . e

2.7182818284590451

>>> math . cos ( math . pi )

-1.0

>>> math . log ( math . e )

1.0

applied python 2 - Vpython, PyGame and STL viewer

函式定義:

寫一個 distance(a, b) 函式, 可以傳回 a 數值與 b 數值差的絕對值.

寫一個 convert_to_metric(a, b) 函式, 可以計算邊長分別為 a 與 b 公分的矩形, 其平方英吋的面積.

寫一個函式 balls_in_space(n, r, d), 執行時, 可以顯示 n 個半徑為 r 的球, 排成一直線, 球心距離為 d.

寫一個函式 stl_ascii_to_binary(mypart.stl), 執行時, 可以開啟文字格式的 stl 零件檔, 並且轉寫為二位元格式的 stl 零件檔.

寫一個函式 stl_viewer(mypart.stl), 執行時, 可以自動判別 stl 格式為文字或二位元格式, 並將零件顯示在視窗畫面.

applied python 3 - Docutils, Sphinx and LaTeX

利用 Python 進行文書處理

applied python4 - Pyforum in CherryPy, Mako and Pybean

利用 Python 進行產品資料管理
    
.. @+node:amd_yen.20130317094520.1539: *5* @url after hours programming
http://www.afterhoursprogramming.com/tutorial/Python/Overview/

以上內容的 mp3 朗讀: http://cae.mde.tw?download=c2mp3.7z (考試範圍)





.. @+node:amd_yen.20130317160119.1723: *5* @url Scientific computing Python
http://www.scientificpython.net/
.. @+node:amd_yen.20130317160119.1724: *5* @url Python scientific lectures
http://scipy-lectures.github.com/
.. @+node:amd_yen.20130317160119.1725: *5* @url  Python for computational engineering
http://www.southampton.ac.uk/~fangohr/training/python/pdfs/Python-for-Computational-Science-and-Engineering.pdf

Slides: http://www.southampton.ac.uk/~fangohr/training/python/pdfs/Python-for-Computational-Science-and-Engineering-slides.pdf
.. @+node:amd_yen.20130310215908.1491: *4* tkinter
.. code-block:: python
    :linenos:

    #coding: utf-8
    from tkinter import *
    root = Tk(className="視窗標題")
    w = Label(root, text = "第一個視窗程式")
    w.pack()
    root.mainloop()
    
單位換算視窗程式:

.. code-block:: python
    :linenos:

    from tkinter import *
    from tkinter import ttk
    
    # source: http://www.tkdocs.com/tutorial/firstexample.html
    def calculate(*args):
        try:
            value = float(feet.get())
            meters.set((0.3048 * value * 10000.0 + 0.5)/10000.0)
        except ValueError:
            pass
        
    root = Tk()
    root.title("Feet to Meters")
    
    mainframe = ttk.Frame(root, padding="3 3 12 12")
    mainframe.grid(column=0, row=0, sticky=(N, W, E, S))
    mainframe.columnconfigure(0, weight=1)
    mainframe.rowconfigure(0, weight=1)
    
    feet = StringVar()
    meters = StringVar()
    
    feet_entry = ttk.Entry(mainframe, width=7, textvariable=feet)
    feet_entry.grid(column=2, row=1, sticky=(W, E))
    
    ttk.Label(mainframe, textvariable=meters).grid(column=2, row=2, sticky=(W, E))
    ttk.Button(mainframe, text="Calculate", command=calculate).grid(column=3, row=3, sticky=W)
    
    ttk.Label(mainframe, text="feet").grid(column=3, row=1, sticky=W)
    ttk.Label(mainframe, text="is equivalent to").grid(column=1, row=2, sticky=E)
    ttk.Label(mainframe, text="meters").grid(column=3, row=2, sticky=W)
    
    for child in mainframe.winfo_children(): child.grid_configure(padx=5, pady=5)
    
    feet_entry.focus()
    root.bind('<Return>', calculate)
    
    root.mainloop()
    
一般計算機:

.. code-block:: python
    :linenos:
    
    #coding: utf8
    '''
    簡單的 tkinter 計算機
    '''
    # 來源: http://bsspirit.appspot.com/20101222/python3-Tkinter-Calculator.html
    
    from tkinter import *
    from tkinter.font import Font
    
    def 按鍵(框架, 文字, 執行函式=None):
        字型 = Font(family=('Verdana'), size=14)
        return Button(框架, text=文字, font=字型, width=3, command=執行函式)
    
    def 框架(框架, 對齊=LEFT, 背景顏色="black"):
        框架 = Frame(框架, background=背景顏色, padx=5, pady=5)
        框架.pack(side=對齊, expand=YES, fill=BOTH)
        return 框架
    
    class 應用程式:
        def __init__(self, 視窗):
            字型 = Font(family=('Verdana'), size=14)
            主視窗 = 框架(視窗)
    
            左邊框架 = 框架(主視窗)
            右邊框架 = 框架(主視窗)
            計算區 = 框架(左邊框架)
            
            self.輸入 = Entry(計算區, font=字型, width=15, background="white")
            self.輸入.pack(side=TOP)
    
            self.按鍵框架 = 框架(計算區)
    
            x, y = 0, 0
            for 按鍵配置 in ("()%C", "+-*/", "1234", "5678", "90.="):
                for 字元 in 按鍵配置:
                    if 字元 == "=":
                        類別按鍵 = 按鍵(self.按鍵框架, 字元, self.計算動作)
                    elif 字元 == "C":
                        類別按鍵 = 按鍵(self.按鍵框架, 字元, self.清除畫面)
                    else:
                        類別按鍵 = 按鍵(self.按鍵框架, 字元, lambda 內容=字元: self.輸入.insert(INSERT, 內容))
                        
                    類別按鍵.grid(row=x, column=y)
                    y += 1
    
                x += 1
                y = 0
    
            self.紀錄 = Text(右邊框架, font=Font(family=('Verdana'), size=10), width=25, height=14, background="yellow")
            self.紀錄.pack(side=RIGHT)
    
        def 清除畫面(self):
            self.輸入.delete(0, END)
    
        def 計算動作(self):
            暫存 = self.輸入.get()
            try:
                結果 = 暫存 + "=" + str(eval(暫存))
                self.紀錄.insert(1.0, 結果 + "\n");
                print(結果)
            except Exception:
                self.紀錄.insert(1.0, "抱歉! 發生錯誤\n");
    
    
    if __name__ == '__main__':
        視窗= Tk()
        視窗.title("計算機")
        #視窗.geometry()
        我的應用程式 = 應用程式(視窗)
        視窗.mainloop()
        
請以組為單位, 將上述一般計算機改為工程用計算機程式.

參考資料:

http://infohost.nmt.edu/tcc/help/pubs/tkinter.pdf

http://www.tkdocs.com/tutorial/

https://github.com/doctoboggan/PYQT-Calculator

https://github.com/smjrifle/Python-Calculator
.. @+node:amd_yen.20130313165007.1510: *4* matplotlib
結合 matplotlib 與 tkinter

.. code-block:: python
    :linenos:
    
    #! /usr/bin/env python
    # source: https://github.com/ondrejh/matplot_embed
    import matplotlib
    matplotlib.use('TkAgg')
    
    from numpy import arange, sin, pi
    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2TkAgg
    from matplotlib.figure import Figure
    
    import sys
    #import everything from tkinter module (Tkinter in python 2.x)
    try:
            from tkinter import *
    except:
            from Tkinter import *
    
    #application class
    class runapp(Frame):
        ''' dummy gui '''
        
        def __init__(self,master=None):
            self.root = Tk()
            self.root.title('Embedding MATPLOTLIB in TK')
            Frame.__init__(self,master)
            self.createWidgets()
        
        def createWidgets(self):
    
            self.f = Figure(figsize=(5,4), dpi=100)
            self.a = self.f.add_subplot(111)
            self.t = arange(0.0,3.0,0.01)
            self.n = 1
            self.s = sin(pi*self.t*self.n)
    
            self.a.plot(self.t,self.s)
            self.a.set(xlabel='x')
            self.a.set(ylabel='y')
    
            # a tk.DrawingArea
            self.canvas = FigureCanvasTkAgg(self.f, master=self.root)
            self.canvas.show()
            self.canvas.get_tk_widget().pack(side=TOP, fill=BOTH, expand=1)
    
            '''self.toolbar = NavigationToolbar2TkAgg(self.canvas, self.root)
            self.toolbar.update()
            self.canvas._tkcanvas.pack(side=TOP, fill=BOTH, expand=1)'''
    
            self.frmButtons = Frame(master=self.root)
            self.frmButtons.pack()
            self.buttonAdd = Button(master=self.frmButtons,text='Inc',command=self.fIncClick)
            self.buttonAdd.pack(side=LEFT)
            self.buttonSub = Button(master=self.frmButtons,text='Dec',command=self.fDecClick)
            self.buttonSub.pack(side=LEFT)
    
        def fIncClick(self):
            self.n += 1
            self.fRedraw()
    
        def fDecClick(self):
            if self.n>1:
                self.n -= 1
                self.fRedraw()
    
        def fRedraw(self):
            self.s = sin(pi*self.t*self.n)
            self.a.clear()
            self.a.plot(self.t,self.s)
            self.a.set(xlabel='x')
            self.a.set(ylabel='y')
            self.canvas.show()
                
        def _quit(self):
            print('kooonec')
            self.root.quit()     # stops mainloop
            self.root.destroy()  # this is necessary on Windows to prevent
                        # Fatal Python Error: PyEval_RestoreThread: NULL tstate
    
    app = runapp()
    app.mainloop()
    # If you put root.destroy() here, it will cause an error if
    # the window is closed with the window manager.
.. @+node:amd_yen.20130310161307.1486: *4* PyQt 應用
可以直接在 Leo Editor 中執行的 PyQt 程式:

.. code-block:: python
    :linenos:
    
    from PyQt4 import QtGui
    w = QtGui.QWidget()
    w.resize(250, 150)
    w.move(300, 300)
    w.setWindowTitle('Simple test')
    w.show()
    c.brian_test_w = w

機械設計視窗程式:

.. literalinclude:: ../c2/pyqt_geardesign.py
    :language: python
.. @+node:amd_yen.20130317160119.1728: *4* @url WinPython
https://code.google.com/p/winpython/

這是一套專門設計用於 Windows 環境的可攜 Python 程式開發環境, 基本設計理念與 portableKMOL 類似, 解開後容量為 540 MB.

基本特點:
.. @+node:amd_yen.20130330144838.1766: *3* C2 第五週
協同報告架構 - 請參考 C2G1

是否可以將此架構與 Pyforum 網際程式結合?
.. @+node:amd_yen.20130330144838.1767: *3* C2 第六週
期中專案

利用 Python Tutor 與其他線上 Python3 教學套件, 整理 Python3 教學內容, 主要學習項目為:

::

    協同報告模式採: https://github.com/chiamingyen/mdeCourse

    網際框架參考: https://github.com/chiamingyen/leo_pyforum

    互動程式參考: https://github.com/bnmnetp/runestone

    互動程式參考: http://docs.runestoneinteractive.org/build/html/index.html

字串列印, 資料輸入, 整數與浮點數轉字串, 數值基本運算, 資料類別, Python 關鍵字: (and, as, assert, break, class, continue, def, del, elif, else, except, exec, finally, for, from, global, if, import, in, is, lambda, nonlocal, not, or, pass, raise, range, return, try, while, with, yield, True, False, None), 程式廻圈, 程式判斷式, math 與 random 模組, 函式定義與呼叫, 函式傳值與不傳值, 數列與元組, 檔案輸出入. 

字串列印:

.. code-block:: python

    print("字串內容")
    print("數值為:"+str(10.5))
    print("數值為:",10.5)
    print("數值為:"+str(10+float("0.5")))

資料輸入:

.. code-block:: python

    輸入值 = input("請輸入數值:")
    print("輸入值為:"+輸入值)
    print("輸入值加上1等於:"+str(1+float(輸入值)))

整數與浮點數轉字串:

.. code-block:: python

    整數值 = 1
    浮點數值 = 0.1
    print("將"+str(整數值)+"加上"+str(浮點數值)+"等於"+str(整數值+浮點數值))

數值基本運算:

.. code-block:: python
    import math
    print("圓週率為:"+str(math.pi))

資料類別:

.. code-block:: python

    print(type(0.1))
    print(type(10))
    print(type("字串"))

Python 關鍵字用法彙整:

.. code-block:: python

    def 函式(輸入):
        輸出 = 0
        for 索引 in range(輸入+1):
            輸出  = 輸出 + 索引
        return 輸出
    
    累加至 = 10
    if type(累加至).__name__ != "int":
        print(累加至, "不是整數, 無法累加!")
    else:
        變數 = 函式(累加至)
        print(變數)
    
    累加至 = 10.1
    if type(累加至).__name__ != "int":
        print(累加至, "不是整數, 無法累加!")
    else:
        變數 = 函式(累加至)
        print(變數)

math 與 random 模組用法:

函式定義與呼叫:

數列與元組:

檔案輸出入:

期末專案

項目一: 工程單位轉換與網際程式開發

::

單位轉換參考: https://bitbucket.org/kiv/unum/src

Python 在動態機構模擬上的應用: double pendulum

https://github.com/gilbertgede/pydy_examples

http://www.pydy.org/double_pendulum

自行車動態模擬: 

http://docs.sympy.org/dev/modules/physics/mechanics/examples.html#the-bicycle

https://github.com/hazelnusse/bicycle.model

.. code-block:: python

    from sympy import symbols  
    from sympy.physics.mechanics import *
     
    q1, q2 = dynamicsymbols('q1 q2')
    q1d, q2d = dynamicsymbols('q1 q2', 1)
    u1, u2 = dynamicsymbols('u1 u2')
    u1d, u2d = dynamicsymbols('u1 u2', 1)
    l, m, g = symbols('l m g')
     
    N = ReferenceFrame('N')
    A = N.orientnew('A', 'Axis', [q1, N.z])
    B = N.orientnew('B', 'Axis', [q2, N.z])
     
    A.set_ang_vel(N, u1 * N.z)
    B.set_ang_vel(N, u2 * N.z)
     
    O = Point('O')
    P = O.locatenew('P', l * A.x)
    R = P.locatenew('R', l * B.x)
     
    O.set_vel(N, 0)
    P.v2pt_theory(O, N, A)
    R.v2pt_theory(P, N, B)
     
    ParP = Particle('ParP', P, m)
    ParR = Particle('ParR', R, m)
     
    kd = [q1d - u1, q2d - u2]
    FL = [(P, m * g * N.x), (R, m * g * N.x)]
    BL = [ParP, ParR]
     
    KM = KanesMethod(N, q_ind=[q1, q2], u_ind=[u1, u2], kd_eqs=kd)
     
    (fr, frstar) = KM.kanes_equations(FL, BL)
    kdd = KM.kindiffdict()
    mm = KM.mass_matrix_full
    fo = KM.forcing_full
    qudots = mm.inv() * fo
    qudots = qudots.subs(kdd)
    qudots.simplify()
    mechanics_printing()
    mprint(qudots)

sympy 的幾何運算應用:

.. code-block:: python

    #encoding: utf-8
    from sympy import *
    from sympy.geometry import *
    
    # 定義四個點物件
    x = Point(0, 0)
    y = Point(1, 1)
    z = Point(2, 2)
    zp = Point(1, 0)
    
    # 判斷三點是否共線
    print(Point.is_collinear(x, y, z))
    print(Point.is_collinear(x, y, zp))
    
    # 利用三點定一個三角形物件
    t = Triangle(zp, y, x)
    # 求出三角形面積
    print("三角形面積為:",t.area)
    # 求出三角形的三條中線線段
    print("三角形中線:", t.medians)
    m = t.medians
    # 利用三條中線求重心位置, m[x] 表示由 x 點產生的中線
    print("三線交點",intersection(m[x], m[y], m[zp]))
    c = Circle(x, 5)
    l = Line(Point(5, -5), Point(5, 5))
    print(c.is_tangent(l)) # is l tangent to c?
    l = Line(x, y)
    print(c.is_tangent(l)) # is l tangent to c?
    print("圓與線的交點:",intersection(c, l))


項目二: 2D 基本繪圖與 STL 零件檔案轉換

1. 使用者上傳 2D 繪圖資料檔案 (例如: Sin(t), Cos(t) 或其他函式數值資料檔), 網際程式繪圖後轉為 png 格式存檔.

學習重點在於 Python 的平面繪圖, 網際檔案上傳與資料處理

Pybean 與 SQLite 資料庫的使用

2. 使用者上傳 ASCII STL 格式 3D 零件檔案, 網際程式轉為 Binary STL 格式 3D 零件檔案, 並且分別於瀏覽器展示零件檔案.

STL ASCII 與 binary 格式的資料處理

Python 程式應用項目:

類別與物件導向, 資料庫, 網際框架與 template engine, 字典, 2D 繪圖, 3D 繪圖, 工程資料轉檔.
.. @+node:amd_yen.20130406103207.2443: *3* C2 第七週
程式題目:

1. 寫一個程式, 可以接受使用者三個數值的輸入, 然後將三個輸入值的平均數印出.

2. 寫一個程式, 可以接受使用者輸入英吋, 程式會將所輸入的英吋轉為公分後印出數值.

3. 寫一個網際程式, 在瀏覽器中有三個資料輸入欄位, 當使用者在三個欄位填入數值送出後, 可以直接在瀏覽器中印出所輸入三個數值的平均數.

4. 寫一個網際程式, 在瀏覽器中有三個資料輸入欄位, 其中兩個欄位可以讓使用者輸入學號與姓名, 而第三個欄位則可以填入三行以上的文字資料, 使用者填完後, 按下送出鍵後, 程式會列出輸入者的學號與姓名, 並且提供一個按鍵連結, 使用者點後該連結後, 可以下載先前所輸入的文字資料檔案.

5. 寫一個網際程式, 可以在瀏覽器中接受使用者上傳一個文字檔案, 其中文字檔案的格式為:

學號    成績
101      80
102      82
103      84
104      85

當使用者完成檔案上傳後, 該網際程式會解讀所上傳的檔案, 並且印出四位同學該次考試的平均成績.

6. 假如要將上述程式中有關的資料存入資料庫, 應該如何進行.

.. code-block:: python

    #encoding: utf-8
    # 請注意以下的 pybean 語法為 0.1.2 版本, 使用 uuid 來辨識各筆資料, pybean 0.2.1 版已經改為整數 id, 不再使用 uuid, 用法上有些差異
    # pybean 0.1.2 與 0.2.1 最大的差異為 uuid 改為 id, commit 不再放入各別資料存取流程中執行, 而是集中在 save 與 delete 時才進行 commit, 大大提升 pybean 的運行速度
    from pybean import Store, SQLiteWriter
    # 將資料存入記憶體中, frozen=False 表示可以動態新增表格與欄位
    #library = Store(SQLiteWriter(":memory:", frozen=False))
    # 將資料存入 sqlite 資料庫檔案中, frozen=False 表示可以動態新增表格與欄位
    # 設定 frozen=False 表示可以 create tables and columns on the fly
    library = Store(SQLiteWriter("database.sqlite", frozen=False))
    # 動態建立 book 資料表
    book = library.new("book")
    # 印出與 book 資料表對應的唯一序號
    print (book.uuid.hex)
    # 動態建立 title 欄位
    book.title = "如何使用 Pybean 儲存資料"
    # 動態建立 author 欄位
    book.author = "Pybean 作者群"
    # 儲存資料表內容
    library.save(book)
    # 利用 find 方法搜尋資料表中的資料
    # 找出 book 資料表中 author 為 "Pybean 作者群" 的資料
    for book in library.find("book","author like ?",["Pybean 作者群"]):
            # 列印資料表中的 title 欄位
            print (book.title)
    # 搜尋資料的筆數
    資料筆數 = library.count("book")
    搜尋資料筆數 = library.count("book", "author like ?", ["Pybean 作者群"])
    # 1 代表 true:沒有特別加入其他篩選條件, 排序內定為 asc, 反向排為 desc
    搜尋資料筆數 = library.count("book", "1 order by author")
    # 以 find_one 找出所要的一筆資料
    一筆資料 = library.find_one("book","author=?",["Pybean 作者群"])
    # 針對所搜尋出的一筆資料進行修改
    一筆資料.author = "修改後的資料"
    # 將修改後的一筆資料存入資料表中
    library.save(一筆資料)
    # 假如要刪除所找出的一筆資料, 使用 delete
    #libry.delete(一筆資料)
    print(資料筆數)
    print(搜尋資料筆數)
    print(一筆資料.title,"_",一筆資料.author)
     
    # 列出目前的資料庫內容
    for book in library.find("book","1"):
            # 列印資料表中的 title 欄位
            print (book.title, book.author)
     
    # 刪除資料表中 book bean 的對應資料
    #library.delete(book)
    
採用 uuid 的 pybean 版本:

使用此一 uuid 版本的關鍵在於, 必須 from uuid import UUID, 並且利用 UUID(uuid).bytes 將 uuid 字串內容轉為 SQLite3 的 blob 資料格式, 才能正確對應到唯一的資料列.

一筆資料 = library.find_one(“student”,”uuid=?”,[UUID(uuid).bytes])

基本的 pybean 使用範例

.. code-block:: python

    #coding: utf-8
    from pybean import Store, SQLiteWriter
    # "frozen=True" means the SQLiteWriter won't create tables and columns on the fly
    # 使用 frozen = False 表示可以動態建立資料表
    library = Store(SQLiteWriter("database.sqlite", frozen=False))
    # 建立  book 資料 bean, 也就是建立一個名稱為 book 的資料表
    book = library.new("book")
    # 動態建立 book 資料表中的 title 欄位, 且將字串值放入此一 book 資料表中的 title 欄位
    book.title = "第一本書的標題"
    # 再動態建立 author 欄位, 且將字串值放入此一 author 欄位
    book.author = "第一本書的作者"
    # 儲存資料表 book 中的資料
    library.save(book)
    # 利用資料庫檔案中的 find 方法搜尋 book 資料表, 找出其中 author 欄位值有 "Charles Xavier" 字串的資料
    for book in library.find("book","author like ?",["第一本書的作者"]):
            # 若找到對應資料, 印出 book 資料表中 title 欄位的資料
            print (book.title)
    # 找出資料表中的所有資料
    # find all books, find method returns an iterator
    print(library.find("book"))
    print(library.find("book","1"))
    for book in library.find("book","1"):
        print (book.title)
    # 再建立 bean 與輸入資料值
    # 建立  book 資料 bean, 也就是建立一個名稱為 book 的資料表
    book = library.new("book")
    # 動態建立 book 資料表中的 title 欄位, 且將字串值放入此一 book 資料表中的 title 欄位
    book.title = "這是書的標題"
    # 再動態建立 author 欄位, 且將字串值放入此一 author 欄位
    book.author = "書的作者"
    # 儲存資料表 book 中的資料
    library.save(book)
    number_of_books = library.count("book")
    number_of_書_books = library.count("book", "author like ?", ["書的作者"])
    print(number_of_books,number_of_書_books)
    # 刪除此一 book 資料表內容 (請注意 book 為對應 book = library.new("book") 之後的內容資料
    library.delete(book)
    number_of_books = library.count("book")
    number_of_書_books = library.count("book", "author like ?", ["書的作者"])
    print(number_of_books,number_of_書_books)
    for book in library.find("book"):
        print (book.title, book.author)
    # 這是 pybean 0.2.1 版的新用法, 將各資料存取流程中所用的 commit, 集中到最後 save 與 delete 時才統一 commit, 此舉提升 pybean 0.2.1 版本的運行速度　
    #library.commit()

.. code-block:: python

    #coding: utf-8
    # 目前版本僅支援 sqlite3
    import sqlite3
    import uuid
    from pkg_resources import parse_version
     
    __version__ = "0.1.2"
    __author__ = "Mickael Desfrenes"
    __email__ = "desfrenes@gmail.com"
     
     
    class SQLiteWriter(object):
     
        """
        In frozen mode (the default), the writer will not alter db schema.
        Just add frozen=False to enable column creation (or just add False
        as second parameter):
     
        query_writer = SQLiteWriter(":memory:", False)
        """
        def __init__(self, db_path=":memory:", frozen=True):
            # 為了讓 sqlite3 可以跨不同的執行緒運作, 設定 check_same_thread = False
            # Yen add check_same_thread = False
            self.db = sqlite3.connect(db_path, check_same_thread = False)
            self.db.row_factory = sqlite3.Row
            self.frozen = frozen
            self.db.cursor().execute("PRAGMA foreign_keys=ON")
        def __del__(self):
            self.db.close()
     
        def replace(self, bean):
            keys = []
            values = []
            self.__create_table(bean.__class__.__name__)
            columns = self.__get_columns(bean.__class__.__name__)
            for key in bean.__dict__:
                keys.append(key)
                if key not in columns:
                    self.__create_column(bean.__class__.__name__, key,
                            type(bean.__dict__[key]))
                if isinstance(bean.__dict__[key], uuid.UUID):
                    values.append(sqlite3.Binary(bean.__dict__[key].bytes))
                else:
                    values.append(bean.__dict__[key])
            cursor = self.db.cursor()
            sql  = "replace into " + bean.__class__.__name__ + "(" 
            sql += ",".join(keys) + ") values (" 
            sql += ",".join(["?" for i in keys])  +  ")"
            cursor.execute(sql, values)
            self.db.commit()
     
        def __create_column(self, table, column, sqltype):
            if self.frozen:
                return
            if sqltype in [float, int, bool]:
                sqltype = "NUMERIC"
            else:
                sqltype = "TEXT"
            sql = "alter table " + table + " add " + column + " " + sqltype    
            self.db.cursor().execute(sql)
            self.db.commit()
     
        def __get_columns(self, table):
            columns = []
            if self.frozen:
                return columns
            cursor = self.db.cursor()
            cursor.execute("PRAGMA table_info(" + table  + ")")
            for row in cursor:
                columns.append(row["name"])
            return columns
     
        def __create_table(self, table):
            if self.frozen:
                return
            sql = "create table if not exists " + table + "(uuid primary key)"
            self.db.cursor().execute(sql)
            self.db.commit()
     
        def get_rows(self, table_name, sql = "1", replace = None):
            if replace is None : replace = []
            self.__create_table(table_name)
            sql = "SELECT * FROM " + table_name + " WHERE " + sql
            cursor = self.db.cursor()
            try:
                cursor.execute(sql, replace)
                for row in cursor:
                    yield row
            except sqlite3.OperationalError:
                return
     
        def get_count(self, table_name, sql="1", replace = None):
            if replace is None : replace = []
            self.__create_table(table_name)
            cursor = self.db.cursor()
            sql = "SELECT count(*) AS cnt FROM " + table_name + " WHERE " + sql
            try:
                cursor.execute(sql, replace)
            except sqlite3.OperationalError:
                return 0
            for row in cursor:
                return row["cnt"]
     
        def delete(self, bean):
            self.__create_table(bean.__class__.__name__)
            sql = "delete from " + bean.__class__.__name__ + " where uuid=?"
            self.db.cursor().execute(sql,[sqlite3.Binary(bean.uuid.bytes)])
            self.db.commit()
     
        def link(self, bean_a, bean_b):
            self.replace(bean_a)
            self.replace(bean_b)
            table_a = bean_a.__class__.__name__
            table_b = bean_b.__class__.__name__
            assoc_table = self.__create_assoc_table(table_a, table_b)
            sql = "replace into " + assoc_table + "(" + table_a + "_uuid," + table_b
            sql += "_uuid) values(?,?)"
            self.db.cursor().execute(sql, 
                    [buffer(bean_a.uuid.bytes), buffer(bean_b.uuid.bytes)])
            self.db.commit()
     
        def unlink(self, bean_a, bean_b):
            table_a = bean_a.__class__.__name__
            table_b = bean_b.__class__.__name__
            assoc_table = self.__create_assoc_table(table_a, table_b)
            sql = "delete from " + assoc_table + " where " + table_a
            sql += "_uuid=? and " + table_b + "_uuid=?"
            self.db.cursor().execute(sql,
                    [buffer(bean_a.uuid.bytes), buffer(bean_b.uuid.bytes)]) 
            self.db.commit()
     
        def get_linked_rows(self, bean, table_name):
            bean_table = bean.__class__.__name__
            assoc_table = self.__create_assoc_table(bean_table, table_name)
            cursor = self.db.cursor()
            sql = "select t.* from " + table_name + " t inner join " + assoc_table 
            sql += " a on a." + table_name + "_uuid = t.uuid where a." 
            sql += bean_table + "_uuid=?"
            cursor.execute(sql,[buffer(bean.uuid.bytes)])
            for row in cursor:
                yield row
     
        def __create_assoc_table(self, table_a, table_b):
            assoc_table = "_".join(sorted([table_a, table_b]))
            if not self.frozen:
                sql = "create table if not exists " + assoc_table + "("
                sql+= table_a + "_uuid NOT NULL REFERENCES " + table_a + "(uuid) ON DELETE cascade,"
                sql+= table_b + "_uuid NOT NULL REFERENCES " + table_b + "(uuid) ON DELETE cascade,"
                sql+= " PRIMARY KEY (" + table_a + "_uuid," + table_b + "_uuid));"
                self.db.cursor().execute(sql)
                # no real support for foreign keys until sqlite3 v3.6.19
                # so here's the hack
                if cmp(parse_version(sqlite3.sqlite_version),parse_version("3.6.19")) < 0:
                    sql = "create trigger if not exists fk_" + table_a + "_" + assoc_table
                    sql+= " before delete on " + table_a
                    sql+= " for each row begin delete from " + assoc_table + " where " + table_a + "_uuid = OLD.uuid;end;"
                    self.db.cursor().execute(sql)
                    sql = "create trigger if not exists fk_" + table_b + "_" + assoc_table
                    sql+= " before delete on " + table_b
                    sql+= " for each row begin delete from " + assoc_table + " where " + table_b + "_uuid = OLD.uuid;end;"
                    self.db.cursor().execute(sql)
            self.db.commit()        
            return assoc_table
     
        def delete_all(self, table_name, sql = "1", replace = None):
            if replace is None : replace = []
            self.__create_table(table_name)
            cursor = self.db.cursor()
            sql = "DELETE FROM " + table_name + " WHERE " + sql
            try:
                cursor.execute(sql, replace)
                return True
            except sqlite3.OperationalError:
                return False
     
    class Store(object):
        """
        A SQL writer should be passed to the constructor:
     
        beans_save = Store(SQLiteWriter(":memory"), frozen=False)
        """
        def __init__(self, SQLWriter):
            self.writer = SQLWriter 
     
        def new(self, table_name):
            new_object = type(table_name,(object,),{})()
            new_object.uuid = uuid.uuid4()
            return new_object
     
        def save(self, bean):
            self.writer.replace(bean)
     
        def load(self, table_name, uuid):
            for row in self.writer.get_rows(table_name, "uuid=?", [buffer(uuid.bytes)]):
                return self.row_to_object(table_name, row)
     
        def count(self, table_name, sql = "1", replace=None):
            return self.writer.get_count(table_name, sql, replace if replace is not None else [])
     
        def find(self, table_name, sql = "1", replace=None):
            for row in self.writer.get_rows(table_name, sql, replace if replace is not None else []):
                yield self.row_to_object(table_name, row)
     
        def find_one(self, table_name, sql = "1", replace=None):
            try:
                return next(self.find(table_name, sql, replace))
                # 原先程式只能用於 Python2, 配合 Python3, 修改為上一行
                #return self.find(table_name, sql, replace).next()
            except StopIteration:
                return None
     
        def delete(self, bean):
            self.writer.delete(bean)
     
        def link(self, bean_a, bean_b):
            self.writer.link(bean_a, bean_b)
     
        def unlink(self, bean_a, bean_b):
            self.writer.unlink(bean_a, bean_b)
     
        def get_linked(self, bean, table_name):
            for row in self.writer.get_linked_rows(bean, table_name):
                yield self.row_to_object(table_name, row)
     
        def delete_all(self, table_name, sql = "1", replace=None):
            return self.writer.delete_all(table_name, sql, replace if replace is not None else [])
     
        def row_to_object(self, table_name, row):
            new_object = type(table_name,(object,),{})()
            for key in row.keys():
                if key == "uuid":
                    new_object.uuid = uuid.UUID(bytes=row[key])
                else:
                    new_object.__dict__[key] = row[key]
            return new_object
.. @+node:amd_yen.20130408141041.2453: *4* redbean 與 pybean 的比較
redbean 為 PHP 的 ORM 介面程式庫, 而 pybean 則為 Python 的 ORM 模組, 目前只支援 SQLite.

pybean 0.2.1 的用法

# 導入 pybean 模組與所要使用的 Store 及 SQLiteWriter 方法
from pybean import Store, SQLiteWriter
# 利用 Store  建立資料庫檔案對應物件, 並且設定 frozen=False 表示要開放動態資料表的建立
library = Store(SQLiteWriter("database.sqlite", frozen=False))
# 動態建立 book 資料表
book = library.new("book")
# 動態建立 title 欄位
book.title = "如何使用 Pybean 儲存資料"
# 動態建立 author 欄位
book.author = "Pybean 作者群"
# 儲存資料表內容
library.save(book)
# 當資料庫內容有變更時, 必須要執行 commit() 才會有作用
library.commit()

# 資料查詢
for book in library.find("book","author like ?",["Pybean 作者群"]):
        # 列印資料表中的 title 欄位
        print (book.title)
        
# 計算資料查詢筆數
搜尋資料筆數 = library.count("book", "1 order by author")

# 資料更新
# 以 find_one 找出所要更新的一筆資料
一筆資料 = library.find_one("book","author=?",["Pybean 作者群"])
# 針對所搜尋出的一筆資料進行修改
一筆資料.author = "修改後的資料"
# 將修改後的一筆資料存入資料表中
library.save(一筆資料)
# 執行上述資料變更
library.commit()

# 資料刪除
# 以 find_one 找出所要刪除的一筆資料
一筆資料 = library.find_one("book","author=?",["Pybean 作者群"])
# 針對所搜尋出的一筆資料進行刪除
library.delete(一筆資料)
# 執行上述資料刪除
library.commit()

readbean PHP 的用法

// 導入 rb.php
require_once('./plugins/common/rb.php');
// 建立資料庫檔案與程式物件對應
R::setup('sqlite:'.dirname(__FILE__).'/db/dbfile.db');

// 將資料庫中的資料表與程式物件 $bean 對應
//lewis is the type of the bean, 也就是資料庫檔案中的資料表名稱
$bean = R::dispense('lewis');

// 資料表中欄位資料設定
// 在 gear_num 與 mould 欄位中輸入特定資料
$bean->gear_num = "齒數";
$bean->mould = "模數";

//Store the bean, 資料儲存
//等同 insert, 將資料表中的資料存入資料庫中, 且取回其所對應的 $id 值
$id = R::store($bean);

// 計算資料表 lewis 中的資料筆數
$num =R::count('lewis');
$output .= "資料庫中共有".$num."筆資料<br />";

// 更改資料
$title = "齒數";
// 只找出符合搜尋條件的第一筆資料, 且設為 $one 物件
$one = R::findone("lewis","gear_num=?",array($title));
// 設定查詢物件的欄位對應值
$one->gear_num = "小齒數";
// 儲存上述修改
R::store($one);

// 取出資料表中的所有資料
// 由 lewis 資料表中取出所有資料
// 1 代表 true:沒有特別加入其他篩選條件, 排序內定為 asc, 反向排為 desc
$all_data = R::find("lewis","1 order by id desc");

foreach ($all_data as $data) {
    $output .= $data->id.":".$data->gear_num."|".$data->mould."<br />";
}

// 關閉資料庫檔案連結
// To disconnect use: R::close(); 
R::close();

// 建立一個 bean 物件 $shop, 與資料表 shop 對應
$shop = R::dispense('shop');

// 設定 $bean 物件的性質
// And this is how you set properties:
$shop->name = 'Antiques';

// 儲存 $shop bean 物件
// This is how you store the shop in the database:
$id = R::store($shop);

// 載入之前已經存檔的 shop 資料表
// This is how you load your previously stored shop:
$shop = R::load('shop',$id);

// 刪除 $shop bean 物件
// And this is how you delete the shop from the database:
R::trash($shop); 
.. @+node:amd_yen.20130411195311.2086: *3* C2 第八週
.. @+node:amd_yen.20130411195311.2087: *4* OpenCASCADE
直接利用 occmodel 建立零件檔案, 並且轉為 stl 或 step 格式後直接以 Python 開啟.

文件說明: http://tenko.github.io/occmodel/index.html

Windows oce prebuilt: https://github.com/tpaviot/oce/downloads

主要下載 oce 0.10: https://github.com/downloads/tpaviot/oce/OCE-0.10.0-Win-MSVC2010.zip

.. code-bolck:: python

    #coding: utf-8
    # 使用 occmodel 模組, 間接擷取 Open CASCADE 函式庫
    from occmodel import *
    from occmodelviewer import *
    from visual import scene, color, materials, faces, points
    import os, struct
    # 建立三個 circles, 然後 loft 成實體, 印出體積後
    # 最後再轉成 loft.stp STEP 檔案
    第一個圓 = Edge().createCircle(center=(0.,0.,0.),normal=(0.,0.,1.),radius = 1.2)
    第二個圓 = Edge().createCircle(center=(0.,0.,5.),normal=(0.,0.,1.),radius = 1.5)
    第三個圓 = Edge().createCircle(center=(0.,0.,10.),normal=(0.,0.,1.),radius = 1.0)
    solid = Solid().loft((第一個圓,第二個圓,第三個圓), True)
    print (solid.volume())
    # 特別注意轉出 loft.stp 的用法
    Tools.writeSTEP(bytes('loft.stp'.encode("utf-8")),solid)
    # 轉成 ASCII STL
    Tools.writeSTL(bytes('loft.stl'.encode("utf-8")),solid)
    
    file ="loft.stl"
     
    scene.width = 400
    scene.height = 400
    scene.background = color.white # black
    # 視窗標題取自 cvisual.pyd, 不可使用中文
    scene.title = "STLViewer in VPython"
     
    print ("利用滑鼠右鍵旋轉")
    print ("滑鼠左右鍵同時按下後移動, 可以縮放畫面")
     
    # Read STL file, only use vertex-line with xyz coordinates
    list = []
     
    #load stl file detects if the file is a text file or binary file
    def load_stl(filename):
        #read start of file to determine if its a binay stl file or a ascii stl file
        fp=open(filename,'rb')
        header=fp.read(80)
        filetype=header[0:5]
        # 這裡必須要能夠分辨二位元字串與文字字串
        #print (type(filetype))
        #print (filetype)
        fp.close()
     
        # for Python 3
        if filetype==b'solid':
        # for Python 2
        #if filetype=='solid':
            print ("讀取文字檔案格式:"+str(filename))
            load_text_stl(filename)
        else:
            print ("讀取二位元檔案格式:"+str(filename,))
            load_binary_stl(filename)
     
    #load binary stl file check wikipedia for the binary layout of the file
    #we use the struct library to read in and convert binary data into a format we can use
    def load_binary_stl(filename):
        '''
        二位元 STL 檔案格式如下:
        檔案標頭共有 80 個字元(bytes), 內容通常省略, 但是內容不可使用 solid, 以免與文字檔案 STL 混淆
        UINT8[80] – Header
        UINT32 – Number of triangles (I:佔 4 bytes 的 unsigned integer)
     
        foreach triangle
        REAL32[3] – Normal vector (f:每一座標分量為一佔 4 bytes 的 float, 共佔 12 bytes)
        REAL32[3] – Vertex 1
        REAL32[3] – Vertex 2
        REAL32[3] – Vertex 3
        UINT16 – Attribute byte count (H:兩個 bytes 的 unsigned short, 表示 attribute byte count)
        end
     
        '''
        global list
     
        fp=open(filename,'rb')
        header=fp.read(80)
     
        triangle_number = struct.unpack('I',fp.read(4))[0]
        count=0
        while True:
            try:
                p=fp.read(12)
                if len(p)==12:
                    n=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
     
                p=fp.read(12)
                if len(p)==12:
                    p1=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
                    list.append(p1)
                p=fp.read(12)
                if len(p)==12:
                    p2=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
                    list.append(p2)
                p=fp.read(12)
                if len(p)==12:
                    p3=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
                    list.append(p3)
                # 使用 count 來計算三角形平面個數
                # triangle_number 為 STL 檔案中的三角形個數
                count += 1
                # 在前面 12*4 個 bytes 的 normal 與三個點資料後, 為
                # 一個 2 bytes 長的 unsigned short, 其值為零, 為 attribute
                fp.read(2)
                # 讀完所有三角平面後, 即跳出 while
                if count > triangle_number:
                    break
            except EOFError:
                break
        fp.close()
     
     
    def load_text_stl(filename):
        global list
        for dataline in open(filename,"r").readlines():
            if not dataline.strip(): # skip blank lines
                continue
            field = dataline.split() # split with no argument makes the right place!
            if field[0] == "vertex":
                list.append([float(x) for x in field[1:4]])
                #print (list)
                #break
                #for x in field[1:4]:
                    #print(x)
     
    load_stl(os.path.abspath('')+'/'+file)
     
     
    # Graphics
    model = faces(pos=list, color=(0.8,0.8,0.8),
                  material=materials.plastic) # creates triangles
    # 請注意, 這裡並沒有使用 STL 檔案中的平面 normal, 而是利用 VPython make_normals() 產生
    model.make_normals() # creates plane normals
    model.smooth(0.93) # smooths the edges
    # = AllepunkteSTL points (pos = list, size = 3, color = Color.Black) # generates points
.. @+node:amd_yen.20130414200359.2118: *3* C2 第九週




.. @+node:amd_yen.20130421114440.2139: *4* 期中考試題目
1. 給一個檔案, 要求查出此檔案的對應 md5 編碼 (第三週課程內容)

查驗程式:

.. code-block:: python

    import hashlib
     
    def md5Checksum(filePath):
        fh = open(filePath, 'rb')
        m = hashlib.md5()
        while True:
            data = fh.read(8192)
            if not data:
                break
            m.update(data)
        return m.hexdigest()
     
    def sha1Checksum(filePath):
        fh = open(filePath, 'rb')
        m = hashlib.sha1()
        while True:
            data = fh.read(8192)
            if not data:
                break
            m.update(data)
        return m.hexdigest()
     
    print (md5Checksum("yourfile.7z"))
    print (sha1Checksum("yourfile.7z"))
    
2. 給兩個檔案, 內容為利用亂數所產生的數字, 其中第一個檔案各行指定要擷取第二個檔案對應行數的數字次序 (例如, 第一個數字或第三個數字), 要求將這些數字進行累加, 給出結果.

產生亂數的程式:

.. code-block:: python

    #coding: utf-8
    import random
    起頭 = 1
    結束 = 5
    重複次數 = 250
    
    # 產生次序檔案
    檔案 = open("file1.txt", "w")
    for 索引 in range(重複次數):
        產生數字 = random.randint(起頭, 結束)
        檔案.write(str(產生數字)+"\n")
    檔案.close()
    
    # 產生累加數字檔案
    最小數 = 0
    最大數 = 50
    數字檔案 = open("file2.txt", "w")
    for 行索引 in range(重複次數):
        for 位置索引 in range(結束):
            產生數字 = random.randint(最小數, 最大數)
            數字檔案.write(str(產生數字)+"\t")
        數字檔案.write("\n")
    數字檔案.close()
    
根據 file1.txt 各行次序要求, 挑出 file2.txt 各行數字累加的程式:

.. code-block:: python

    #coding: utf-8
    
    # 取得各行的數字
    次序檔案 = open('file1.txt') # 開檔案的內建模式為 read
    數字檔案 = open('file2.txt') # 開檔案的內建模式為 read
    # 先將數字檔案中各行資料打包成為 list
    數字 = []
    while True:
        # readline() 讀取單行
        # readlines() 讀取多行, 並放入串列資料格式中
        各行資料 = 數字檔案.readline()
        # 以下兩行判斷式在確定檔案讀到最後一行後就會跳出 while 迴圈, 不會無限執行
        if len(各行資料) == 0: # 若該行的字數為 0, 表示已經到底
            break
        # 去掉各行最後面的跳行符號
        各行資料 = 各行資料.rstrip()
        # 依照資料的區隔符號 "\t" 將各行資料拆開, 並且存為 list, 到這裡各行資料為 list
        各行資料 = 各行資料.split("\t")
        # 可以將各行資料印出檢查
        #print(各行資料)
        # 將各行資料數列再疊成 數字 list
        數字.append(各行資料)
    # 可以將資料印出檢查, 數字大數列應該有 250 個 elements
    #print(數字)
    
    # 準備讀取次序檔案, 然後從數字數列抓出對應位置的數字來進行累加
    答案 = 0
    次序 = 0
    while True:
        # readline() 讀取單行
        # readlines() 讀取多行, 並放入串列資料格式中
        各行資料 = 次序檔案.readline()
        # 以下兩行判斷式在確定檔案讀到最後一行後就會跳出 while 迴圈, 不會無限執行
        if len(各行資料) == 0: # 若該行的字數為 0, 表示已經到底
            break
        # 去掉各行最後面的跳行符號
        各行資料 = 各行資料.rstrip()
        # 已經取得各行的資料(但是資料為字串), 這裡的"各行資料"就是擷取數字的序號
        #print(各行資料)
        # 開始累加
        # 要將各行資料當作索引使用, 必須由字串換成整數, 但是各行資料由 1 排序, 而 list 第一次序為 0 因此必須減 1
        # 而"數字"的內容也都是字串, 取出後必須轉為整數, 才可以進行運算
        print(數字[次序][int(各行資料)-1])
        答案 += int(數字[次序][int(各行資料)-1])
        print("目前答案為:", 答案)
        print("次序為:", 次序)
        # 對序號增量
        次序 += 1
    
    print(答案)
    
    次序檔案.close() # 關閉檔案
    數字檔案.close() # 關閉檔案

假如希望只累加單數行的對應資料, 求出累加數值總額, 或者累加雙數行的對應數據.

上述題目可能的變化:

    根據原先  file1.txt 的數字作為次序, 選擇 file2.txt 對應行的對應數字, 若該數字為偶數則選擇進入累加, 否則進行下一行查驗, 最後列出累加結果.
    
    根據原先  file1.txt 的數字作為次序, 選擇 file2.txt 對應行的對應數字, 若該數字大於 20 則選擇進入累加, 否則進行下一行查驗, 最後列出累加結果, 以及不列入累加的數字累加總和.
.. @+node:amd_yen.20130414200359.2119: *4* Python 3 程式教學的主題
.. @+node:amd_yen.20130414200359.2120: *5* Python 程式簡介
Python 是一種支援物件導向的高階解譯程式語言.

Python 程式可以在任何文字編輯器中編輯, 存檔時則需要給 .py 副檔名

Python 程式執行 - 直接在命令列中執行

python.exe prog.py

程式註解 - 單行註解, 使用 # 符號作為開頭, 多行註解則可使用三個單引號開頭, 三個單引號結束, 或者使用三個雙引號開頭, 三個雙引號結束, 介於引號中間則為多行註解.

# 註解說明
'''程式說明

這裡也是程式的註解說明, 通常為多行的說明.

'''
.. @+node:amd_yen.20130414200359.2121: *5* Python 程式變數與資料型別
任何程式變數, 函式與類別名稱的命名都必須避開該程式語法的關鍵保留字, 否則程式解譯時無法分辨哪些為語法關鍵字, 哪些為使用者自定的變數.

Python 3 keywords: 

False, class, finally, is, return
None, continue, for, lambda, try
True, def, from, nonlocal, while
and, del, global, not, with
as, elif, if, or, yield
assert, else, import, pass
break, except, in, raise

Python 資料型別

在靜態程式語言中, 變數有型別, 但是就動態程式語言而言, 變數並沒有型別, 但是變數的對應值則有型別.

Python 為一種動態且弱型別定義的程式語言, 相較於 Java 則為靜態且強型別定義的程式語言.

Booleans are either True or False.
Numbers can be integers (1 and 2), floats (1.1 and 1.2), fractions (1/2 and 2/3), or even complex numbers.
Strings are sequences of Unicode characters, e.g. an HTML document.
Bytes and byte arrays, e.g. a JPEG image file.
Lists are ordered sequences of values.
Tuples are ordered, immutable sequences of values.
Sets are unordered bags of values.
Dictionaries are unordered bags of key-value pairs. 

print(type(5)) 可以傳回整數資料型別.

Python 語言具有 int, float, string, byte 等資料型別, 以及 bytearray() 函式

int 整數表示

57 為一個十進位 (decimal) 整數.

0b111001 為一個二進位 (binary) 整數, 化為十進位則為 57.

0o71 為一個八進位 (octal) 整數, 化為十進位則為 57.

0x39 唯一個十六進位 (hexadecimal) 整數, 化為十進位則為 57.

不同進位數的轉換, 則採用 bin(), oct(), hex() 進行二進位, 八進位, 十六進位數的轉換.

.. code-block:: python

    print(type(5))
    print(0b111001)
    print(0o71)
    print(0x39)
    print(bin(57))
    print(oct(57))
    print(hex(57))
    
.. code-block:: python

    #coding: utf8
    # 設定一個二位元資料變數
    二位元變數  =  b"hello world"
    # 列出此變數
    print(二位元變數)
    for 索引 in 二位元變數:
        print(索引, end="  ")
        print()
        
    # 轉為二位元陣列
    二位元陣列  =  bytearray(二位元變數)
    二位元陣列.pop()
    print()
    print(二位元陣列, "\n")
    for 索引 in b"dogs":
        print(hex(索引), end=" ")
        print()
    資料  =  b"There are \x39\x20\x64\x6f\x67\x73"
    print(資料.upper())
    print(資料.replace(b"There are", b"We have"))
.. @+node:amd_yen.20130414200359.2122: *5* Python 程式的變數有效範圍
區域與廣域
.. @+node:amd_yen.20130414200359.2123: *5* Python 的敘述與表示式
Expression - 13. Computers. a combination of variables, constants, and functions linked by operation symbols and any required punctuation that describe a rule for calculating a value.

noun

1. the act of expressing or setting forth in words: the free expression of political opinions.

2. a particular word, phrase, or form of words: old-fashioned expressions.

3. the manner or form in which a thing is expressed in words; wording; phrasing: delicacy of expression.

4. the power of expressing in words: joy beyond expression.

5. indication of feeling, spirit, character, etc., as on the face, in the voice, or in artistic execution: the lyric expression embodied in his poetry.

6. a look or intonation expressing personal reaction, feeling, etc.: a shocked expression.

7. the quality or power of expressing an attitude, emotion, etc.: a face that lacks expression; to read with expression.

8. the act of expressing or representing, as by symbols.

9. Mathematics . a symbol or a combination of symbols representing a value, relation, or the like.

10. Linguistics . the stylistic characteristics of an utterance ( opposed to meaning ).

11. Linguistics . the system of verbal utterances specific to a language ( opposed to content ).

12. the act of expressing or pressing out.

13. Computers. a combination of variables, constants, and functions linked by operation symbols and any required punctuation that describe a rule for calculating a value.

14. Genetics.

    a. the action of a gene in the production of a protein or a phenotype.

    b. expressivity (  def 2 ) .
    

Statement - 8. Computers. an instruction or other elementary component in a high-level programming language.

noun

1. something stated.

2. a communication or declaration in speech or writing, setting forth facts, particulars, etc.

3. a single sentence or assertion: I agree with everything you said except for your last statement.

4. Commerce . an abstract of an account, as one rendered to show the balance due.

5. an appearance of a theme, subject, or motif within a musical composition.

6. the act or manner of stating something.

7. the communication of an idea, position, mood, or the like through something other than words: The furniture in the room makes a statement about the occupant's love of color. Walking out of the meeting will be a statement of our refusal to submit.

8. Computers. an instruction or other elementary component in a high-level programming language.
.. @+node:amd_yen.20130414200359.2124: *5* Python 運算符號與數學函式
運算符號:

算術: +, -, *, /, and % (模數)
比較: ==, !=, <, >, <=, >=
邏輯: and, or, not
階次: **
系統指令(需要導入 os 模組): os.system('ls -l')
    
常用數學函式(需要導入 math 模組)

絕對值: a = abs(-7.5)
三角函數(單位為徑度): x = asin(0.5)
Ceil (round up): print(ceil(4.2))
Cosine: a = cos(x) #x in rads
Degrees: a = degrees(asin(0.5)) #a=30
Exp: y = exp(x) #y=e^x
Floor (round down): a = floor(a+0.5)
Log: x = log(y); #Natural Log
       x = log(y,5); #Base-5 log
Log Base 10: x = log10(y)
Max: mx = max(1, 7, 3, 4) #7
       mx = max(arr) #max value in array
Min: mn = min(3, 0, -1, x) #min value
Powers: x = pow(y,3) #x=y^3
Radians: a = cos(radians(60)) #a=0.5
Random #: Random number functions require import random
       random.seed() #Set the seed based on the system time.
       x = random() #Random number in the range [0.0, 1.0)
       y = randint(a,b) #Random integer in the range [a, b]
Round: print round(3.793,1; #3.8 - rounded to 1 decimal
       a = round(3.793,0) #a=4.0
Sine: a = sin(1.57) #in rads
Square Root: x = sqrt(10) #3.16...
Tangent: print tan(3.14)# #in rads
.. @+node:amd_yen.20130414200359.2125: *5* Python 字串與數值轉換
資料型別轉換

    str()
    float()
    int()

字串函式應用:

字串 = "這是幾個字串"

利用 字串[0] 可以取出 "這"
字串[0:2] 可以取出 "這是" 等同 字串[:2]
字串[2:] 則可以取出 "幾個字串"
字串[-1] 則可取出最後一個字元 "串"
字串[-5:-3] 則取出 "是幾"

字串內容不可重新設定, 例如想要將 字串[0] 設為 "不" 則會發生錯誤

len(字串) 則可列出字串長度為 6

字串.find("幾") 會列出 "幾"所在位置的索引值, 也就是 2

利用  字串.join("內容"), 可以在原有字串中加上 "內容"

字串內容的置換, 然後必須指定為其他變數

字串 = "這是幾個字串, 還有字串"
print(字串.replace("字串","學生", 1))    # 只換 1 次
print(字串.replace("字串","學生", 2))    # 更換 2 次

.. code-block:: python

    #coding: utf8
    變數 = "一二三四五六!"
    print("變數[:2] 列出最前頭兩個元素:",變數[:2],"/",變數) # 從索引 0 開始, 列出串列中的元素, 到索引小於 2 為止 (不包括索引 2)
    print("變數[2:] 列出索引 2 到最後一個元素:",變數[2:],"/",變數) # 從索引 2 開始, 列出串列中到最終的元素
    print("變數[-2:] 列出倒數 2 個元素:",變數[-2:],"/",變數) # 從索引 -2 開始 (倒數第二個), 列出串列中到最終的元素 (也就是列出倒數兩個元素)
    print("變數[-7:] 列出倒數 7 個元素:",變數[-7:],"/",變數) # 從索引 -7 開始 (倒數第七個), 列出串列中到最終的元素 (也就是列出倒數七個元素)
    print("len(變數) 元素個數:",len(變數),"/",變數) # 變數 共有 6 個元素
    print("變數[0:2] 列出最前頭兩個元素:",變數[0:2],"/",變數)  # 列出索引 0, 1 等兩個元素
    print("變數[2:-1] 由索引 2 列到最後一元素之前一個(不含倒數第一個):",變數[2:-1],"/",變數) # 從索引 2 開始, 列出串列中到最終的元素的前一個 (不包括索引 -1)
    print("變數[2:-3] 由索引 2 列到最後一元素之前三個(不含倒數第三個):",變數[2:-3],"/",變數) # 從索引 2 開始, 列出串列中到最終的元素的前三個 (不包括索引 -3)
    print("變數[-1] 列出最後一個元素:",變數[-1],"/",變數) # 列出最後一個元素
    print("變數[-2] 列出倒數第二個元素:",變數[-2],"/",變數) # 列出倒數第二個元素
    print("變數[-0] 列出第一個元素:",變數[-0],"/",變數) # 列出第一個元素, 索引 -0 等同 0

Python 3 的字串物件型別共有三種:

    str 資料型別一律為 Unicode 格式資料(immutable)
    
    bytes 資料型別則用來表示二位元格式資料(immutable sequence of 8-bit integers)
    
    bytearray 資料型別則為以陣列排列的二位元格式資料(mutable)
    
字串資料轉換:

    str 轉為 bytes 的方法, str.encode() 或 bytes(S, encoding)
    
    bytes 轉為 str 的方法, bytes.decode() 或 str(B, encoding)
.. @+node:amd_yen.20130414200359.2127: *5* Python 的串列與 tuple
.. code-block:: python

    #coding: utf8
    串列 = ["一", 3, "五", 7, "九"]
    print(串列[0:2],"/",串列)
    串列[0:2] = [1, "三"]
    print(串列[0:2],"/",串列)
    # 串列元素附加, 串在最後面
    串列.append("十")
    print(串列[0:-2],"/",串列)
    print(len(串列))
    # 移除串列的最後一個元素
    del 串列[len(串列)-1]
    print(串列[0:-2],"/",串列)
    print(len(串列))
    串列[0] = "壹"
    print(串列[0:-2],"/",串列)
    print(len(串列))
    
.. code-block:: python

    #coding: utf8
    # 使用者將不同時段的課程以(列, 行, 課程名稱) 輸入串列資料中
    # 若課程資料需要排序, 則利用 sorted() 或 itemgetter() 處理
    # 若需要配合雙 for 迴圈將混亂排序之課程資料納入表單中, 則設法在串列中依序搜尋出與列行對應的課程, 即可順利列出課表
    from operator import itemgetter
    # 課程資料為串列資料, 其元件則為元組資料, 串列可排序, 元組則次序固定
    課程資料 =[(1,2,"1,2 課程"),(1,1,"1,1 課程"),(1,1,"1,3 課程")]
    print(sorted(課程資料, key=lambda 課程: 課程[0], reverse=True))   # 以列反向排序
    # 假如要在兩個資料元素接續排序, 則需要 operator 中的 itemgetter()
    print(sorted(課程資料, key=itemgetter(0,1)))   # 以列排序, 再以行排序
    print(sorted(課程資料, key=lambda 課程: 課程[1]))   # 以行排序
    print(sorted(課程資料, key=lambda 課程: 課程[2]))   # 以課程名稱排序
    for 課程子內容 in 課程資料:
        if 課程子內容[0] == 1 and 課程子內容[1] == 1:
            print(課程子內容)
          
  
將課表資料套到 html 表格列印:

.. code-block:: python

    #coding: utf8
    # 使用者將不同時段的課程以(列, 行, 課程名稱) 輸入串列資料中
    # 若課程資料需要排序, 則利用 sorted() 或 itemgetter() 處理
    # 若需要配合雙 for 迴圈將混亂排序之課程資料納入表單中, 則設法在串列中依序搜尋出與列行對應的課程, 即可順利列出課表
    from operator import itemgetter
    # 課程資料為串列資料, 其元件則為元組資料, 串列可排序, 元組則次序固定
    課程資料 =[(2,2,"1,2 課程"),(1,1,"1,1 課程"),(1,3,"1,3 課程")]
    print(sorted(課程資料, key=lambda 課程: 課程[0], reverse=True))   # 以列反向排序
    # 假如要在兩個資料元素接續排序, 則需要 operator 中的 itemgetter()
    print(sorted(課程資料, key=itemgetter(0,1)))   # 以列排序, 再以行排序
    print(sorted(課程資料, key=lambda 課程: 課程[1]))   # 以行排序
    print(sorted(課程資料, key=lambda 課程: 課程[2]))   # 以課程名稱排序
    for 課程子內容 in 課程資料:
        if 課程子內容[0] == 1 and 課程子內容[1] == 1:
            print(課程子內容)
    有資料 = False
    print("<table border=1>")
    for 列 in range(1,2):
        print("<tr>")
        for 行 in range(1,4):
            print("<td>")
            for 課程子內容 in 課程資料:
                if 課程子內容[0] == 列 and 課程子內容[1] == 行:
                    有資料 = True
                    print(課程子內容)
            if (有資料 == False):
                print("&nbsp;")
            print("</td>")
            有資料 = False
        print("</tr>")
    print("</table>")

Sets

Sets 與 Lists 類似但是以 { } 圈起, 與字典相同, 但是沒有 key, 也沒有特別的元件前後次序.

Sets 中不能有重複元件, 這點又與 Lists 不同, Lists 是允許有重複元件的

Sets 在特定查驗有無重複元件的操作上比 Lists 快.

.. code-block:: python

    #coding: utf8
    # set() 可將串列轉為集合
    一個集合 = set(['a','b','c','a'])
    print(一個集合)
    一個字串 = "abcdefghi"
    # 也可以利用 set() 將字串轉為 sets
    另外一個集合 = set(一個字串)
    # 可以利用 ::-1 將字串順序反轉過來
    print(一個字串[::-1])
    # :: 與 : 相同, 都會印出全部元素
    print(一個字串[::])
    print(一個字串[:])
    # 由第 1 列印到 3
    print(一個字串[1:4])
    # 由 0 列印到 4
    print(一個字串[:5])
    # 由 0 列印到最後一個的前一個
    print(一個字串[:-1])
    # 由 -4 列印到最後一個
    print(一個字串[-4:])
    # 列印第 2 個
    print(一個字串[2])
    # 而 list() 則可將集合轉為串列
    一個串列 = list(一個集合)
    print(一個串列)
    
.. code-block:: python

    #coding: utf8
    # 由字串取出單字, 以 set() 特性, 將重複單字去除
    字串 = '''
    Fundamentals discusses the basic tasks in using Creo Parametric, such as collaboration, managing data, working with the user interface, working with the model, and so on. 
    Use Fundamentals Help when you first start learning how to use Creo Parametric or when you want to enhance your knowledge. Fundamentals Help introduces you to the basic terminology, tasks, and procedures so you can build your models efficiently and share information, ideas, and processes in real time. You will learn how to use data management tools, customize the user interface, work with your models, and manage model composition.  
    '''
    # 將字串以空白隔開, 並用 set() 轉為單字集合
    # 利用 lower() 轉為小寫
    單字集合 = set(字串.lower().split())
    # 以 key=str.lower 使用 sorted() 將單字按照字母排序
    單字集合 = sorted(單字集合,key=str.lower)
    # 設法去除單字中的逗點與句點
    for 單字 in 單字集合:
        if "," in 單字:
            沒有逗點的單字 = 單字.replace(",","")
            print(沒有逗點的單字)
        elif "." in 單字:
            沒有句點的單字 = 單字.replace(".","")
            print(沒有句點的單字)
        else:
            # 印出原本就沒有逗點與句點的單字
            print(單字)
.. @+node:amd_yen.20130414200359.2128: *5* Python 條件式與重複廻圈
#coding: utf8
變數 = [1, 5, 16 , 8, 12]
比較值 = 10
for 索引值 in 變數: # 注意冒號與程式內縮
    if 索引值 < 比較值:
        print(索引值, "比", 比較值, "小")
    elif 索引值 > 比較值: # 注意冒號與程式內縮
        print(索引值, "比", 比較值, "大")
print("程式執行結束")
.. @+node:amd_yen.20130414200359.2129: *5* Python 定義函式與呼叫函式, 函式的內建變數
.. code-block:: python

    #coding: utf8
    def 斐波那契數列(輸入): # 定義 Fibonacci 級數函式
       變數1, 變數2 = 0, 1
        while 變數2 < 輸入:
            # 每一列印, 不以跳行結束, 而以 end=" " 所定義的空白區隔
            print(變數2, end=" ")
            變數1, 變數2 = 變數2, 變數1+變數2
        print()
    # 呼叫 斐波那契數列() 函數
    斐波那契數列(500)
    
.. code-block:: python

    import hashlib
    def md5Checksum(filePath):
        fh = open(filePath, 'rb')
        m = hashlib.md5()
        while True:
            data = fh.read(8192)
            if not data:
                break
            m.update(data)
        return m.hexdigest()
    print (md5Checksum("file.7z"))
.. @+node:amd_yen.20130414200359.2130: *5* Python 的類別與物件導向
Python 的物件宣告:

class subclass[(superclass)]:
    [attributes and methods]
    
Python 的案例建立:

object = class()

Python 的屬性與方法引用:

object.attribute
object.method()

Python 的特殊類別屬性:

__dict__  Dict variable of class name space

__doc__  Document reference string of class

__name__  Class name

__module__  Module name consisting of class

__bases__  The tuple including all the  superclasses

Python 類別的建構子: __init__()

Python 物件繼承:

class class1(object):

    def method1(self):
        return "method1"

class class2(class1):

    def method1(self):
        return "inheritance of class1"
        

Python 的多重繼承:

.. code-block:: python

    class A(object):
        def A(self):
            print("this is A")
    
    class B(object):
        def A(self):
            print("this is a")
        def B(self):
            print("this is B")
    
    class C(A, B):
        def C(self):
            print("this is C")
    
    C = C()
    D = B()
    
    C.A()
    C.B()
    C.C()
    D.A()
    
Python 物件中的 self, 就如同 C++ 中的 this, 在 Python 物件中, 類別中的函式 (方法) 必須透過 self 來擷取資料.

Python 程式語言雖然沒有 private 與 public, 但是仍可在變數或函式名稱之前加上 _ 或 __, 就可以讓此變數或函式無法直接 (或稱為被動) 從物件外部擷取, 使用這在物件外部擷取這些隱藏的變數或函式之唯一方法就是主動寫在程式某一方法中, 以主動的方式讓使用者從物件外部擷取.

例如:

class A(object):
    def __init__(self):
        self.Var1 = "var1"
        self.__Var2 = "var2"
    def getVar(self):
        print(self.Var1)
        print(self.__Var2)
        
B = A()

print(B.Var1) # 可以取得 "var1"
print(B.__Var2) # 無法取的 "var2"
B.getVar() # 可以列出 "var1" 與 "var2"


.. code-block:: python

    #coding: utf8
    # 建立一個自行車類別
    class 自行車(object):
    
        # 物件的內建成員變數
        車輪數量 = 2
        車燈型號 = "001"
        # __init__ 為物件建構子
        
        def __init__(自己, 名稱):
            自己.名稱 = 名稱
            
        def 列出名稱(自己):
            print("這輛車的名稱為", 自己.名稱)
            
        def 車燈選擇(自己, 車燈型號):
            自己.車燈型號 = 車燈型號
            
        def 列出車燈(自己):
            print(自己.名稱, "的車燈型號為:", 自己.車燈型號)
            
        def 列出車輪(自己):
            print(自己.名稱, "的車輪數量為:", 自己.車輪數量)
            
        def 加車輪(自己, 數量):
            自己.數量 = 數量
            自己.車輪數量 += 自己.數量
            
            
    # 三輪車繼承自行車
    class 三輪車(自行車):
        車輪數量 = 3
        
        
    # 四輪車繼承自行車
    class 四輪車(自行車):
        車輪數量 = 4
        
        
    有一輛車 = 自行車("小米")
    有一輛車.車燈選擇("1059")
    有一輛車.車輪數量 = 3
    有一輛車.加車輪(2)
    有一輛車.列出名稱()
    有一輛車.列出車燈()
    有一輛車.列出車輪()
    另一輛車 = 三輪車("三米")
    另一輛車.車燈選擇("007")
    另一輛車.列出名稱()
    另一輛車.列出車燈()
    另一輛車.列出車輪()

.. code-block:: python

    class Sample(object):
        x = 100      
        _a = 1
        __b = 11               
        def __init__(self, value):
            self.y = value      
            self._c = 'private'    
            self.__d = 'more private'
            z = 300
       
    '''In this example:
    
    x is class variable,
    _a is private class variable (by naming convention),
    __b is private class variable (mangled by interpreter),
    y is instance variable,
    _c is private instance variable (by naming convention),
    __d is private instance variable (mangled by interpreter),
    z is local variable within scope of __init__ method.
    In case of single underscore in names, it's strictly a convention. It is still possible to access these variables. In case of double underscore names, they are mangled. It's still possible to circumvent that.
    
    '''

.. code-block:: python

    #coding: utf8
    import math
    class Point(object):
        'Represents a point in two-dimensional geometric coordinates'
        def __init__(self, x=0, y=0):
            '''Initialize the position of a new point. The x and y  
               coordinates can be specified. If they are not, the point  
               defaults to the origin.'''
            self.move(x, y)
            
        def move(self, x, y):
            "Move the point to a new location in two-dimensional space."
            self.x = x
            self.y = y
        def reset(self):
            'Reset the point back to the geometric origin: 0, 0'
            self.move(0, 0)
        def calculate_distance(self, other_point):
            """Calculate the distance from this point to a second point  
               passed as a parameter.
            This function uses the Pythagorean Theorem to calculate  
            the distance between the two points. The distance is returned  
            as a float."""
            return math.sqrt(
                    (self.x - other_point.x)**2 +
                    (self.y - other_point.y)**2)
                    
    # how to use it:
    point1 = Point()
    point2 = Point()
    point1.reset()
    point2.move(5,0)
    print(point2.calculate_distance(point1))
    assert (point2.calculate_distance(point1) ==
            point1.calculate_distance(point2))
            
    point1.move(3,4)
    print(point1.calculate_distance(point2))
    print(point1.calculate_distance(point1))
    
.. code-block:: python

    # 檔案名稱為: fourbar.py
    # 資料來源 ; http://homepages.math.uic.edu/~jan/mcs275/
    # P-1 MCS 275 Wed 3 Feb 2010 : oo model for 4-bar mechanism
    # The main program to test the class prompts the user for n,
    # a number of angles, and then prints the coordinates for the
    # five joints that define the mechanism.
    from math import cos, sin, pi, sqrt
    class FourBar(object):
       """
       A 4-bar mechanism is determined by five parameters:
       (1) a : the length of the horizontal bar,
       (2) L : the length of the crank,
       (3) R : the length of the bar attached to the crank,
       (4) r : the length of the bar to the right,
       (5) b : the length of the bar to the coupler.
       The mechanism is driven by a crank, with angle t,
       and we use c = cos(t) and s = sin(t).  
       The value of t determines the state of the mechanism.
       """
       def __init__(self,a=100,L=50,R=125,r=125,b=125,t=pi/2):
          """
          Initializes a 4-bar mechanism with the 5 given lengths
          and sets the state of the 4-bar to the angle t.
          Default values are for the Chebyshev mechanism.
          """
          self.flat = a    # (0,a) is joint
          self.crank = L   # length of the crank
          self.top = R     # length of bar attached to crank
          self.right = r   # length of the right bar
          self.coupler = b # length of bar to the coupler
          self.angle = t   # state of the 4-bar
       def z1(self):
          """
          Returns the value of L^2+a^2-2*a*L*c.
          """
          a = self.flat
          L = self.crank
          c = cos(self.angle)
          v = L**2 + a**2 - 2.0*a*L*c
          return v
       def z2(self):
          """
          Returns the value of -L*R^2*s+L^3*s+L*s*r^2+a^2*L*s-2*L^2*s*c*a.
          """
          a = self.flat
          L = self.crank
          R = self.top
          r = self.right
          c = cos(self.angle)
          s = sin(self.angle)
          v = -L*R**2*s+L**3*s+L*s*r**2+a**2*L*s-2*L**2*s*c*a 
          return v
       def z3(self):
          """
          Returns the value of the square root of the discriminant:
             sqrt(-2*L^2*R^2*s^2*a^2-2*L^2*R^2*s^2*r^2+2*a^4*R^2-a^2*r^4
                 +L^6*s^2-L^2*R^4+2*L^4*R^2+2*L^4*r^2-L^2*r^4-7*L^4*a^2
                 -7*L^2*a^4-L^6-a^6+6*L^4*s^2*a^2+4*L^3*R^2*s^2*c*a
                 -4*L^5*s^2*c*a-2*L^2*s^2*r^2*a^2-2*L^4*R^2*s^2+L^2*s^2*r^4
                 +5*a^4*L^2*s^2+2*L^2*r^2*R^2+6*L^5*a*c+4*L^2*a^2*R^2
                 +4*L^2*r^2*a^2+20*L^3*c*a^3+2*a^2*r^2*R^2+4*L^3*s^2*r^2*c*a
                 -12*a^3*L^3*s^2*c+4*L^4*s^2*c^2*a^2-8*L^3*a*R^2*c-8*L^3*a*r^2*c
                 -8*a^3*R^2*L*c-8*a^3*r^2*L*c-a^2*R^4+2*a^4*r^2+6*a^5*L*c
                 -8*a^2*L^4*c^2-8*a^4*L^2*c^2+2*a*L*c*R^4+2*a*L*c*r^4
                 +8*a^2*L^2*c^2*R^2+8*a^2*L^2*c^2*r^2-2*L^4*s^2*r^2
                 +L^2*R^4*s^2-4*a*L*c*r^2*R^2)
          If the argument of the sqrt is negative, zero is returned.
          """
          a = self.flat
          L = self.crank
          c = cos(self.angle)
          s = sin(self.angle)
          R = self.top
          r = self.right
          v = -2.0*L**2*R**2*s**2*a**2-2*L**2*R**2*s**2*r**2+2*a**4*R**2 \
                -a**2*r**4+L**6*s**2-L**2*R**4+2*L**4*R**2+2*L**4*r**2-L**2*r**4 \
                -7*L**4*a**2-7*L**2*a**4-L**6-a**6+6*L**4*s**2*a**2 \
                +4*L**3*R**2*s**2*c*a-4*L**5*s**2*c*a-2*L**2*s**2*r**2*a**2 \
                -2*L**4*R**2*s**2+L**2*s**2*r**4 +5*a**4*L**2*s**2 \
                +2*L**2*r**2*R**2+6*L**5*a*c+4*L**2*a**2*R**2 \
                +4*L**2*r**2*a**2+20*L**3*c*a**3+2*a**2*r**2*R**2 \
                +4*L**3*s**2*r**2*c*a-12*a**3*L**3*s**2*c+4*L**4*s**2*c**2*a**2 \
                -8*L**3*a*R**2*c-8*L**3*a*r**2*c-8*a**3*R**2*L*c-8*a**3*r**2*L*c \
                -a**2*R**4+2*a**4*r**2+6*a**5*L*c-8*a**2*L**4*c**2 \
                -8*a**4*L**2*c**2+2*a*L*c*R**4+2*a*L*c*r**4 \
                +8*a**2*L**2*c**2*R**2+8*a**2*L**2*c**2*r**2-2*L**4*s**2*r**2 \
                +L**2*R**4*s**2-4*a*L*c*r**2*R**2
          if v < 0:
             return 0
          else:
             return sqrt(v)
       def y1p(self):
          """
          Returns the value of (1/2)*(z2+z3)/z1.
          """
          v = (self.z2()+self.z3())/(2*self.z1())
          return v
       def y1m(self):
          """
          Returns the value of (1/2)*(z2-z3)/z1.
          """
          v = (self.z2()-self.z3())/(2*self.z1())
          return v
       def x(self,y):
          """
          Returns the value of (1/2)*(-a^2+r^2+L^2-R^2-2*y*L*s)/(-a+L*c).
          """
          a = self.flat
          L = self.crank
          c = cos(self.angle)
          s = sin(self.angle)
          R = self.top
          r = self.right
          x_den = 2*(-a+L*c)
          x_num = -a**2+r**2+L**2-R**2-2*y*L*s
          v = x_num/x_den
          return v
       def ConnectorPoint(self):
          """
          Returns coordinates of connector point.
          For complex values (0,0) is returned.
          """
          try:
             y1pv = self.y1p(); 
             x1pv = self.x(y1pv)
             return (x1pv,y1pv)
          except:
             return (0,0)
       def CouplerPoint(self):
          """
          Returns the coordinates of the coupler point.
          """
          t = self.angle
          L = self.crank
          ax = L*cos(t)
          ay = L*sin(t)
          p = self.ConnectorPoint()
          dx = p[0] - ax
          dy = p[1] - ay
          b = self.coupler
          if dx == 0:
             x = ax
             y = p[1] + b
          else:
             v = sqrt(dx*dx + dy*dy)
             x = p[0] + b*dx/v
             y = p[1] + b*dy/v
          return (x,y)
       def Joints(self):
         """
         Returns the list of the coordinates of the 
         five joints that define the mechanism.
         """
         L = [(0,0),(self.flat,0)]
         t = self.angle
         L.append((self.crank*cos(t),self.crank*sin(t)))
         L.append(self.ConnectorPoint())
         L.append(self.CouplerPoint())
         return L
       def PrintJoints(self):
         """
         Prints the coordinates for the joints.
         """
         L = self.Joints()
         s = "%.2f " % self.angle
         for p in L:
            s = s + "(%5.1f,%5.1f)" % p
         print (s)
       def TrackPath(self):
          """
          Computes coordinates of points along a path
          tracked by the coupler point.
          """
          n = int(input('give number of samples = '))
          h = 2*pi/n
          for i in range(0,n):
             self.PrintJoints()
             self.angle = self.angle + h
             if self.angle > 2*pi:
                self.angle = self.angle - 2*pi
    def main():
       """
       Evaluates the formulas for the coupler of the 4-bar mechanism
       for values corresponding to the Chebyshev mechanism.
       """
       f = FourBar()
       f.TrackPath()
    if __name__ == "__main__": main()

.. code-block:: python

    # P-1 MCS 275 Wed 3 Feb 2010 : GUI model for 4-bar mechanism
    # 資料來源: http://homepages.math.uic.edu/~jan/mcs275/
    # The GUI consists of one canvas to draw a 4-bar mechanism.
    # A 4-bar mechanism consists of four rigid bars.  The first bar, the crank,
    # drives the mechanism.  The first two scales at the left regulate the 
    # length of the crank and the angle of the crank.
    # The horizontal scale below the canvas determine the position of the
    # rightmost bottom joint, at the start of the right bar.
    
    # the crank.  The bar attached to the crank connects to the right bar.
    # six scales and six corresponding labels.  Five of the six scales
    # determine the lenghts of the bars of the mechanims, 
    
    from tkinter import *
    from math import cos, sin, pi, sqrt
    from fourbar import *
    
    class FourBarGUI():
       """
       GUI to model a 4-bar mechanism.
       """ 
       def __init__(self,wdw,r,c):
          """
          Determines layout of the canvas,
          number of rows and colums is r and c.
          """
          wdw.title('a 4-bar mechanism')
          self.fbr = FourBar()
          self.rows = r; self.cols = c
          self.ox = c/3; self.oy = 3*r/4
          # print "A =" , (self.ox,self.oy)
          self.go = False
          # the canvas and start, stop, and clear buttons
          self.c = Canvas(wdw,width=self.cols,height=self.rows,bg='green')
          self.c.grid(row=1,column=2,columnspan=2)
          self.b0 = Button(wdw,text='start',command = self.start)
          self.b0.grid(row=3,column=2,sticky=W+E)
          self.b1 = Button(wdw,text='stop',command = self.stop)
          self.b1.grid(row=3,column=3,sticky=W+E)
          self.b2 = Button(wdw,text='clear',command = self.clear)
          self.b2.grid(row=3,column=4,columnspan=3,sticky=W+E)
          # the length of the crank
          self.crankLbl = Label(wdw,text='crank',justify=LEFT)
          self.crankLbl.grid(row=0,column=0)
          self.crankBar = IntVar()
          self.L = Scale(wdw,orient='vertical',from_=0,to=self.rows/2,\
             tickinterval=20,resolution=1,length=self.rows,\
             variable=self.crankBar,command=self.DrawMechanism)
          self.L.set(self.fbr.crank)
          self.L.grid(row=1,column=0)
          # the angle that drives the crank
          self.angleLbl = Label(wdw,text='angle',justify=LEFT)
          self.angleLbl.grid(row=0,column=1)
          self.angle = DoubleVar()
          self.t = Scale(wdw,orient='vertical',from_=0,to=6.30,\
             tickinterval=0.30,resolution=0.01,length=self.rows,\
             variable=self.angle,command=self.DrawMechanism)
          self.t.grid(row=1,column=1)
          self.angle.set(self.fbr.angle)
          # the bar at the right
          self.RightBarLbl = Label(wdw,text='right bar',justify=LEFT)
          self.RightBarLbl.grid(row=0,column=4)
          self.rightBar = IntVar()
          self.r = Scale(wdw,orient='vertical',from_=0,to=self.rows/2,\
             tickinterval=20,resolution=1,length=self.rows,\
             variable=self.rightBar,command=self.DrawMechanism)
          self.r.grid(row=1,column=4)
          self.rightBar.set(self.fbr.right)
          # the top bar attached to the crank
          self.topBarLbl = Label(wdw,text='top bar',justify=LEFT)
          self.topBarLbl.grid(row=0,column=5)
          self.RtopBar = IntVar()
          self.R = Scale(wdw,orient='vertical',from_=0,to=self.rows/2,\
             tickinterval=20,resolution=1,length=self.rows,\
             variable=self.RtopBar,command=self.DrawMechanism)
          self.R.grid(row=1,column=5)
          self.RtopBar.set(self.fbr.top)
          # the scale for the coupler bar
          self.CouplerBarLbl = Label(wdw,text='coupler',justify=LEFT)
          self.CouplerBarLbl.grid(row=0,column=6)
          self.couplerBar = IntVar()
          self.cpl = Scale(wdw,orient='vertical',from_=0,to=self.rows/2,\
             tickinterval=20,resolution=1,length=self.rows,\
             variable=self.couplerBar,command=self.DrawMechanism)
          self.cpl.grid(row=1,column=6)
          self.couplerBar.set(self.fbr.coupler)
          # the horizontal bottom bar
          self.flatLbl = Label(wdw,text='right joint',justify=RIGHT)
          self.flatLbl.grid(row=2,column=1)
          self.flat = IntVar()
          self.f = Scale(wdw,orient='horizontal',from_=0,to=self.rows/2,\
             tickinterval=50,resolution=1,length=self.cols,\
             variable=self.flat,command=self.DrawMechanism)
          self.f.grid(row=2,column=2,columnspan=2)
          self.flat.set(self.fbr.flat)
          # coordinates of the coupler point appear on top
          self.ex = Entry(wdw) # for x value
          self.ex.grid(row=0,column=2)
          self.ex.insert(INSERT,"x = ")
          self.ey = Entry(wdw) # for y value
          self.ey.grid(row=0,column=3)
          self.ey.insert(INSERT,"y = ")
          # check button for drawing of coupler curve
          self.curve = IntVar()
          self.cb = Checkbutton(wdw,text='coupler',\
            variable=self.curve,onvalue=1,offvalue=0)
          self.curve.set(1)
          self.cb.grid(row=3,column=0)
          # draw the mechanism on canvas
          self.DrawMechanism(0)
    
       def UpdateValues(self):
          """
          Takes all values of the scales and updates
          the data attributes of self.fbr.
          """
          self.fbr.flat = self.flat.get()
          self.fbr.crank = self.crankBar.get()
          self.fbr.top = self.RtopBar.get()
          self.fbr.right = self.rightBar.get()
          self.fbr.coupler = self.couplerBar.get()
          self.fbr.angle = self.angle.get()
          #self.fbr.PrintJoints()
    
       def DrawCouplerPoint(self,p):
          """
          Draws coupler point with coordinates in p
          if the curve checkbox is on.
          Note that the previous values for the coordinates
          of the coupler point are stored in the entry fields.
          """
          if self.curve.get() == 1:
             px = self.ox + p[0]; py = self.oy - p[1]
             eqx = self.ex.get(); Lx = eqx.split('='); 
             if Lx[1] == ' ':
                qx = 0.0
             else:
                qx = float(Lx[1])
             eqy = self.ey.get(); Ly = eqy.split('=');
             if Ly[1] == ' ':
                qy = 0.0
             else:
                qy = float(Ly[1])
             if (qx != 0.0) and (qy != 0.0):
                qx = self.ox + qx; qy = self.oy - qy
                self.c.create_line(qx,qy,px,py,width=1)
    
       def FillEntries(self,p):
          """
          Fills the entry fields with the coordinates
          of the coupler point in p.
          """
          sx = 'x = %f' % p[0]
          sy = 'y = %f' % p[1]
          self.ex.delete(0,END)
          self.ex.insert(INSERT,sx)
          self.ey.delete(0,END)
          self.ey.insert(INSERT,sy)
    
       def DrawLink(self,p,q,s):
          """
          Draws the link from point with coordinates in p
          to the point with coordinates in q, using s as tag.
          """
          self.c.delete(s)
          px = self.ox + p[0]; py = self.oy - p[1]
          qx = self.ox + q[0]; qy = self.oy - q[1]
          self.c.create_line(px,py,qx,qy,width=2,tags=s)
    
       def DrawMechanism(self,v):
          """
          Fills the canvas with the current model
          of the planar 4-bar mechanism.
          Because this command is called by the sliders,
          the argument v is needed but not used.
          """
          self.UpdateValues()
          L = self.fbr.Joints()
          for i in range(0,len(L)):
             p = L[i]
             px = self.ox + p[0]; py = self.oy - p[1]
             sj = 'joint%d' % i
             self.c.delete(sj)
             self.c.create_oval(px-6,py-6,px+6,py+6,width=1,\
                outline='black',fill='red',tags=sj)
          self.DrawLink(L[0],L[2],'link0')
          self.DrawLink(L[1],L[3],'link1')
          self.DrawLink(L[2],L[3],'link2')
          self.DrawLink(L[2],L[4],'link3')
          self.DrawCouplerPoint(L[4])
          self.FillEntries(L[4])
    
       def start(self):
          """
          Starts the animation, adding 0.01 to angle.
          """ 
          self.go = True
          while self.go:
             theta = self.angle.get()
             theta = theta + 0.01
             if theta > 6.28: theta = 0
             self.angle.set(theta)
             self.DrawMechanism(0)
             self.c.update()
    
       def stop(self):
          """
          Stops the animation.
          """
          self.go = False
    
       def clear(self):
          """
          Clears the canvas.
          """
          self.c.delete(ALL)
    
    def main():
       top = Tk()
       r = 400; c = 600
       # r = 600; c = 800
       show = FourBarGUI(top,r,c)
       top.mainloop()
    
    if __name__ == "__main__": main()
.. @+node:amd_yen.20130423211907.2159: *6* pickle 應用
以下範例利用 pickle 模組將物件進行序列化(serialize)資料轉換, 可以將類別物件轉換為 bytes 資料型別, 以利存入檔案或資料庫, 之後取出該 bytes 資料後, 在以反序列化轉回原始的資料內容.

.. code-block:: python

    #encoding: utf-8
    import pickle as pickle
    '''pickle dumps 與 loads 的應用'''
    
    class 類別(object):
        屬性 = '這是類別屬性'
        def 成員函式(self):
            print("來自成員函式的列印")
    
    # 將上述類別物件透過 pickle.dumps() 轉換
    pickle輸出 = pickle.dumps(類別)
    
    print("pickle輸出的型別:",type(pickle輸出))
    
    # 利用 pickle.loads() 取出物件
    原先壓入類別 = pickle.loads(pickle輸出)
    
    print("原先壓入類別的型別:",type(原先壓入類別))
    
    # 利用取出的類別建立案例
    一個物件 = 原先壓入類別()
    # 執行案例物件的方法
    一個物件.成員函式()
    
字串資料的序列化與反序列化:

.. code-block:: python

    #encoding: utf-8
    import pickle as pickle
    '''pickle dumps 與 loads 的應用'''
    
    字串 = "這是原始字串"
    
    # 將上述類別物件透過 pickle.dumps() 轉換
    pickle輸出 = pickle.dumps(字串)
    
    # 請注意, 序列化之後的"pickle輸出"資料型別為 bytes
    print("pickle輸出的型別:",type(pickle輸出))
    
    # 請注意, 只要將原先序列化的資料(格式為 bytes) 執行反序列化, 就可以取回原先序列化的字串內容, 且"原先的字串"資料型別為字串
    # 利用 pickle.loads() 取出原先序列化的內容
    原先的字串 = pickle.loads(pickle輸出)
    
    print("原先的字串之型別:",type(原先的字串))
    
    print(原先的字串)
.. @+node:amd_yen.20130414200359.2131: *5* Python 的檔案輸出入
.. code-block:: python

    #coding: utf8
    詩句 = '''\
    月落烏啼霜滿天, 江楓漁火對愁眠.
    姑蘇城外寒山寺, 夜半鐘聲到客船.
    '''
     
    檔案 = open('楓橋夜泊.txt', 'w') # 寫入資料
    檔案.write(詩句) # 將變數內容寫入檔案
    檔案.close() # 關閉檔案
     
    另一檔案 = open('楓橋夜泊.txt') # 開檔案的內建模式為 read
    while True:
        # readline() 讀取單行
        # readlines() 讀取多行, 並放入串列資料格式中
        行資料 = 另一檔案.readline()
        if len(行資料) == 0: # 若該行的字數為 0, 表示已經到底
            break
        # 比較下列, 跳行與不跳行列印的差別
        #print(行資料, end='') # 不跳行列印
        print(行資料)
    另一檔案.close() # 關閉檔案
    
readline() 與 realines() 的差別, 以及 write()必須將數值轉為字串

.. code-block:: python

    #coding: utf8
    檔案 = open("test.txt","w")
    for 索引 in range(5):
        數值 = 索引*2
        # write 的內容必須為字串
        檔案.write(str(索引)+" "+str(數值)+"\n")
    檔案.close()
    檔案 = open("test.txt","r")
    while True:
        # readline() 一次讀一行
        # readlines() 則讀進全部行數資料
        行資料 = 檔案.readline()
        if len(行資料) == 0:
            break
        for 索引 in range(len(行資料)):
            print("第",索引,"個資料",行資料[索引])
    檔案.close()
    
.. code-block:: python

    #coding: utf8
    檔案內容 = '''\
    k|p|T|E|  k|p|T|E| 
    c|p|a|E|  k|d|r|E| 
    k|p|T|E|  k|p|T|E| 
    c|p|a|E|  k|d|r|E| 
    '''
     
    檔案 = open('data.txt') # 開檔案的內建模式為 read
    寫檔案 =  open('newdata.txt', 'w') # 寫檔案用 handle
    while True:
        # readline() 讀取單行
        # readlines() 讀取多行, 並放入串列資料格式中
        行資料 = 檔案.readline()
        if len(行資料) == 0: # 若該行的字數為 0, 表示已經到底
            break
        # 比較下列, 跳行與不跳行列印的差別
        #print(行資料, end='') # 不跳行列印
        前半部, 後半部 = 行資料.split()
        新前半部 = 前半部.replace("|","")
        新後半部 = 後半部.replace("|", " ")
        print(新前半部, 新後半部)
        寫檔案.write(新前半部+"\t\t"+新後半部+"\n")
    檔案.close() # 關閉檔案
    寫檔案.close() # 關閉檔案
.. @+node:amd_yen.20130414200359.2132: *5* Python 的繪圖與影像處理功能
將 png 檔案全部轉為 gif

.. code-block:: python

    from PIL import Image
    import glob,os
    files = glob.glob("*.png") 
    for imageFile in files:
        filepath,filename = os.path.split(imageFile)
        filterame,exts = os.path.splitext(filename)
        print ("Processing: " + imageFile,filterame)
        im = Image.open(imageFile)
        im.save( filterame+'.gif','GIF')
        
tkinter 與 matplotlib 繪圖結合, 利用 tkinter button 改變直線斜率

.. code-block:: python

    import tkinter
    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
    from matplotlib.figure import Figure
    
    class App:
        def __init__(self, master):
            # Create a container
            frame = tkinter.Frame(master)
            # Create 2 buttons
            self.button_left = tkinter.Button(frame,text="< Decrease Slope",
                                            command=self.decrease)
            self.button_left.pack(side="left")
            self.button_right = tkinter.Button(frame,text="Increase Slope >",
                                            command=self.increase)
            self.button_right.pack(side="left")
    
            fig = Figure()
            ax = fig.add_subplot(111)
            self.line, = ax.plot(range(10))
    
            self.canvas = FigureCanvasTkAgg(fig,master=master)
            self.canvas.show()
            self.canvas.get_tk_widget().pack(side='top', fill='both', expand=1)
            frame.pack()
    
        def decrease(self):
            x, y = self.line.get_data()
            self.line.set_ydata(y - 0.2 * x)
            self.canvas.draw()
    
        def increase(self):
            x, y = self.line.get_data()
            self.line.set_ydata(y + 0.2 * x)
            self.canvas.draw()
    
    root = tkinter.Tk()
    app = App(root)
    root.mainloop()

tkinter 與 matplotlib 結合, 滑鼠互動

.. code-block:: python

    from tkinter import Tk, Button
    import numpy as np
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2TkAgg
    
    # plotting function: clear current, plot & redraw
    def plot(x, y):
        plt.clf()
        plt.plot(x,y)
        # just plt.draw() won't do it here, strangely
        plt.gcf().canvas.draw()
    
    # just to see the plot change
    plotShift = 0
    def main():
        global plotShift
    
        x = np.arange(0.0,3.0,0.01)
        y = np.sin(2*np.pi*x + plotShift)
        plot(x, y)
    
        plotShift += 1
    
    # GUI
    root = Tk()
    
    draw_button = Button(root, text="Plot!", command = main)
    draw_button.grid(row=0, column=0)
    
    # init figure
    fig = plt.figure()
    
    canvas = FigureCanvasTkAgg(fig, master=root)
    toolbar = NavigationToolbar2TkAgg(canvas, root)
    canvas.get_tk_widget().grid(row=0,column=1)
    toolbar.grid(row=1,column=1)
    
    root.mainloop()

使用 pylab 繪圖

.. code-block:: python

    from pylab import *
    
    r=arange(0,1,0.01)
    z=arange(0,1,0.01)
    sigma=1
    l=1
    kappa=1/(2*pi*sigma*l)
    u=-(kappa/r)*sin(pi*pow(r, 2))
    plot(r,u)
    ylabel('$ u_r $')
    xlabel('$ r $')
    title('$ u_r $')
    show()
    
contour 繪圖

.. code-block:: python

    from matplotlib import pyplot as plt
    import numpy as np
    
    r = np.linspace(0.1,2,200)
    t = np.linspace(np.pi/4,7*np.pi/4,200)
    r,t = np.meshgrid(r,t)
    x = r*np.cos(t)
    y = r*np.sin(t)
    z = (x+0.6)**2 + (y-1.)**2
    
    ax = plt.subplot(111)
    
    ax.pcolor(x,y,z[1:,1:])
    # ax.colorbar()
    
    con = ax.contour(x,y,z)
    ax.clabel(con)
    
    plt.show()
    
matplotlib 繪圖與方向鍵互動

.. code-block:: python

    from matplotlib import pyplot as plt
    import numpy as np
    
    class MovingPlot(object):
        """ MovingPlot plots a figure that flows across the screen.  Right and left 
    arrows move the figure one step
        """
        def __init__(self, r0= [-0.8, 1.0], v0 = [0.1, 0.]):
            # set up grid
            r = np.linspace(0.2,2,20)
            t = np.linspace(np.pi/4, 7*np.pi/4, 20)
            r,t = np.meshgrid(r,t)
            self.x = r*np.cos(t)
            self.y = r*np.sin(t)
    
            self.x0 = r0[0]
            self.y0 = r0[1]
            self.vx = v0[0]
            self.vy = v0[1]
    
            # create figure and axes for reuse
            self.fig = plt.figure()
            self.ax = self.fig.add_subplot(111)
    
            # draw the initial frame
            self.frame = 0
            self.draw(self.frame)
    
            # call self.update everytime a 'key_press_event' happens
            # bind this behavior to an object so it persists
            self.cid = self.fig.canvas.mpl_connect('key_press_event', self.update)
            plt.show()
    
        def update(self, event):
            """Changes the frame number based on event and draws a new frame if the 
            frame changed"""
            if event.key ==  'right':
                print('forward')
                self.frame += 1
            elif event.key == 'left':
                print('backward')
                self.frame -= 1
            else:
                return
            self.draw(self.frame)
    
        def draw(self, t):
            """Draws the frame occuring at time=t"""
            x = self.x - self.vx*t
            y = self.y - self.vy*t
            z = (x-self.x0)**2 + (y-self.y0)**2
            self.ax.pcolor(self.x, self.y, z)
            self.fig.canvas.draw()
    
    if __name__ == "__main__":
        mplot = MovingPlot()
.. @+node:amd_yen.20130416222738.2125: *6* tkinter 繪圖
http://www.python-course.eu/python_tkinter.php

.. code-block:: python

    from tkinter import *
    master = Tk()
    
    canvas_width = 80
    canvas_height = 40
    w = Canvas(master, 
               width=canvas_width,
               height=canvas_height)
    w.pack()
    
    y = int(canvas_height / 2)
    w.create_line(0, y, canvas_width, y, fill="#476042")
    
    mainloop()
.. @+node:amd_yen.20130421114440.2838: *5* Python 的單機視窗程式
.. @+node:amd_yen.20130421114440.2839: *6* PyQt 程式編寫
若程式可以採開放原始碼模式, 則可選擇 PyQt, 否則可以選擇類似的 PySide.

PyQt: http://www.riverbankcomputing.com/software/pyqt/download, 採 GPL 2 or 3 and commercial license(若非開源專案則必須付費)

PySide: http://qt-project.org/wiki/About-PySide, 採 LGPL 2.1

GPL 與 LGPL 授權比較: http://en.wikipedia.org/wiki/GNU_Lesser_General_Public_License
.. @+node:amd_yen.20130421114440.2840: *5* Python 與資料庫
Python 內建 SQLite 3 資料庫程式介面, 一般的機械設計程式可以考慮採用, 較大型的程式則可使用 MySQL 或 PostgreSQL.

MySQL: http://www.mysql.com/

PostgreSQL: http://www.postgresql.org/
.. @+node:amd_yen.20130421114440.2841: *6* Pybean
https://pypi.python.org/pypi/pybean

為了簡化 Python 程式與資料庫連線操作的複雜度, 一般電腦輔助機械設計程式可以透過 Pybean 與 SQLite 連線.

.. code-block:: python

    #encoding: utf-8
    from pybean import Store, SQLiteWriter
    # 將資料存入記憶體中, frozen=False 表示可以動態新增表格與欄位
    #library = Store(SQLiteWriter(":memory:", frozen=False))
    # 將資料存入 sqlite 資料庫檔案中, frozen=False 表示可以動態新增表格與欄位
    # 設定 frozen=False 表示可以 create tables and columns on the fly
    library = Store(SQLiteWriter("database.sqlite", frozen=False))
    # 動態建立 book 資料表
    book = library.new("book")
    # 印出與 book 資料表對應的唯一序號
    print (book.uuid.hex)
    # 動態建立 title 欄位
    book.title = "如何使用 Pybean 儲存資料"
    # 動態建立 author 欄位
    book.author = "Pybean 作者群"
    # 儲存資料表內容
    library.save(book)
    # 利用 find 方法搜尋資料表中的資料
    # 找出 book 資料表中 author 為 "Pybean 作者群" 的資料
    for book in library.find("book","author like ?",["Pybean 作者群"]):
            # 列印資料表中的 title 欄位
            print (book.title)
    # 搜尋資料的筆數
    資料筆數 = library.count("book")
    搜尋資料筆數 = library.count("book", "author like ?", ["Pybean 作者群"])
    # 1 代表　true:沒有特別加入其他篩選條件, 排序內定為 asc, 反向排為 desc
    搜尋資料筆數 = library.count("book", "1 order by author")
    # 以 find_one 找出所要的一筆資料
    一筆資料 = library.find_one("book","author=?",["Pybean 作者群"])
    # 針對所搜尋出的一筆資料進行修改
    一筆資料.author = "修改後的資料"
    # 將修改後的一筆資料存入資料表中
    library.save(一筆資料)
    # 假如要刪除所找出的一筆資料, 使用 delete
    #libry.delete(一筆資料)
    print(資料筆數)
    print(搜尋資料筆數)
    print(一筆資料.title,"_",一筆資料.author)
     
    # 列出目前的資料庫內容
    for book in library.find("book","1"):
            # 列印資料表中的 title 欄位
            print (book.title, book.author)
     
    # 刪除資料表中的所有資料
    #library.delete(book)
.. @+node:amd_yen.20130421114440.2842: *5* Python 網際程式
Python 內建 W3 伺服器

目前最為流行的 Python 網際方案為 django, 而較小型的網際框架目前 (2013.04) 已經能夠支援 Python 3 的則有 CherryPy 與 Bottle.

一般機械設計網際程式建議採用 CherryPy 或 Bottle, 中型以上的網站則可直接採用 django.
.. @+node:amd_yen.20130421114440.2843: *6* CherryPy
http://www.cherrypy.org/

.. code-block:: python

    import cherrypy,os
    class HelloWorld(object):
        def index(self):
            return "Hello World!"
        index.exposed = True
     
    os.system("V:/Chrome/chrome.exe http://localhost:8083")
    cherrypy.server.socket_port = 8083
    cherrypy.server.socket_host = '127.0.0.1'
    cherrypy.quickstart(HelloWorld())
    
.. code-block:: python

    #coding: utf-8
    # 最簡單的 CherryPy 程式
    # 導入 cherrypy 與 os 模組
    import cherrypy,os
    # 建立 HelloWorld 類別物件
    class HelloWorld(object):
        # 定義一個會內建呼叫的 index 方法
        def index(self):
            # 傳回字串
            return "Hello World!"
        # 可以從外部以 index 連結呼叫此方法
        index.exposed = True
     
    # 利用 os.system() 執行 chrome.exe, 直接以瀏覽器開啟 cherrypy 伺服器
    os.system("V:/Chrome/chrome.exe http://localhost:8083")
    # 設定 cherrypy 的連結埠號為 8083
    cherrypy.server.socket_port = 8083
    # 設定 cherrypy 的啟動 IP 為 127.0.0.1
    cherrypy.server.socket_host = '127.0.0.1'
    # 以 HelloWorld() 物件啟動 cherrypy
    cherrypy.quickstart(HelloWorld())
    
.. code-block:: python

    import cherrypy,os
    class HelloWorld(object):
        def index(self):
            return "Hello World!"
        index.exposed = True
     
        def mymethod(self):
            return "This is my method!"
        mymethod.exposed = True
     
    os.system("V:/Chrome/chrome.exe http://localhost:8083/mymethod")
    cherrypy.server.socket_port = 8083
    cherrypy.server.socket_host = '127.0.0.1'
    cherrypy.quickstart(HelloWorld())

將 mymethod.exposed = True 蓋去, 表示使用者無法直接利用瀏覽器呼叫, 而只能以 self.mymethod() 的方式, 由其他可以直接呼叫的方法中執行, 下列程式執行後, http://localhost:8083 與 http://localhost:8083/index 結果相同, 但是卻無法直接呼叫 mymethod().

.. code-block:: python

    import cherrypy,os
    class HelloWorld(object):
        def index(self):
            #return "Hello World!"
            return self.mymethod()
        index.exposed = True
     
        def mymethod(self):
            return "This is my method!"
        #mymethod.exposed = True
     
    os.system("V:/Chrome/chrome.exe http://localhost:8083")
    os.system("V:/Chrome/chrome.exe http://localhost:8083/index")
    os.system("V:/Chrome/chrome.exe http://localhost:8083/mymethod")
    cherrypy.server.socket_port = 8083
    cherrypy.server.socket_host = '127.0.0.1'
    cherrypy.quickstart(HelloWorld())

Python3 程式與 Javascript 程式交換變數, 使用者呼叫時, 由 URL 連結中輸入變數值, 然後交由 Python3 傳給 Javascript 程式.

.. code-block:: python

    import cherrypy,os
    class HelloWorld(object):
        def index(self,var1=None):
            outString = '''
            <script>
            '''
            outString += "document.write('"+var1+"');"
            outString += '''
            </script>
            '''
            return outString
        index.exposed = True
     
    os.system("V:/Chrome/chrome.exe http://localhost:8083?var1=123")
    os.system("V:/Chrome/chrome.exe http://localhost:8083?var1=Hello")
    cherrypy.server.socket_port = 8083
    cherrypy.server.socket_host = '127.0.0.1'
    cherrypy.quickstart(HelloWorld())

利用 cherrypy.request.method 來判定變數取值的方法, 這裡透過 GET 取得變數值, 另外以表單取變數值的方法稱為 POST.

.. code-block:: python

    import cherrypy,os
    class HelloWorld(object):
        def index(self,var1=None):
            outString = '''
            <script>
            '''
            outString += "document.write('"+var1+"');"
            outString += '''
            </script>
            '''
            outString += cherrypy.request.method
     
            return outString
        index.exposed = True
     
    os.system("V:/Chrome/chrome.exe http://localhost:8083?var1=123")
    cherrypy.server.socket_port = 8083
    cherrypy.server.socket_host = '127.0.0.1'
    cherrypy.quickstart(HelloWorld())

CherryPy session 用法:

.. code-block:: python

    import cherrypy,os
    class HelloWorld(object):
        # cherrypy 執行的設定檔案, 以 dictionay 資料格式設定
        _cp_config = {
        # 配合 utf-8 格式之表單內容
        # 若沒有 utf-8 encoding 設定,則表單不可輸入中文
        'tools.encode.encoding': 'utf-8',
        'tools.sessions.on' : True,
        'tools.sessions.storage_type' : 'file',
        'tools.sessions.locking' : 'explicit',
        'tools.sessions.storage_path' : 'v:/tmp',
        'tools.sessions.timeout' : 60
        }
     
        def index(self,var1=None):
            outString = '''
            <script>
            '''
            if var1 != None:
                outString += "document.write('"+var1+"');"
            else:
                outString += "document.write('no var1 value');"
            outString += '''
            </script>
            '''
            outString += cherrypy.request.method
            count = cherrypy.session.get('count', 0) + 1
            cherrypy.session['count'] = count
            outString += " count is now:"+str(count)
     
            return outString
        index.exposed = True
     
        def reset_session(self):
            # delete all session data
            #cherrypy.session.delete()
            # only delete 'count' session
            del cherrypy.session['count']
            return "count is deleted"
        reset_session.exposed = True
     
    os.system("V:/Chrome/chrome.exe http://localhost:8083?var1=123")
    cherrypy.server.socket_port = 8083
    cherrypy.server.socket_host = '127.0.0.1'
    cherrypy.quickstart(HelloWorld())

加上客製化錯誤訊息.

.. code-block:: python

    #coding: utf-8
    import cherrypy,os
     
    class HelloWorld(object):
        # cherrypy 執行的設定檔案, 以 dictionay 資料格式設定
        _cp_config = {
        # 配合 utf-8 格式之表單內容
        # 若沒有 utf-8 encoding 設定,則表單不可輸入中文
        'tools.encode.encoding': 'utf-8',
        'tools.sessions.on' : True,
        'tools.sessions.storage_type' : 'file',
        'tools.sessions.locking' : 'explicit',
        'tools.sessions.storage_path' : 'v:/tmp',
        'tools.sessions.timeout' : 60
        }
     
        def index(self,**var):
            outString = '''
            <script>
            '''
            try:
                if var['var1'] != None:
                    outString += "document.write('"+var['var1']+"');"
                else:
                    outString += "document.write('no var1 value');"
                outString += '''
                </script>
                '''
            except:
                outString += '''
                </script>
                '''
                pass
            outString += cherrypy.request.method
            count = cherrypy.session.get('count', 0) + 1
            cherrypy.session['count'] = count
            outString += " count is now:"+str(count)
     
            return outString
        index.exposed = True
     
        def reset_session(self):
            # delete all session data
            #cherrypy.session.delete()
            # only delete 'count' session
            del cherrypy.session['count']
            return "count is deleted"
        reset_session.exposed = True
     
        # 客製化的 error 402 函式
        def error_page_402(status, message, traceback, version):
            return "Error %s - 抱歉! 發生 402 錯誤!" % status
        cherrypy.config.update({'error_page.402': error_page_402})
     
        def error_page_404(status, message, traceback, version):
            return "Error %s - 抱歉! 發生 404 錯誤!" % status
        cherrypy.config.update({'error_page.404': error_page_404})
     
    os.system("V:/Chrome/chrome.exe http://localhost:8083?var1=123")
    cherrypy.server.socket_port = 8083
    cherrypy.server.socket_host = '127.0.0.1'
    cherrypy.quickstart(HelloWorld())
    
CherryPy 程式以 http 及 https 模式啟動

.. code-block:: python

    #coding: utf-8
    import cherrypy,os
     
    class HelloWorld(object):
        # cherrypy 執行的設定檔案, 以 dictionay 資料格式設定
        _cp_config = {
        # 配合 utf-8 格式之表單內容
        # 若沒有 utf-8 encoding 設定,則表單不可輸入中文
        'tools.encode.encoding': 'utf-8',
        'tools.sessions.on' : True,
        'tools.sessions.storage_type' : 'file',
        'tools.sessions.locking' : 'explicit',
        'tools.sessions.storage_path' : 'v:/tmp',
        'tools.sessions.timeout' : 60
        }
     
        def index(self,**var):
            outString = '''
            <script>
            '''
            try:
                if var['var1'] != None:
                    outString += "document.write('"+var['var1']+"');"
                else:
                    outString += "document.write('no var1 value');"
                outString += '''
                </script>
                '''
            except:
                outString += '''
                </script>
                '''
                pass
            outString += cherrypy.request.method
            count = cherrypy.session.get('count', 0) + 1
            cherrypy.session['count'] = count
            outString += " count is now:"+str(count)
     
            return outString
        index.exposed = True
     
        def reset_session(self):
            # delete all session data
            #cherrypy.session.delete()
            # only delete 'count' session
            del cherrypy.session['count']
            return "count is deleted"
        reset_session.exposed = True
     
        # 客製化的 error 402 函式
        def error_page_402(status, message, traceback, version):
            return "Error %s - 抱歉! 發生 402 錯誤!" % status
        cherrypy.config.update({'error_page.402': error_page_402})
     
        def error_page_404(status, message, traceback, version):
            return "Error %s - 抱歉! 發生 404 錯誤!" % status
        cherrypy.config.update({'error_page.404': error_page_404})
     
    os.system("V:/Chrome/chrome.exe http://localhost:8083?var1=123")
    os.system("V:/Chrome/chrome.exe https://localhost:8093?var1=123")
     
    cherrypy.config.update({'server.socket_port': 8083, 'server.socket_host': '127.0.0.1'})
     
    from cherrypy._cpserver import Server
    server = Server()
    server.socket_port = 8093
    server.socket_host = '127.0.0.1'
    server.ssl_certificate = 'v:/ssl_cert.pem'
    server.ssl_private_key = 'v:/ssl_cert.pem'
    server.subscribe()
    #cherrypy.server.socket_port = 8083
    #cherrypy.server.socket_host = '127.0.0.1'
    cherrypy.quickstart(HelloWorld())
    
僅使用 https 模式啟動上述 CherryPy 程式:

.. code-block:: python

    #coding: utf-8
    import cherrypy,os
     
    class HelloWorld(object):
        # cherrypy 執行的設定檔案, 以 dictionay 資料格式設定
        _cp_config = {
        # 配合 utf-8 格式之表單內容
        # 若沒有 utf-8 encoding 設定,則表單不可輸入中文
        'tools.encode.encoding': 'utf-8',
        'tools.sessions.on' : True,
        'tools.sessions.storage_type' : 'file',
        'tools.sessions.locking' : 'explicit',
        'tools.sessions.storage_path' : 'v:/tmp',
        'tools.sessions.timeout' : 60
        }
     
        def index(self,**var):
            outString = '''
            <script>
            '''
            try:
                if var['var1'] != None:
                    outString += "document.write('"+var['var1']+"');"
                else:
                    outString += "document.write('no var1 value');"
                outString += '''
                </script>
                '''
            except:
                outString += '''
                </script>
                '''
                pass
            outString += cherrypy.request.method
            count = cherrypy.session.get('count', 0) + 1
            cherrypy.session['count'] = count
            outString += " count is now:"+str(count)
     
            return outString
        index.exposed = True
     
        def reset_session(self):
            # delete all session data
            #cherrypy.session.delete()
            # only delete 'count' session
            del cherrypy.session['count']
            return "count is deleted"
        reset_session.exposed = True
     
        # 客製化的 error 402 函式
        def error_page_402(status, message, traceback, version):
            return "Error %s - 抱歉! 發生 402 錯誤!" % status
        cherrypy.config.update({'error_page.402': error_page_402})
     
        def error_page_404(status, message, traceback, version):
            return "Error %s - 抱歉! 發生 404 錯誤!" % status
        cherrypy.config.update({'error_page.404': error_page_404})
     
    os.system("V:/Chrome/chrome.exe https://localhost:8093?var1=123")
     
    cherrypy.config.update({'server.socket_port': 8093, 'server.socket_host': '127.0.0.1',
                            'server.ssl_certificate': 'v:/ssl_cert.pem',
                            'server.ssl_private_key': 'v:/ssl_cert.pem'})
     
    #cherrypy.server.socket_port = 8083
    #cherrypy.server.socket_host = '127.0.0.1'
    cherrypy.quickstart(HelloWorld())
    
另一種以 https 啟動 CherryPy 的方法:

.. code-block:: python

    #coding: utf-8
    import cherrypy,os
     
    class HelloWorld(object):
        # cherrypy 執行的設定檔案, 以 dictionay 資料格式設定
        _cp_config = {
        # 配合 utf-8 格式之表單內容
        # 若沒有 utf-8 encoding 設定,則表單不可輸入中文
        'tools.encode.encoding': 'utf-8',
        'tools.sessions.on' : True,
        'tools.sessions.storage_type' : 'file',
        'tools.sessions.locking' : 'explicit',
        'tools.sessions.storage_path' : 'v:/tmp',
        'tools.sessions.timeout' : 60
        }
     
        def index(self,**var):
            outString = '''
            <script>
            '''
            try:
                if var['var1'] != None:
                    outString += "document.write('"+var['var1']+"');"
                else:
                    outString += "document.write('no var1 value');"
                outString += '''
                </script>
                '''
            except:
                outString += '''
                </script>
                '''
                pass
            outString += cherrypy.request.method
            count = cherrypy.session.get('count', 0) + 1
            cherrypy.session['count'] = count
            outString += " count is now:"+str(count)
     
            return outString
        index.exposed = True
     
        def reset_session(self):
            # delete all session data
            #cherrypy.session.delete()
            # only delete 'count' session
            del cherrypy.session['count']
            return "count is deleted"
        reset_session.exposed = True
     
        # 客製化的 error 402 函式
        def error_page_402(status, message, traceback, version):
            return "Error %s - 抱歉! 發生 402 錯誤!" % status
        cherrypy.config.update({'error_page.402': error_page_402})
     
        def error_page_404(status, message, traceback, version):
            return "Error %s - 抱歉! 發生 404 錯誤!" % status
        cherrypy.config.update({'error_page.404': error_page_404})
     
    os.system("V:/Chrome/chrome.exe https://localhost:8093?var1=123")
     
    cherrypy.server.socket_port = 8093
    cherrypy.server.socket_host = '127.0.0.1'
    cherrypy.server.ssl_certificate = 'v:/ssl_cert.pem'
    cherrypy.server.ssl_private_key = 'v:/ssl_cert.pem'
    cherrypy.quickstart(HelloWorld())
    
CherryPy 虛擬主機設定方法:

.. code-block:: python

    #coding: utf-8
    import cherrypy,os
    '''
    CherryPy 的虛擬主機對應
     
    1. 修改 Windows C:\WINDOWS\system32\drivers\etc\hosts 檔案
    127.0.0.1 server1.my.domain
    127.0.0.1 server2.my.domain
     
    2. 以下設定將可透過
    https://server1.my.domain:8093
    https://server2.my.domain:8093 
    連結到同一 CherryPy 網際程式的不同對應物件方法
    '''
    class Root(object):
        def __init__(self):
            self.server1 = HelloWorld1()
            self.server2 = HelloWorld2()
     
    class HelloWorld1(object):
        # cherrypy 執行的設定檔案, 以 dictionay 資料格式設定
        _cp_config = {
        # 配合 utf-8 格式之表單內容
        # 若沒有 utf-8 encoding 設定,則表單不可輸入中文
        'tools.encode.encoding': 'utf-8',
        'tools.sessions.on' : True,
        'tools.sessions.storage_type' : 'file',
        'tools.sessions.locking' : 'explicit',
        'tools.sessions.storage_path' : 'v:/tmp',
        'tools.sessions.timeout' : 60
        }
     
        def index(self,**var):
            outString = '''這是 server1.my.domain
            <script>
            '''
            try:
                if var['var1'] != None:
                    outString += "document.write('"+var['var1']+"');"
                else:
                    outString += "document.write('no var1 value');"
                outString += '''
                </script>
                '''
            except:
                outString += '''
                </script>
                '''
                pass
            outString += cherrypy.request.method
            count = cherrypy.session.get('count', 0) + 1
            cherrypy.session['count'] = count
            outString += " count is now:"+str(count)
     
            return outString
        index.exposed = True
     
        def reset_session(self):
            # delete all session data
            #cherrypy.session.delete()
            # only delete 'count' session
            del cherrypy.session['count']
            return "count is deleted"
        reset_session.exposed = True
     
        # 客製化的 error 402 函式
        def error_page_402(status, message, traceback, version):
            return "Error %s - 抱歉! 發生 402 錯誤!" % status
        cherrypy.config.update({'error_page.402': error_page_402})
     
        def error_page_404(status, message, traceback, version):
            return "Error %s - 抱歉! 發生 404 錯誤!" % status
        cherrypy.config.update({'error_page.404': error_page_404})
     
    class HelloWorld2(object):
        # cherrypy 執行的設定檔案, 以 dictionay 資料格式設定
        _cp_config = {
        # 配合 utf-8 格式之表單內容
        # 若沒有 utf-8 encoding 設定,則表單不可輸入中文
        'tools.encode.encoding': 'utf-8',
        'tools.sessions.on' : True,
        'tools.sessions.storage_type' : 'file',
        'tools.sessions.locking' : 'explicit',
        'tools.sessions.storage_path' : 'v:/tmp',
        'tools.sessions.timeout' : 60
        }
     
        def index(self,**var):
            outString = '''這是 server2.my.domain
            <script>
            '''
            try:
                if var['var1'] != None:
                    outString += "document.write('"+var['var1']+"');"
                else:
                    outString += "document.write('no var1 value');"
                outString += '''
                </script>
                '''
            except:
                outString += '''
                </script>
                '''
                pass
            outString += cherrypy.request.method
            count = cherrypy.session.get('count', 0) + 1
            cherrypy.session['count'] = count
            outString += " count is now:"+str(count)
     
            return outString
        index.exposed = True
     
        def reset_session(self):
            # delete all session data
            #cherrypy.session.delete()
            # only delete 'count' session
            del cherrypy.session['count']
            return "count is deleted"
        reset_session.exposed = True
     
        # 客製化的 error 402 函式
        def error_page_402(status, message, traceback, version):
            return "Error %s - 抱歉! 發生 402 錯誤!" % status
        cherrypy.config.update({'error_page.402': error_page_402})
     
        def error_page_404(status, message, traceback, version):
            return "Error %s - 抱歉! 發生 404 錯誤!" % status
        cherrypy.config.update({'error_page.404': error_page_404})
     
    os.system("V:/Chrome/chrome.exe https://server1.my.domain:8093?var1=123")
    os.system("V:/Chrome/chrome.exe https://server2.my.domain:8093?var1=123")
     
    hostmap = {
        'server1.my.domain:8093': '/server1',
        'server2.my.domain:8093': '/server2',
    }
     
    config = {
        'request.dispatch': cherrypy.dispatch.VirtualHost(**hostmap)
    }
     
    cherrypy.server.socket_port = 8093
    cherrypy.server.socket_host = '127.0.0.1'
    cherrypy.server.ssl_certificate = 'v:/ssl_cert.pem'
    cherrypy.server.ssl_private_key = 'v:/ssl_cert.pem'
    #cherrypy.quickstart(HelloWorld())
    cherrypy.quickstart(Root(), '/', {'/': config})
    
.. @+node:amd_yen.20130421114440.2844: *6* Bottle
http://bottlepy.org/docs/dev/
.. @+node:amd_yen.20130421114440.2846: *6* django
https://www.djangoproject.com/
.. @+node:amd_yen.20130417210155.2884: *5* Python 與 C/C++
Python 程式語言由於屬於動態資料結構且為解譯模式, 因此就某些需要較長運算時間的分析程式, 就必須與 C/C++ 程式分工合作.

而這些分工合作的模式分為兩類, 一類就是利用 C/C++ 來編寫 .pyd 動態連結程式庫, 然後以 Python 程式呼叫 .pyd 程式庫中的函式執行運算.

而另一類則是利用 C/C++ 來編寫 .exe 程式, 但是其中安排讓 C/C++ 執行程式在運算時呼叫 Python 程式中的某些物件 (通常為運算所需的函式, 例如要最大化或最小化的函式格式).

第一類 Python 與 C/C++ 結合的模式: 將 C/C++ 程式寫為 .pyd 格式, 然後以 Python 程式執行呼叫.

C 程式:

.. code-block:: python

    #include <Python.h>
    // 宣告內部運算的 C 函式格式
    int sum2(int a, int b);
    
    // 定義內部運算的函式內容
    int sum2(int a, int b)
    {
        return a+b;
    }
    
    // sum 函式的 interface
    static PyObject* mod_sum(PyObject *self, PyObject *args)
    {
        int a;
        int b;
        int s;
        // ii 表示兩個輸入變數都是整數
        if (!PyArg_ParseTuple(args,"ii",&a,&b))
           return NULL;
        // 這裡的 sum2 則是內部的函式定義, 與外部呼叫模組或函式名稱沒有直接關係
        s = sum2(a,b);
        // i 表示 s 為整數
        return Py_BuildValue("i",s);
    }
    
    // 這裡的 sum 是外部模組的呼叫名稱, 而 mod_sum 則是內部的呼叫名稱 (即 interface function)
    // Mod_Methods 為函式 (方法) 結構定義
    static struct PyMethodDef Mod_Methods[] = {
        {"sum", mod_sum, METH_VARARGS, "Description.."},
        {NULL,NULL,0,NULL}
    };
    
    // 配合 Python 3 新增的模組結構定義
    static struct PyModuleDef ModMethods = {
       PyModuleDef_HEAD_INIT,
       "SumModule",   /* 模組名稱 */
       "SumModule_doc", /* 模組文件, may be NULL */
       -1,       /* size of per-interpreter state of the module,
                    or -1 if the module keeps state in global variables. */
       Mod_Methods  // 函式結構名稱
    };
    
    // 模組啟始, PyInit_ 後必須使用"名稱".pyd 中的模組名稱, 以便啟動
    // 換言之, 若編譯連結後的動態模組名稱為 sum.pyd, 則此地的起始函式名稱必須為 PyInit_sum
    PyMODINIT_FUNC 
    PyInit_sum(void)
    {
        // 建立模組的起始, 輸入為模組結構名稱之 address
        (void) PyModule_Create(&ModMethods);
    }

編譯上述程式流程:

.. code-block:: python

    import os
    d = c.scanAllDirectives(p)
    # 將目錄指到 latex
    mandir = d.get('path') + "/module"
    g.es(mandir)
    os.chdir(mandir)
    os.system("mkdir build")
    os.system("mkdir dist")
    target_name = "pymod"
    module_name = "sum"
    filename = target_name+".c"
    # compile
    os.system("V:/IDE/C/MinGW/bin/gcc.exe -c -g -IV:/IDE/Python33/include  -MMD -MP -MF build/"+target_name+".o.d -o build/"+target_name+".o "+filename)
    # link 因為 .c 程式中起始為 PyInit_sum, 因此
    os.system("V:/IDE/C/MinGW/bin/gcc.exe -shared -o dist/"+module_name+".pyd build/"+target_name+".o V:/IDE/Python33/libs/libpython33.a")
    g.es("done")
    
上述 C 程式將會以 gcc 編譯連結為 sum.pyd, 然後以下列 Python 程式呼叫:

.. code-block:: python

    import sum
    print(sum.sum(10,20))
    
第二種模式, 則取材自 http://docs.python.org/3/extending/embedding.html#pure-embedding

C 程式寫法:

.. code-block:: python

    #include <Python.h>
    
    int
    main(int argc, char *argv[])
    {
        PyObject *pName, *pModule, *pDict, *pFunc;
        PyObject *pArgs, *pValue;
        int i;
    
        if (argc < 3) {
            fprintf(stderr,"Usage: call pythonfile funcname [args]\n");
            return 1;
        }
    
        Py_Initialize();
        pName = PyUnicode_FromString(argv[1]);
        /* Error checking of pName left out */
    
        pModule = PyImport_Import(pName);
        Py_DECREF(pName);
    
        if (pModule != NULL) {
            pFunc = PyObject_GetAttrString(pModule, argv[2]);
            /* pFunc is a new reference */
    
            if (pFunc && PyCallable_Check(pFunc)) {
                pArgs = PyTuple_New(argc - 3);
                for (i = 0; i < argc - 3; ++i) {
                    pValue = PyLong_FromLong(atoi(argv[i + 3]));
                    if (!pValue) {
                        Py_DECREF(pArgs);
                        Py_DECREF(pModule);
                        fprintf(stderr, "Cannot convert argument\n");
                        return 1;
                    }
                    /* pValue reference stolen here: */
                    PyTuple_SetItem(pArgs, i, pValue);
                }
                pValue = PyObject_CallObject(pFunc, pArgs);
                Py_DECREF(pArgs);
                if (pValue != NULL) {
                    printf("Result of call: %ld\n", PyLong_AsLong(pValue));
                    Py_DECREF(pValue);
                }
                else {
                    Py_DECREF(pFunc);
                    Py_DECREF(pModule);
                    PyErr_Print();
                    fprintf(stderr,"Call failed\n");
                    return 1;
                }
            }
            else {
                if (PyErr_Occurred())
                    PyErr_Print();
                fprintf(stderr, "Cannot find function \"%s\"\n", argv[2]);
            }
            Py_XDECREF(pFunc);
            Py_DECREF(pModule);
        }
        else {
            PyErr_Print();
            fprintf(stderr, "Failed to load \"%s\"\n", argv[1]);
            return 1;
        }
        Py_Finalize();
        return 0;
    }
    
而負責編譯連結的程式流程則為:

.. code-block:: python

    import os
    d = c.scanAllDirectives(p)
    # 將目錄指到 pass2
    mandir = d.get('path') + "/pass2"
    g.es(mandir)
    os.chdir(mandir)
    os.system("mkdir build")
    os.system("mkdir dist")
    target_name = "pass2"
    module_name = "Test"
    filename = target_name+".c"
    # compile
    os.system("Y:/IDE/C/MinGW/bin/gcc.exe -c -g -IY:/IDE/Python33/include -MMD -MP -MF build/"+target_name+".o.d -o build/"+target_name+".o "+filename)
    # link 因為 .c 程式中起始為 PyInit_sum, 因此
    #os.system("Y:/IDE/C/MinGW/bin/gcc.exe -shared -o dist/"+module_name+".pyd build/"+target_name+".o Y:/IDE/Python33/libs/libpython33.a")
    os.system("Y:/IDE/C/MinGW/bin/gcc.exe -o dist/"+module_name+".exe build/"+target_name+".o Y:/IDE/Python33/libs/libpython33.a")
    g.es("done")

編譯連結後, 可執行的 C 程式為 Test.exe, 必須能夠擷取 Python 的程式執行環境, 若未修改 Python 執行的系統路徑, 則 Text.exe 必須放在 python.exe 的目錄中, 而下列 Test.py 則放入 site-packages 目錄中, 然後以"Test.exe Test multiply 3 2" 執行 Test.exe, 表示要導入 Test.py 程式中的 multiply 函式, 來進行 3 乘以 2 的運算.

.. code-block:: python

    def multiply(a,b):
        print("Will compute", a, "times", b)
        c = 0
        for i in range(0, a):
            c = c + b
        return c
        
討論: 上述 a times b 的實際運算是在 Python 程式端, 一般而言若 Python 僅負責提供 C/C++ 程式運算所需的方程式, 讓實際的運算由 C/C++ 程式完成, 應該是較佳的做法, 亦即仍然將 C/C++ 程式寫為 .pyd, 然後設法由 C/C++ 程式呼叫特定的 Python 函式, 以取得要處理的特定方程式格式, 然後再讓 C/C++ 程式來執行實際的數值運算.

範例:

https://code.google.com/p/pyminuit/

https://code.google.com/p/pymunk/ (以 svn checkout 程式碼, 完成安裝後可以結合 Pygame 進行 2D 動態模擬)

    C 版本: https://github.com/slembcke/Chipmunk-Physics
    
    Javascript 版本: https://github.com/josephg/Chipmunk-js
    
    Brython 版本: 還沒有開始編寫:-)

.. @+node:amd_yen.20130414200359.2126: *5* 
.. @+node:amd_yen.20130424175812.2164: *3* C2 第十週
Python 程式在機械設計工程領域的應用:

1. 一般的工程分析運算及動態模擬

    微積分與工程數學 - 使用 Scipy, Numpy 與 Sympy, 可以解決科學、數值分析與符號式運算等問題

2. 網際協同設計程式與系統編寫

3. 2D/3D 繪圖

    2D 繪圖 - PythonCAD

    3D 繪圖 - 在機械設計流程中的 3D 動態模擬應用領域, Python 程式語言具有舉足輕重的地位, 無論是造型設計套件 Rhinoceros, AutoDesk maya 或 Blender 都選擇 Python 作為 API 程式語言, 此外許多中大型線上遊戲也採用 Python 作為場景與動作邏輯的 Scripting 語言, 儘管這些應用多與工業設計、造形設計或動畫設計較有密切關係, 但是在許多專案執行過程中, 也需要許多具有深厚機械造形設計、力學、機構設計、自動控制等領域知識的機械設計工程師配合.
    
    電腦輔助機械設計繪圖 - FreeCAD

參考資料: 

rhino: http://python.rhino3d.com/

maya: http://download.autodesk.com/global/docs/maya2013/en_us/index.html

blender: http://www.blender.org/
.. @+node:amd_yen.20130423211907.2156: *4* 2D PythonCAD
PythonCAD 自 2010 年起正以 PyQT GUI 全面改寫(R38)中, 主要特色在於:

    自行打造一個小型的 2D 繪圖 kernel
    
    使用 SQLite 資料庫系統
    
    支援 Scriptable 程式介面

使用者可以透過此一完全以 Python 程式語言打造的 2D 來了解電腦輔助機械設計製圖的初步架構, 進而建立其他客製化的 2D 繪圖應用模組.

截至 2013.04, Python R38 仍然僅支援 Python 2, 若要將程式碼改為 Python 3 相容, 需要進行以下修改:
    
    IDE\Python33\Lib\site-packages\PyQt4\pyrcc4.exe 將 PythonCAD\Interface\cadwindow.qrc 轉為 cadwindow_rc.py 過程必須將 icons 目錄複製為 Interface\images, 然後重新建立 cadwindow_rc.py (pyrcc4 -py3 cadwindow.qrc -o cadwindow_rc.py), 才可建立 Python 3 相容的 cadwindow_rc.py
    
    必須利用 IDE\Python33\tools\scripts\2to3.py -w PythonCAD 將原先 Python 2 的程式碼轉為 Python 3 相容的程式碼
    
    實際執行 pythoncad_qt.py 時還必須修改 .toBool() 為 bool(), 以及其他類似的 Python 2 轉為 Python 3 的程式語法差異
    
    此外, C:\Documents and Settings\用戶名稱\PythonCAD 目錄中的 PythonCAD_Local.pdr SQLite 資料庫檔案為啟動 PythonCAD 時會自動導入的資料檔案, 由於 Python 2 與 Python 3 有不同版本的 pickle.dumps() 與 pickle.loads() 用法 (Python 2 支援 protocol 2, 而 Python 3 支援 protocol 3), 因此必須全面改寫繪圖檔案的 file io 格式, 才能夠全面將 Python 2 的 PythonCAD 轉為 Python 3.
    
以下為 .pdr 檔案格式中 pycadent, 也就是 PythonCAD entity 資料表格的欄位設計:

CREATE TABLE pycadent(
                    pycad_id INTEGER PRIMARY KEY,
                    pycad_entity_id INTEGER,
                    pycad_object_type TEXT,
                    pycad_object_definition TEXT,
                    pycad_object_style TEXT,
                    pycad_security_id INTEGER,
                    pycad_undo_id INTEGER,
                    pycad_entity_state TEXT,
                    pycad_index NUMERIC,
                    pycad_visible INTEGER,
                    pycad_undo_visible INTEGER,
                    pycad_locked INTEGER,
                    pycad_bbox_xmin REAL,
                    pycad_bbox_ymin REAL,
                    pycad_bbox_xmax REAL,
                    pycad_bbox_ymax REAL, pycad_property TEXT)
                    
為了將 PythonCAD 改為 Python 3 相容, 必須修改上述資料庫欄位設計, 將 pycad_object_definition TEXT, 改為 pycad_object_definition BLOB, 並且將 pycad_object_style TEXT, 改為 pycad_object_style BLOB, 主要原因在於 Python 3 的 pickle 版本為 3, 而 Python 2 pickle 版本則為 2, 所有在 Python 3 經過 pickle.dumps() 處理過的資料其格式為 bytes, 而且 pickle.loads() 中的輸入資料格式必須為 bytes.
.. @+node:amd_yen.20130423211907.2158: *5* pickle 與 unpickle
根據 http://docs.python.org/3/library/pickle.html#what-can-be-pickled-and-unpickled 的說明:

The following types can be pickled:

    None, True, and False
    integers, floating point numbers, complex numbers
    strings, bytes, bytearrays
    tuples, lists, sets, and dictionaries containing only picklable objects
    functions defined at the top level of a module
    built-in functions defined at the top level of a module
    classes that are defined at the top level of a module
    instances of such classes whose __dict__ or the result of calling __getstate__() is picklable (see section Pickling Class Instances for details).
.. @-all
.. @-leo
