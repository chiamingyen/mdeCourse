.. @+leo-ver=5-thin
.. @+node:amd_yen.20130308210411.2392: * @file cd.txt
.. @@language rest
.. @@tabwidth -4

.. @+at @rst-options
..  call_docutils=False
..  code_mode=False
..  generate_rst=True
..  http_server_support = False
..  show_organizer_nodes=True
..  show_headlines=True
..  show_leo_directives=True
..  stylesheet_path=..\doc
..  write_intermediate_file = True
..  verbose=True
.. @@c

.. @+all
.. @+node:amd_yen.20130308210411.2393: ** @rst document\cd.html
################################################
協同產品設計實習
################################################

.. index:: 協同產品設計實習

.. contents::
    :depth: 3
.. @+node:amd_yen.20130308210411.2394: *3* @rst-no-head Links
.. @+node:amd_yen.20130308214521.2420: *3* CD 第一週
以下資料從課程電子書所對應的 springlink 網站取出, 此內容為公開資料.

http://link.springer.com/chapter/10.1007/978-0-387-47321-5_1

Collaborative Design Approach in Product Design and Development

Abstract

This chapter presents an integrated framework for distributed and collaborative environment, which could assist organizations to achieve integrated design goals. The proposed system emphasizes the integration of the software tools and the resources involved in the design process to collaborate the geographically dispersed design teams and vendors. The advancement in information technology (IT) is the driving force for the development of this environment. Also, the early participation of vendors in the design process is considered critical in order to improve the product quality and reduce the development cycle time.

Advances in IT have enabled designers to more effectively communicate, collaborate, obtain, and exchange a wide range of design resources during development [1]. Many manufacturing companies are publishing their product information on the Internet. The network-oriented design environment is a new design paradigm for product development. An integrative framework that enables designers to rapidly construct performance models of complex problems can provide both design insight and a tool to evaluate, optimize, and select better alternatives. Furthermore, a design problem constructed from modeling components made available over Internet might facilitate the collaborative development of analytical system models in addition to the exchange of design information. A well-defined integrated model will predict the required product properties and evaluate alternative solutions in order to meet the defined design objectives and performances.

Key to the analysis of any problem is the identification of what functions are performed and the relationships between them [18]. A collaborative engineering development process includes a set of activities and functions arranged in a specific order with clearly defined inputs and outputs. Each activity in the process will take a set of inputs and transforms it into an output of some value. The process is considered efficient, when the output of the process satisfies the general customer and product requirements and meets management objectives and cost. New technologies and tools along with advancement in IT are helping these organizations in several ways [2, 17]. However, there is no established generic implementation model for wide range of industries.

Software vendors may provide “custom” software packages for individual firms. Different industries have different product development strategies, which demand a generic framework that will help them collaborate efficiently irrespective of their product, organizational structure, and/or geographical location. Two of the more important elements in this changing environment are increased product sophistication and variation. Minimizing the total costs and being quick to develop and market new products is the key for survival. Product development is a complex process requiring expertise from several fields. This will demand integrating the diverse functional areas of an organization on a common platform [22].

In this chapter, an integrative framework that would enable the design teams rapidly construct performance models of complex design problems is presented. This framework can provide both design insight and a tool to evaluate, optimize, and select better alternatives. Interaction between the elements at every level of design is a critical issue. The framework should not be limited only to internal function integration but it should also consider the external functions such as vendors. The vendors have precise and detailed knowledge for their items. This expertise should be incorporated in the main development system to ensure and optimize the product as a complete system. The templates for different processes and/or procedures should be designed systematically to assist in evaluating and optimizing the design alternatives through proper integration and analysis.

Reference

Albrecht R. and Nicol N. (2002), Microsoft Access Projects with Microsoft SQL server, Microsoft Press.

Agnar G., Harry B., and Mariano C. (2004), The implementation process of standardization, Journal of Manufacturing Technology Management, Vol. 15, No. 4, pp. 335–342.

Bhandari V. (2000), Design of Machine Elements, Tata-McGraw Hill Publications.

Borland N. (1997), DOME—MoDeL Language Reference, MIT, Cambridge, MA.

Charles N. (2002), New type of standard for accessibility, designed to foster the competition and innovation of designers, developers, and project and business management, Behavior and Information Technology, Vol. 21, No. 3, pp. 155–169. 

Chen Y. and Liang ?. (2000), Design and implementation of a collaborative engineering information system for allied concurrent engineering, International Journal of Computer Integrated Manufacturing, Vol. 13, pp. 11–30.

Cutkosky M., Toye G., Leifer L., Tenenbaum J., and Glicksman J. (1993), SHARE: A Methodology and Environment for Collaborative Product Development, Post-Proceedings of IEEE Infrastructure for Collaborative Enterprise.

Deutschman D., Michels J., and Wilson C. (1975), Machine Design: Theory and Practice, Macmillan Publishing Co. Inc.
Dudley D. (1962), Gear Handbook: The Design, Manufacture and Applications of Gears, First Edition, McGraw Hill Book Company.

Eddy M. and Anthony D. (1999), Web-centric systems: A new paradigm for collaborative engineering, Journal of Management in Engineering, Vol. 15, No. 1, pp. 39–45.

Emilda S., Alex L., and Shaik ?. (2004), COVES: An e-business case study in the engineering domain, Business Process Management Journal, Vol. 10, No. 1, pp. 115–125.

Gupta A. and Wilemon D. (1998), Managing Global Product Development Teams, IEEE— 1998, 0-7803-5082-0.

Khalid H. (2001), Towards Effective Collaborative Design, Proceedings of HCI International, Mahwah, NJ.

Koufteros X., Vonderembse ?., and Doll W. (2001), Concurrent engineering and its consequences, Journal of Operations Management, Vol. 19, No. 1, pp. 97–115.

Lawry ?. (1997), SDRC I-DEAS Master Series Guide, SDRC Press.

Lee R., Tasi J., Kao Y., Lin G., and Fan K. (2003), STEP-based product modeling system for remote collaborative reverse engineering, Robotics and Computer-Integrated Manufacturing, Vol. 19, No. 6, pp. 543–553.

Manuel C., Pedro C., Carlos V., and Nuria A. (2002), Product data quality and collaborative engineering, IEEE Computer Graphics and Applications, Vol. 22, No. 3, pp. 32–42.

Pahl G. and Beitz W. (1996), Engineering Design: A Systematic Approach, Springer Publications.

Pahng F., Senin N., and Wallace D. (1998), Web-Based Collaborative Design Modeling and Decision Support, ASME-DETC 1998.

Park H. and Cutkosky ?. (1999), Framework for modeling dependencies in collaborative engineering processes, Research in Engineering Design, Vol. 11, No. 1, pp. 84–102.

Pawar K. and Sharifi S. (1997), Physical or virtual team collocation: Does it matter?, International Journal on Production Economics, Vol. 52, No. 1, pp. 283–290.

Rouibah K. and Caskey K. (2003), A workflow system for the management of inter-company collaborative engineering process, Journal of Engineering Design, Vol. 14, No. 3, pp. 273–293.

Senin N., Borland N., and Wallave D. (1997), Distributed Modeling of Product Design Problems in a Collaborative Design Environment, CIRP International Design Seminar Proceedings: Multimedia Technologies for Collaborative Design and Manufacturing.

Sethi R. and Nicholoson C. (2001), Structural and contextual correlates of charged behavior in product development teams, Journal of Product Innovation Management, Vol. 18, No. 3, pp. 154–168.

Srinivasan V., Williams S., Love J., and David B. (1997), Integrated product design for marketability and manufacturability, Journal of Marketing Research, Vol. XXXIV, No. 1, pp. 154–163.

Ulrich K. and Eppinger S. (2000), Product Design and Development, Second Edition, McGraw-Hill Publication.

Wallace, D. and Senin N. (1997), A Framework for Mixed Parametric and Catalog Based Product Design, MIT, CADLab.

Wallace D., Senin N., and Sferro P. (2000), Integrated design in a service marketplace, Computer-Aided Design, Vol. 32, No. 2, pp. 97–107.

Wang B. (Ed.) (1998), Concurrent Design of Products, Manufacturing Processes and Systems (Automation and Production Systems: Methodologies and Applications), Vol. 3, Gordon and Breach Science Publishers.
.. @+node:amd_yen.20130308214521.2427: *3* CD 第二週
Simple Groupware 安裝

兩種安裝模式:

1. local 主機安裝

2. 雲端 OpenShift 主機安裝
.. @+node:amd_yen.20130308214521.2428: *4* 有關 reading 與考試
期中考前有兩篇從教科書中選出的章節, 希望學員能夠充分了解內容的涵義, 由於是英文的資料, 因此至少要能夠先將單字篩選出來, 進行字意了解, 然後再套進基本的字句解析, 接著則是"希望"學員經過多次閱讀後, 能夠了解段落涵義, 最後則是了解該章節所點出與協同產品開發有關的基本概念與內容.

至於教學內容的評量, 則是希望將章節內容以閱讀的方式轉為 mp3 語音, 考試時則以撥放相關內容的英文 mp3 檔案, 以單選題或複選題讓學員於線上考試作答, 以測試學員是否理解章節中的英文內容.

由於協同產品設計過程, 若需於線上直接透過英文與其他研發團隊進行溝通, 許多的對話與反應幾乎都必須是及時進行, 因此利用 mp3 的英文語音來訓練機械設計工程師的協同設計流程, 應該是合理的流程.

此外, 將教科書的英文章節轉為 mp3 語音檔案, 也是希望能夠將檔案放在手機中, 可以隨時以耳機練習英文聽力, 希望能降低學員對於閱聽英文對話的恐懼與障礙.

協同產品設計實習前半段教科書內容的 mp3 朗讀: http://cae.mde.tw?download=cdmp3.7z
.. @+node:amd_yen.20130308214521.2429: *4* Simple Groupware 管理
兩種身分: 管理者與一般使用者

管理者權限

如何讓使用者登入 sgw:

採用 IMAP 進行 user authentication, 設定讓 Gmail

進行登入認證

.. code-block:: none
    :linenos:

    1. main menu - > change settings
    
    Authentication Mode 選擇 IMAP
    
    Host: 填入 imap.gmail.com:993:ssl
    
    並且勾選 下方的
        
    Enable automatic user creation
    [htaccess, NTLM, LDAP, IMAP, SMTP]
    
    讓系統在使用者登入時能夠建立對應帳號.
    
    設定修改後, 按最下方的 Save 後, 登出管理帳號.
    
    以 gmail 帳號與密碼登入 Simple Groupware
    
    例如:
    
    myaccount@gmail.com 作為帳號
    然後輸入與此 gmail 帳號對應的密碼
    
    就可以利用 Gmail 的 IMAP server 認證, 讓使用者登入 sgw 並且由系統建立一個對應帳號, 並且出現下列訊息.
    
    Notification
    
    Item successfully created. (101)
    
    Processing modules/core/users.xml ...
    
    Folder structure created. ( / Personal folders / 2012c1@mde.tw / )
    
    Folder created. (../simple_store/home/2012c1@mde.tw/)
    
    Item successfully created. (101)
    
    2. 當所有的組員完全帳號建立後, 就可以修改設定, 讓 anonymous 帳號無法登入, 並且取消
    
    Enable automatic user creation
    [htaccess, NTLM, LDAP, IMAP, SMTP]
    
    自動建立對應帳號的設定, 如此就只有與專案執行相關的組員可以利用 IMAP 模式登入協同系統, 管理者 (admin) 則依然透過 Simple Groupware 資料庫中的帳號設定登入系統.
.. @+node:amd_yen.20130308214521.2430: *4* SpreadSheet 的應用
由以下的資料格式出發

.. code-block:: none
    :linenos:
    
    dbCells = [
    
      [0,0,"1",""], // A1
      
      [1,0,"4",""], // B1
      
      [3,0,"=graph(\"line\",\"測試\",A1:A3,B1:B3,\"x 軸\",\"y 軸\")",""], // D1
    
      [0,1,"2",""], // A2
      
      [1,1,"1",""], // B2
    
      [0,2,"3",""], // A3
      
      [1,2,"2",""], // B3
      
    ];

利用程式方法, 建立 0~2PI 的 Sin 與 Cos 繪圖
.. @+node:amd_yen.20130308214521.2431: *4* sgw 版本
先前附在 portableKMOL 的 sgw 無法搜尋, 且中文試算表無法使用, 因此在

https://github.com/chiamingyen/sgw745 

上傳新的版本.
.. @+node:amd_yen.20130309155804.1709: *3* CD 第三週
利用 Python 程式進行 Sin 與 Cos 函式的運算, 然後套進 Simple Groupware 的 Spreadsheet 模組資料格式, 以便能夠利用網際協同群組中的各組員檢視結果.

以下為 Sin 與 Cos 的繪圖程式:

.. 請注意: 以下採用程式檔案直接載入文書內容的模式取得對應的程式原始碼.

.. literalinclude:: ../cd/spreadsheet.py
    :language: python
   
將上列程式輸出結果, 以轉貼方式複製到 Simple Groupware Spreadsheet 中的 JS 資料介面, 然後按下 Load, 就可以顯示出 Sin() 與 Cos() 的繪圖結果.

另外一種將資料傳入 Simple Groupware 的方式為: 將運算結果以 URL 方式載入.

Simple Groupware graphviz 模組的中文化:

1. 取得 fireflysung.ttf, 放入 V:\extensions\sgw\ext\tools\bin_win32\graphviz\bin 目錄下

2. 利用下列 graphviz 就可以顯示出中文化的流程圖.

.. code-block:: none
    :linenos:
    
    digraph G {
    node[fontname="使用內定字型"]
    "在 Projecs 目錄下\n建立一個專案\n並指定專案參與人員"->
    "系統會採\n project_專案名稱 \n自動建立對應群組"->
     "使用者可以由\n Personal projects \n目錄中進入檢視相關資料"->
    "專案參與人員\n在其他目錄下\n所建立的相關資料\n
    只要綁上該專案名稱\n 相關資料就會統一彙整到\n 
    Personal projects 所屬資料分類下"
        }
    
.. code-block:: none
    :linenos:
    
    digraph G {
    node[fontsize = 14,fontname = "內定字型"]
    開始->執行->結束
    }

Simple Groupware 在 `mongoose web server`_ [#]_ 環境下執行, 使用上傳檔案模組 (files) 時會發生 ajax 的錯誤, 目前無法解決, 而 nginx 在 nginx.conf 設定中, 增加 client_max_body_size 的設定, 就可以正常上傳檔案 [#]_ .

.. [#] 目前單獨使用 mongoose web server 的情況只剩下 Python3 Tutor 的 cgi-bin 執行. 
.. [#] 這裡限制最大上傳檔案為 50MB.

.. code-block:: none
    :linenos:

    http {
        include       mime.types;
        default_type  application/octet-stream;
        client_max_body_size 50M;
        
只是在上傳"中文命名"檔案時, 會發生 php 的 basename() `截斷 sgw 中文檔名問題`_, 即使在 simple_store/config.php 中設定 setlocale(LC_ALL, 'en_US.UTF8'); 仍然無法解決, 目前已知在"中文命名檔"之前加上一個"-", 可以暫時解決問題.

.. _mongoose web server: https://github.com/valenok/mongoose

.. _截斷 sgw 中文檔名問題: http://sourceforge.net/p/simplgroup/support-requests/344/

以下則為 Simple Groupware 程式執行的流程, 若希望針對上述問題全面解決, 必須同時面對 php 與 javascript 交互處理的問題:

    1. 需要 simple_store/config.php 與 bin/core/functions.php 以及 smarty class 進行啟動.
    
    2. 以 bin/core/functions.php 中的 sys_build_output() 將套入 main.tpl 後的頁面, 以 echo 的方式送回瀏覽器, 其中的 $output 最前方放入處理程式所花的時間.
    
    3. simple_cache 目錄中則分門別類存放各種執行程式所需的暫存檔案, 若相關設定或程式更新, 則必須要先清除對應的 cache 檔案, 否則會依照舊的內容執行.
    
    4. 上傳檔案的檔名利用 bin/core/functions.php 中的 sys_build_filename() 進行命名, 某些中文長檔名就是因為此一函式的處理造成實際存檔的名稱過長, 超過 256 個字元而造成無法正確存檔, 因此若必須使用檔名很長的中文命名, 則要修改 sys_build_filename() 函式.

其次, 上傳檔案實際執行程式為 bin/upload.php, 必須考量 config.php 中 INVALID_EXTENSIONS 所不允許上傳的副檔名.

上傳檔案過程的 ajax 則由 bin/core/classes/ajax.php 中的 upload_file($filename) 函式負責處理, 並且透過 bin/ext/js/functions_edit.js 中的 handle_upload(item_name, max_file_size, max_file_count, files, input_id) 進行呼叫.

經過上述 Simple Groupware 執行流程的追蹤, 終於找到實際解決"中文命名檔案"上傳問題的方案.

以下為 ajax.php 檔案的修改:

.. code-block:: php
    :linenos:
    
    // setlocale() 必須放到 V:\extensions\sgw\bin\core\classes\ajax.php 第 242 與 243 行, 才會有作用
    static function upload_file($filename) {
      if (empty($filename) or empty($_SESSION["username"])) exit("Upload failed");
      if (strpos($filename,"://")) {
        $target = sgsml::getfile_url($filename);
      } else {
        $target = sgsml::getfile_upload($filename);
      }
      if ($target=="" or !file_exists($target)) {
        exit("Upload failed: Failed to write file to disk.");
      }
        // 為了避免中文命名檔案前面被斷頭的問題
        setlocale(LC_ALL, 'en_US.UTF8');
      return array("tmp_path"=>$target, "basename"=>modify::basename($target), "filesize"=>modify::filesize($target));
    }
    
截至目前使用 Simple Groupware 的檔案上傳與中文處理結論:

1. 目前的 mongoose web server (3.7版) 仍然無法正確處理 Simple Groupware 的 ajax 檔案傳送, 目前採 nginx 在 ssl 模式下運作.

2. 中文命名檔案的處理已經有理想方案, 亦即在 V:/extensions/sgw/bin/core/classes/ajax.php 中的 upload_file() 函式中, 加上 setlocale(LC_ALL, 'en_US.UTF8');

3. 為了讓 nginx 處理 Simple Groupware 的解譯, 在 nginx.conf 加入 ssl 的 server 設定, 完整的設定如下:

.. code-block:: none
    :linenos:

    worker_processes  1;

    events {
        worker_connections  1024;
    }
    
    
    http {
        include       mime.types;
        default_type  application/octet-stream;
        client_max_body_size 50M;
    
        #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
        #                  '$status $body_bytes_sent "$http_referer" '
        #                  '"$http_user_agent" "$http_x_forwarded_for"';
    
        #access_log  logs/access.log  main;
    
        sendfile        on;
        #tcp_nopush     on;
    
        #keepalive_timeout  0;
        keepalive_timeout  65;
    
        #gzip  on;
    
        server {
            listen       89;
            server_name  localhost;
    
            #charset koi8-r;
            charset utf-8;
    
            #access_log  logs/host.access.log  main;
    
            location / {
                root   V:/www/cmsimpleSpring2013;
                index  index.html index.htm index.php;
            }
    
            #error_page  404              /404.html;
    
            # redirect server error pages to the static page /50x.html
            #
            error_page   500 502 503 504  /50x.html;
            location = /50x.html {
                root   html;
            }
    
            # proxy the PHP scripts to Apache listening on 127.0.0.1:80
            #
            #location ~ \.php$ {
            #    proxy_pass   http://127.0.0.1;
            #}
    
            # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
            #
           # location ~ \.php$ {
              location ~ ^(.+\.php)(.*)$ {
                root   V:/www/cmsimpleSpring2013;
                fastcgi_split_path_info ^(.+\.php)(.*)$;
                fastcgi_pass   127.0.0.1:9000;
                fastcgi_index  index.php;
            #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
            #    orig    fastcgi_param SCRIPT_FILENAME ./html/$fastcgi_script_name;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                fastcgi_param PATH_INFO $fastcgi_script_name;
                include        fastcgi_params;
            }
        
        # for perl
        #location ~ \.pl$ {
        #gzip off;
        #include /etc/nginx/fastcgi_params;
        #fastcgi_pass  127.0.0.1:8999;
        #fastcgi_index index.pl;
        #fastcgi_param  SCRIPT_FILENAME  /srv/www/www.example.com/public_html$fastcgi_script_name;
        
            location /django{
                fastcgi_pass 127.0.0.1:8088;
                fastcgi_param SERVER_NAME $server_name;
                fastcgi_param SERVER_PORT $server_port;
                fastcgi_param SERVER_PROTOCOL $server_protocol;
                fastcgi_param PATH_INFO $fastcgi_script_name;
                fastcgi_param REQUEST_METHOD $request_method;
                fastcgi_param QUERY_STRING $query_string;
                fastcgi_param CONTENT_TYPE $content_type;
                fastcgi_param CONTENT_LENGTH $content_length;
                fastcgi_pass_header Authorization;
                fastcgi_intercept_errors off;
                }
            # deny access to .htaccess files, if Apache's document root
            # concurs with nginx's one
            #
            #location ~ /\.ht {
            #    deny  all;
            #}
    # hide index.php for Yii
    #location /yii/demos/blog {
    #try_files $uri /yii/demos/blog/index.php;
        }
    
    server {
        server_name localhost;
        listen 9443;
        ssl on;
        ssl_certificate V:/certificates/ssl_cert.pem;
        ssl_certificate_key V:/certificates/ssl_cert.pem;
    
            location / {
                root   V:/www/cmsimpleSpring2013;
                index  index.html index.htm index.php;
            }
    
              location ~ ^(.+\.php)(.*)$ {
                root   V:/www/cmsimpleSpring2013;
                fastcgi_split_path_info ^(.+\.php)(.*)$;
                fastcgi_pass   127.0.0.1:9000;
                fastcgi_index  index.php;
            #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
            #    orig    fastcgi_param SCRIPT_FILENAME ./html/$fastcgi_script_name;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                fastcgi_param PATH_INFO $fastcgi_script_name;
                include        fastcgi_params;
            }
        }
    
    server {
        server_name localhost;
        listen 6443;
        ssl on;
        ssl_certificate V:/certificates/ssl_cert.pem;
        ssl_certificate_key V:/certificates/ssl_cert.pem;
    
            location / {
                root   V:/extensions/sgw;
                index  index.html index.htm index.php;
            }
    
              location ~ ^(.+\.php)(.*)$ {
                root   V:/extensions/sgw;
                fastcgi_split_path_info ^(.+\.php)(.*)$;
                fastcgi_pass   127.0.0.1:9000;
                fastcgi_index  index.php;
            #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
            #    orig    fastcgi_param SCRIPT_FILENAME ./html/$fastcgi_script_name;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                fastcgi_param PATH_INFO $fastcgi_script_name;
                include        fastcgi_params;
            }
        }
    }


.. @+node:amd_yen.20130316100629.1526: *4* Simple Groupware 上傳檔名
bin/core/functions.php 中的 sys_build_filename() 對於較長的上傳中文檔案名稱 ,經過轉換後, 會超過系統允許的 255 字元限制, 在 Linux 可以依照論壇中的修改因應, 但是 Windows 環境則必須限制中文檔案名稱的上傳.

.. code-block: php

    function sys_build_filename($filename,$table="") {
    //Yen 修正中文命名檔案轉成 sha1 造成檔案名稱過長的問題, 
    // https://groups.google.com/forum/?fromgroups=#!topic/simple-groupware/yD9CyH7CL7E
    // 在 Windows 只能要求使用較短的中文檔案名稱
      $filename = NOW."-".sha1(uniqid(rand(), true).uniqid(rand(), true))."--".urlencode(basename($filename));
      if ($table=="" or strpos($table,"_nodb_")) {
        return array(SIMPLE_CACHE."/upload/",$filename);
      }
    // 存入資料庫的檔案名稱在某些情況有誤, 但是存檔則是正確的檔名轉換, 因此判斷是 Javascript  ajax 轉換時出問題
      return array(SIMPLE_STORE."/".$table."/",$filename);
    }
    
在 Windows 環境使用 Simple Groupware 的相關限制:

    1. 建立使用英文命名的檔案上傳, 若真要使用中文命名檔案上傳, 建議在檔名之前一律加上"-" (dash), 以避免某些中文檔名無法上傳的問題 (即使已經利用 setlocale(LC_ALL, 'en_US.UTF8'); 設定試圖修正 php basename() 處理中文命名檔案的問題, 但是仍有部分特定中文檔案名稱無法正確被解讀, 目前懷疑是檔名經過 php 轉 ajax 時所產生的問題).
    
    2. 若真要使用"-"+中文命名檔案, 也不可使用過長的檔案名稱, 否則會產生檔名過長無法上傳的錯誤.
.. @+node:amd_yen.20130310161901.1489: *3* CD 第四週
@language python

# 執行以下程式時, 將滑鼠定在此內文的標題上, 然後按下 Ctrl+b
'''
c is the commander of the outline containing the script.
g is Leo's leo.core.leoGlobals module.
p is the presently selected position, the same as c.p.
'''
# p 為 position, subtree 為子節點, 下列程式會逐一列出子節點的 body text
for p in p.subtree():
    g.es(p.b)

# g 為核心全域模組, 取其應用程式的圖形介面, 並且執行 AskOkDialog 對話視窗
g.app.gui.runAskOkDialog(c,"輸入密碼",message="請輸入網誌的密碼:",text='Ok')

def getInput (event=None):

   stateName = 'get-input'
   k = c.k
   state = k.getState(stateName)

   if state == 0:
       k.setLabelBlue('Input: ',protect=True)
       k.getArg(event,stateName,1,getInput)
   else:
       k.clearState()
       g.es_print('你輸入的值為: %s' % k.arg)

# 執行上述 getInput 函式
getInput()


.. @+node:amd_yen.20130317094520.1540: *4* 四次考試的 mp3 內容
協同產品設計實習前半段教科書內容的 mp3 朗讀: http://cae.mde.tw?download=cdmp3.7z
.. @+node:amd_yen.20130316100629.1537: *4* @url 最新 SGW 版本
https://github.com/simplegroupware/Simple-Groupware

從這裡可以發現 0.8 版正在打造中, 0.8 alpha 已經重新更動程式安裝架構與下拉式功能表:
    
    1. 大大簡化安裝流程, 過去從 src 加載語系資料, 並且複製到 bin 目錄的架構已經變更, bin 目錄不存在, 應該是採一組程式碼讀取語系資料的方式執行.
    
    2. 管理者功能一分為二, home 為原先的更改設定選單, 而 settings 獨立存在, 全部都在下拉式選單第一層, 操作更加簡潔.
    
    3. 目前為 alpha 版, spreadsheet 在英文語系設定下會將圖檔存在 V:\, 顯然仍有錯誤尚未修改.
    
    4. 許多 0.8x 預計新增的功能都還未加入, 應該是先整理基本架構, 之後才會一一納入.
    
    5. 移除 SSL 設定模式, 建議全時在 SSL 模式下運作.
    
    6. Webdav server 功能已經移除, 建議採用網際硬碟 (google drive 或 dropbox) 進行 offline 同步), 實際操作流程仍有待確認.
.. @+node:amd_yen.20130314194325.1511: *4* Simple Groupware 郵件設定
Simple Groupware 可在執行專案過程利用電子郵件通知參與專案的相關人員, 因此除各組員必須提供與帳號相關的電子郵箱外, 管理者必須設定寄信用的 email identity.

Organisation -> Mail identities

Id: admin
E-mail: 管理者電子郵箱
Name: admin
SMTP: username:password[:port[:tls]]@hostname

若 username 與 password 包含 @, 則必須以 %% 取代

若 username 與 password 包含 : 則以 == 取代

寄信郵件設定範例:
    
    1. 若希望使用 Gmail 電子郵箱: myemail@gmail.com 且密碼為 mypassword 來設定寄信, 則
    SMTP 欄位必須填入: myemail:mypassword:465:tls@smtp.gmail.com
    
    2. 若希望使用 Gmail 電子郵箱: myemail@gm.domain.name 且密碼為 mypassword 來設定寄信, 則
    SMTP 欄位必須填入: myemail%%gm.domain.name:mypassword:465:tls@smtp.gmail.com
.. @+node:amd_yen.20130316100629.1532: *5* 用戶管理
完成安裝後, 就可以利用總管理者的帳號登入系統. 內建的總管理者帳號為 admin, 密碼也是 admin, 但是若在安裝過程已經進行設定, 系統就不會採用內建的總管理者帳號密碼.

若使用者連結到完成安裝的系統, 將會以訪客 (anonymous) 的身份進入系統. 假如不希望使用者以無法辨識身份的訪客帳號進入系統, 則必須以管理者登入後在

main menu - administration - Change setup settings 中去除

Enable anonymous access 選項的勾選.

總管理者登入之後, 若希望建立零星的用戶帳號, 可以進入

Workspace - Organization - Users 項下建立帳號.

使用者帳號至少三個字元, 而密碼至少 5 個字元, 並且要提供至少一個電子郵箱, 其餘欄位則為選項, 接著就是在帳號頁面設定 SMTP 寄信主機.

總管理者若忘記密碼, 則必須刪除 simple_store 目錄下的 config.php, 然後重新進行設定, 總管理者在 simple_sys_users 資料表中並沒有存入任何資料, 而是存在 config.php 中.

新建帳號登入後, 系統會轉到該帳號下的個人目錄區, 也就是 Workspace - Personal folders, 假如要改變此一轉址, 則必須在 Users 目錄下的帳號頁面, 於 Home folder id 中加以設定.

假如要在個人帳號區內使用 IMAP 收信則必須要設定對應的 Mountpoints.

假如登入後希望改變帳號所對應的密碼則進入Main menu - Change settings 中修改, 而與帳號對應的 status 更改也是在 Change settings.

總管理者若刪除用戶, 則該用戶資料會被丟入 trash 區, 之後使用者可以利用剪下複製的方式回復該帳號, 也可以永久刪除該用戶資料.

使用剪貼的方式回復目錄資料後, 總管理者必須手動設定該目錄中的各項使用權限, 系統並不會自動回復原先的相關權限設定.

一個使用者帳號, 可以分別加入不同的群組 (group), 但是群組中則不可以加入群組, 以免產生後續管理上的問題.
.. @+node:amd_yen.20130316100629.1533: *5* 群組管理
有關 Simple Groupware 的群組:

    總管理者可以在 Workspace - Organization - Groups 中建立群組.
    
    刪除的群組會被視為暫停使用, 該群組目錄資料則會被移到 Workspace - System - Trash. 總管理者之後可以採用剪貼方式回復或永久刪除該群組. 已經被移到 Trash 區的群組, 總管理者仍然可以處理與該群組有關的設定, 因為總管理者具有進入 Trash 區查閱該群組資料.
    
    專案 (project) 與部門 (department) 的內建群組, 建立一個部門後, 以 department_群組名稱 進行命名的群組會自動建立, 並且將該部門的所有成員納入該自動建立的群組之中. 而列在個人部門中的檔案, 該部門人員可以進入讀寫該部門所建立的各種資料.
    
    而建立一個新專案後, 以 project_專案名稱 命名的群組也會自動建立, 任何屬於 internal participants 中的成員則會自動被歸屬到該群組中. 而且該群組成員可以讀寫在個人專案下屬於該新增專案目錄下所屬的相關資料.
    
    唯一必須特別注意的是, 管理者 (manager) 或外部參與專案或部門的成員, 並不會對於目錄或群組成員的擷取屬性有任何影響, 亦即, 設定一個新專案時, 列名為管理者 (manger) 也必須加入該專案的 internal participants, 而各個列名外部參與者的帳號則沒有該專案所屬的各項存取權.
    
    群組成員屬性只有在該帳號登入後, 才會刷新資料, 亦即才會反映出最新的屬性修改, 換句話說, 若某一位成員的屬性被修改後, 管理者或許必須刷新所對應的 session 資料, 並且強制該帳號重新登入系統, 該群組或專案的新設定才會生效, 否則系統仍然以舊 session 中的資料為准.
.. @+node:amd_yen.20130314194325.1512: *5* 建立專案
在 Simple Groupware 中建立專案步驟:

先建立專案目錄:

    1. 以管理者身分(admin) 登入系統後, 在樹狀結構下方點選 options.
    
    2. 樹狀結構上方會出現兩個區域, 亦即 Rename folder 與 New folder 等兩區.
    
    3. 在 New folder 區中填入專案目錄建立的相關資料.
    
    Name: 輸入專案目錄名稱
    
    Module: 選擇 Projects
    
    Icon: 選擇 Default 或其他圖示
    
    Description: 輸入專案目錄說明
    
    若要將此專案目錄放在列表最前頭, 則勾選 First in list.
    
    完成後, 按下 OK

接著在專案目錄下, 建立與產品設計相關的專案計畫.

    1. 點選上列所建立的專案目錄.
    
    2. 選擇右上方的 New, 準備建立新的專案計畫.
    
    3. Name: 輸入專案計畫名稱
    
    4. 選擇 Participants (參與專案計畫的成員)
    
    選擇 Manager: 選擇右方的分組成員, 然後按下 << 箭頭, 移入左方的表單中.
    
    選擇 Participants (internal): 由右方分組成員選擇要加入專案計畫的人員.
    
    5. 選擇 Scheduling (執行期限)
    
    選擇專案起始日期與預定結束日期.
    
    6. 按下 Save 就可完成專案計畫的建立.
    
完成上述專案計畫建立後, Simple Groupware 會自動建立對應的群組, 並且以 project_專案名稱 加以命名.

此後, 參與該專案計畫的成員登入系統後, 就可進入 Personal projects 目錄中檢視各種與該專案有關的資料.

參與專案的成員在其他目錄建立相關資料時, 只要綁上該專案名稱, 資料就會統一彙整到 Personal projects 所屬資料分類下, 其餘參與專案之組員也可以根據專案權限的設定, 在相關 Personal project 所屬的目錄下看到這些與專案執行相關的協同資料.

其他與建立專案相關的說明:
    
    1. 先確認所有組員可以登入系統, 其中可使用的認證方式, 　包括, mysql, ldap, imap 等.
    
    2. 在資料區建立一個 project folder, and create related project under that project folder.
    
    3. As the administrator create one project, participants can be added into the project, sgw will automatically create related group named project_project_title, and all participants will added into this group.
    
    4. All participants will grant read and write rights for the associated project, and related project template will appear under all participants' personal folder.
    
    5. The project folder which uses to group certain project definition need to let all project participants to read and write right can be directed to admin_project group as the default sgw system setting does.
.. @+node:amd_yen.20130314194325.1513: *5* 專案管理
所謂專案, 就是指在一定時間內, 一定資源支撐下, 由特定群組依照共同目標所擬定完成的任務規劃.

專案執行過程中, 群組中的成員各司其職, 必須在約定期限內依照特定的工作流程完成特定工作項目.

What is Project Management?

More specifically, what is a project? It's a temporary group activity designed to produce a unique product, service or result.

A project is temporary in that it has a defined beginning and end in time, and therefore defined scope and resources.

And a project is unique in that it is not a routine operation, but a specific set of operations designed to accomplish a singular goal. So a project team often includes people who don't usually work together – sometimes from different organizations and across multiple geographies.

The development of software for an improved business process, the construction of a building or bridge, the relief effort after a natural disaster, the expansion of sales into a new geographic market — all are projects.

And all must be expertly managed to deliver the on-time, on-budget results, learning and integration that organizations need.

Project management, then, is the application of knowledge, skills and techniques to execute projects effectively and efficiently. It's a strategic competency for organizations, enabling them to tie project results to business goals — and thus, better compete in their markets.

It has always been practiced informally, but began to emerge as a distinct profession in the mid-20th century. PMI's A Guide to the Project Management Body of Knowledge (PMBOK® Guide) identifies its recurring elements:

Project management processes fall into five groups:

    Initiating
    
    Planning
    
    Executing
    
    Monitoring and Controlling
    
    Closing

Project management knowledge draws on nine areas:

    Integration
    
    Scope	
    
    Time
    
    Cost
    
    Quality
    
    Procurement
    
    Human resources
    
    Communications
    
    Risk management
    
All management is concerned with these, of course. But project management brings a unique focus shaped by the goals, resources and schedule of each project. The value of that focus is proved by the rapid, worldwide growth of project management:

as a recognized and strategic organizational competence

as a subject for training and education

as a career path
.. @+node:amd_yen.20130316100629.1528: *5* @url 專案使用案例
https://groups.google.com/forum/?fromgroups=#!topic/simple-groupware/m5R3IzniasA

以下為論壇中,  某一用戶針對 Simple Groupware 在專案管理項目, 實際使用的基本流程描述.

我將專案模組用在建築事務所. 其中大約有 35 個專案, 使用電子郵件匣作為收信, 任務, 聯繫工作, 還有專案日誌等資料存檔用.

基本上由一位管理者指派任務與聯繫工作. 另一位管理人則待在辦公室中, 透過列表得知有哪些任務指派給他, 並且依照所指定的任務, 打電話給相關人等.

亦即, 一有新任務, 管理者就會建立相關專案內的任務指派, 並將該任務交付給相關負責人.

而在該任務負責人的個人資料匣中, 就會有收納交付給他的所有任務列表. 由於各任務會依照不同專案分類, 因此在他的任務資料匣中, 也會依照不同專案進行任務的分類.

此外, 各任務與聯繫工作也分別掛在不同類別中, 這些類別主要是用來建立特定列表. 其中一個類別為"待批准" (approval of bill), 因此在相關人等的個人資料匣中, 就會有一個列表集中在"待批准"的類別中, 等待其在指定日期之前必須完成審核批准.

而這些待批的文件, 會按照日期排序. 因此相關人等不僅從待批文件匣, 就可以得知期間內所必須完成的工作, 一點都無法偷懶.

目前在專案模組仍然缺乏的功能, 則是針對不同專案成員賦予其各自不同角色的權限, 目前的用法是將所有專案成員都視為相同角色.

爾後若能按照規劃加入企業資源規劃與計價模組, 將能讓專案管理模組的功能往上提升.
.. @+node:amd_yen.20130316100629.1529: *5* 目錄權限
每一個目錄的權限都可以單獨設定, 但是新增一個子目錄則會套用父目錄的相關權限.

目錄共有三個可以設定的權限:

讀取 (read), 寫入 (write) 與管理 (admin) 等三種, 只有對該目錄擁有管理 (admin) 權限的使用者, 可以對目錄 (及其子目錄) 設定所謂的 read, write 與 admin 權限, 總管理者則擁有所有系統內各目錄的管理權限.

有關目錄權限的設定, 必須使用 Folder 下拉式功能表中的 Rights: Show 或 Rights: Edit, 來檢視或更動相關目錄的權限設定.

假如要將目錄所設定的權限套用到所有該目錄項下的所有子目錄, 可以使用 Folder 下的 Apply rights to subfolders

除了管理目錄的權限外, 管理者也可以針對特定目錄設定容量管制 (quota), 設定的單位為 MB, 以其目錄與子目錄下所有上傳的檔案作為管理標的, 管理者可以在各目錄編輯欄位中的 Quota 項下加以設定.

且目錄的設定除了可以使用 read, write, admin 設定外, 也可以透過 View access (users) 與 View access (group) 進行更細化的擷取設定.

可採用的語法如下:

    View access (users)
    
    Syntax: |::|
    
    Examples:
        
    |freebusy:read:anonymous|
    
    |freebusy:read:anonymous|details:no_read:anonymous|
    
    Group access (groups)
    
    Syntax: |::|
    
    Examples:
        
    |freebusy:read:internals|
    
    |freebusy:read:internals|details:no_read:guests|
    
    Right: read, no_read, write, no_write 

採用上述 view 權限設定, 可以允許使用者建立或編輯內容, 但是無法 rename folder 或 建立子目錄.

View 權限不會影響其剪貼或刪除的操作.

允許 anonymous 擷取的目錄, 表示所有用戶 (若系統允許訪客進入, 則包括訪客) 都可以擷取該目錄, 但是若 anonymous 的擷取權被移除, 而且沒有其他用戶可擷取的設定, 則該目錄只有總管理者可以擷取.

總管理者登入後, 可以在 Main menu - administration 下的 Permissions  中檢視系統中所有目錄的相關權限設定.

目錄中各筆資料的權限設定:

    除了可以透過目錄權限管理外, 可以針對目錄中的各筆資料進行權限管理, 而每一筆內容所能設定的權限:
    
    Full 權限表示對各筆內容擁有讀寫權, 並且內建為 anonymous 可以讀寫.
    
    Owner write 權限表示只有擁有人可以寫入, 而擁有人就是建立該筆資料的用戶.
    
    Owner read 權限表示只有永有人可以讀取, 而擁有人就是建立該筆資料的用戶.
    
    cms 與 files 模組都是採用 Full 內定權限, forum 模組則採用 owner write, timesheet 與 expenses 模組則採用 owner read.
    
    通常各筆內容的權限設定, 在 new 資料表中的 permissions 頁面中加以設定.
.. @+node:amd_yen.20130316100629.1531: *5* Session 管理
Every user has a session where some settings are stored.

每一用戶登入後, 系統都會針對該連線進行所謂的"連線管理".

這些與用戶連線有關的管理資料可依目錄來存檔, 或依照目錄中的特定檢視權限來存檔, 或可檢視的模組為依據來存檔.

而每一連線以所謂的 session_id 來加以辨識, 並且與客戶的 IP 位址進行連結.

當使用者每次登入時系統就會重新建立此一 session_id

當使用者仍然在線時, 此一連線資料就會進行複製.

當登入的使用者超過 30 分鐘沒有任何動作, 原先的登入連線資料就會被視為無效, 使用者就必須重新登入.

有關連線內容所登錄的資料:

Global: username, client IP address, current folder, current theme, group memberships, read messages for POP3 / IMAP (max. 100), server id (used for creating unique dataset ids), allowed paths in the filesystem, form data tickets, cut-copy-paste data, folder states (open/closed), calendar day begin/end, tree type (folders, categories), tree page (if tree contains 100+ items), tree visible, data visible (calendar)

Per folder: calendar view (day, week, month, year, custom, all), calendar week start, calendar today / tomorrow, search string, selected page (datasets), current view, current folders (in categories mode)

Per folder+view: selected items, dataset filters

Per module+view: form finished (internal), dataset order/group by, dataset limit 

當使用者在畫面中按下 [All], 則連線資料就會刪除 folder+view, search string 與 folders 等相關資料.

若按下上方功能表中的 "Reset view" 則將移除與folder , module+view 有關的資料.
.. @+node:amd_yen.20130316100629.1535: *5* 取消 anonymous 登入
1. 以管理者身分登入系統

2. 進入上方的  Main Menu->Administration

3. 進入 Change Setup Settings

4. 取消下列兩設定的勾選

Enable anonymous access 	
Enable anonymous CMS

5. 設定存檔後, 必須透過帳號才可以登入系統.
.. @+node:amd_yen.20130316100629.1534: *5* 取消 too many wrong login 保護
在某些情況中, 若開放大批用戶使用測試中的 Simple Groupware, 很有可能在初學者的錯誤密碼輸入下, 導致在同一區段的管理者也無法登入系統, 可以將 bin/core/functions.php 中相關的保護程式暫時蓋掉, 就可以避開上述問題.

修改的程式碼如下:

.. code-block:: php

    $file = SIMPLE_CACHE."/ip/".str_replace(".","-",$ip);
    //if (file_exists($file."_3") and $trials = file_get_contents($file."_3") and strlen($trials)>3 and filemtime($file."_3") > time()-900) {
     // $_REQUEST["logout"] = true;
      //sys_alert("Too many wrong logins. Please wait 15 minutes.");
    IMPLE_CACHE."/ip/".str_replace(".","-",$ip);
    //if (file_exists($file."_3") and $trials = file_get_contents($file."_3") and strlen($trials)>3 and filemtime($file."_3") > time()-900) {
     // $_REQUEST["logout"] = true;
      //sys_alert("Too many wrong logins. Please wait 15 minutes.");
    if(0){
    //never happen
    }
.. @+node:amd_yen.20130316100629.1536: *5* @url 建立延伸模組
http://www.simple-groupware.de/cms/ExtensionManagerDeveloper
.. @+node:amd_yen.20130318140025.2834: *4* sgsML
@nocolor

使用 sgsML 建立網際程式的優勢:
    
    無需處理網際欄位與背後資料庫欄位的連結
    
網際程式欄位類別 (types)
    
    sgsML 會自動配額欄位屬性, 建立對應的資料庫欄位
    
    sgsML 會採整合的方式, 處理各模組的搜尋、分類與檢視
    
    Syntax: Types are declared with simple_type="type" where type is one of int, float, text, password, id, hidden, select, wikiarea, codearea, textarea, htmlarea, checkbox, files, date, time, datetime ... for a complete list, see src/modules/schema/!examples.html.
    
欄位查驗 (validator)

    Syntax: To collect these functions in a central place, all validators are stored in core/functions_user.php and have a ``"validate_"`` prefix, e.g. "validate_is_numeric". To define a validator in a sgsML file, write <validate function="is_numeric"/> between the <field>-tags to validate the field with the function validate_is_numeric.
    
過濾器 (filter)

    當使用者所要呈現在網頁上的資料, 與資料庫中所存放的內容不同時, 就必須使用過濾器.
    
    Syntax: To collect these functions in a central place, all filters are stored in core/functions_user.php and have a ``"modify_"`` prefix (because they modify data), e.g. "modify_dateformat". To define a filter in a sgsML file, write <filter views="all" function="truncate|20"/> between the <field>-tags to truncate the field to a maximum of 20 characters with the function modify_truncate. (The "views=all" parameter indicates that this filter is used with every view and will be discussed later) Other functions are included to help you to manage files, URLs, source code highlighting, etc.
    
store 與 restore (以 modify 為代號)

    當使用者要存在資料庫的格式, 與 Simple Groupware 存值的標準處理法不同時, 就必須使用 store 與 restore.
    
    Syntax: To collect these functions in a central place, all store and restore functions are kept in core/functions_user.php and have a ``"modify_"`` prefix (because they modify data), e.g. "modify_datetime_to_int" converts a date given as string to a timestamp using integer representation. To define a store or restore function in a sgsML file, write <store function="datetime_to_int"/> and <restore function="dateformat||d.m.Y"/> between the <field>-tags to work with a date-field using the functions modify_datetime_to_int and modify_dateformat.
As told before, Simple Groupware already knows a type called "date". Therefore you only need restore/store functions when defining your date-field with type "int". Using type "date" this is done automatically for you.

資料來源 (以 select 為代號)

    當欄位需要從特定資料選擇時, 採用資料來源.

    Syntax: To collect these functions in a central place, all data functions are kept in core/functions_user.php and have a ``"select_"`` prefix (because they select data), e.g. "select_dbselect" can be used to get data from the database.
To define a data construct in a sgsML file, write <data function="getmydata"/> between the <field>-tags to call the function "select_getmydata". Here dbselect is illustrated because it is the most common function to get data from the database.

############################################################

以下為 sgsML 的翻譯

sgsML Manual

sgsML 手冊  (simple groupware system markup language, 簡單群組系統標註語言)

This is a small tutorial intended to help you to understand and develop web applications with sgsML.

這是一個協助使用者了解如何以 sgsML 語言開發網際應用程式的簡短教學.


Introduction

簡介

For many years now I'm writing web applications. Using PHP, Java, HTML, CSS, Javascript in combination with MySQL, Oracle, MsSQL, etc. always struggling with the complexity of web applications.

多年來,我一直在寫網際應用程式. 使用 PHP, Java, HTML, CSS, Javascript 與各種資料庫管理系統 MySQL, Oracle, MsSQL 等結合的方式,讓網際應用程式的開發變得太過複雜.

Making changes in one point always influences many other parts of the program.
 
程式中的某一個點的改變會影響到程式的其他部分.

Often applications have several thousand lines of code (or even more).

經常這些應用程式有幾千行,甚至更多.

Searching bugs or making daily changes like adding fields takes a lot of time because you need to test the whole application again.
 
尋找錯誤或經常必須更動的修改,如增加表單欄位,常會耗費許多時間,因為整個程式必須要再測試一遍.

Since time is rare and deadline are sharp, it's time to optimize the common web application architecture.

因為時間經常不夠,而且交期緊迫. 該是對常用的網際程式架構進行最佳化了.

Looking at bigger programs with many web applications, people start writing frameworks for common functions, managing users and parts of the user interface.

看看現今的許多大型的網際程式,大家開始寫框架,以處理常用的函式,管理用戶與使用者介面.

But these frameworks are often very limited in functionality or require too much time to learn.

但是,這些框架要不是功能有限,就是要花許多時間學習.

Using a small framework, you still need to deal with the full complexity of coding PHP, Java, HTML, etc.

即使採用小型框架,還是得處理 PHP, Java, HTML 在程式方面所衍生的複雜度.

Moreover when working in bigger teams with a small framework, everyone writes its own specializations for his part.

尤有甚者,若開發者眾多而卻採用小框架,每個人都得決定各自的規範

This creates a unmanageable lack of consistency and increases costs for adding new functionality and fixing bugs.

將會因規範不一致而造成無法管理,在開發新功能或除錯時,成本就會跟著增加.

Therefore many companies create bigger frameworks to prevent programmers from getting too individual with their code.

因此,許多公司建立大型框架,以避免程式師建立太過個人化的程式碼.

With Java this is enforced using object-oriented programming (maybe also with PHP in the future).

對 Java 而言,(強制的要求)就是必須採用物件導向(未來 PHP 也是如此)

But I think that all these concepts are still too difficult to learn and understand in short time.

個人則認為這些概念仍然難以學習,也不容易在短時間內能夠理解.

That's why I created a new programming language only intended for web applications.

這也就是為甚麼我要建立一種新的程式語言,只用於網際程式.

You might ask: Hey, are you just creating another language with the intention to replace all the others?

或許有人會問: 哼, 難道要建立一種語言,以取代其他語言?

The answer is no. The other languages are still used, but in a different way.

答案當然是: 不. 其他語言仍會被使用,只不過以不同的方法加以應用.

This is important to understand, because today programming languages are so complex in usage and syntax, and this gets harder every year.

這點認知非常重要,因為今天的程式語言無論是用法或語法,都很複雜,並且越來越複雜.

So what is different when working with sgsML?

那採用 sgsML 到底有甚麼不同?

You no longer need to be the super nerd of a programming language.

你不再需要是程式語言的專家(才能寫網際應用程式)

Now you can create good web applications without having learned programming for ten years.

不用學 10 年程式, 就能寫很棒的網際程式.

To build web applications with sgsML it is enough if you can write functions with 5 to 10 lines of code.

利用 sgsML 編寫網際程式,只要用 5 到 10 行的函式程式就夠了.

You no longer write functions to store or load data in the database.

不再需要寫資料庫存取用的函式.

You no longer write GUI components just like HTML editors, spreadsheets or data selectors. How can this work?

不再需要寫使用者介面,處理超文件編輯器,試算表,或者資料選單. 這到底要如何辦到?

The name sgsML already indicates a relation to XML.

從 sgsML 名稱就可以知道與 XML 有關.

To produce applications written in sgsML, XML version 1.0 has been chosen as the syntax for sgsML files.

利用 sgsML 編寫應用程式,採用 XML 1.0 的格式語法.

This format is easier to read and interpret than many other formats (e.g. ini, CSV, CSS, etc.).

這種格式比其他格式(像 ini, CSV, CSS 等)更容易解讀.

As said before we are talking about sgsML files, meaning that one module (e.g. companies or appointments) is written into one file with the extension ".xml".

如前所述, sgsML 檔案就是一個模組(如,公司或約會模組),寫成一個以 xml 為副檔名的檔案.

Types

型別

With sgsML a field is generally defined by its type.

在 sgsML 中,欄位依照其型別加以定義.

This can be a text, a date, a number, etc. So when you define a field as text with sgsML, Simple Groupware creates this field in the database with the correct type and size in the corresponding table.

可以是文字,日期,數字等. 在 sgsML 中將欄位定義為文字型別, sgw 就會在資料庫中依照正確的型別與長度,在資料庫中建立此一欄位.


Furthermore Simple Groupware already knows how to display this field (You only have to decide between a horizontal or a vertical view) including sorting, searching, etc. Additionally, forms to create or edit this field inside a dataset are created automatically for you.

而且, sgw 也會正確顯示此一欄位(只要決定水平或垂直檢視), 也會正確完成諸如排序, 搜尋等工作.
至於表單, 欄位編輯等資料處理, 也會自動完成.


Syntax: Types are declared with simple_type="type" where type is one of int, float, text, password, id, hidden, select, wikiarea, codearea, textarea, htmlarea, checkbox, files, date, time, datetime ... for a complete list, see src/modules/schema/!examples.html.

語法: 型別採 simple_type="type" 的方式宣告,其中 type 為 int, float, text, password, id, hidden, select, wikiarea, codearea, textarea, htmlarea, checkbox, files, date, time, datetime 中的一種, 完整的型別表列,可以參考 src/modules/schema/!examples.html

Validators

驗證器

To be able to validate inputs made by a user you are able define functions that take care of this.

為能驗證使用者所提供的輸入, 就必須定義處理的函式.

E.g. you define a field as type text and also declare that it has to be validated with the two functions myvalidate1 and myvalidate2.

例如, 將欄位定義為文字型別, 必須要宣告, 以 myvalidate1 與 myvalidate2 等兩個函式加以驗證.

When a user wants to save a new dataset these two functions are called with the value of the field as a parameter and you only have to return a true/false-like answer to tell the program that the input is valid or not.

當使用者希望存一新的欄位資料時, 這兩個函式就會被呼叫, 並且以欄位變數加以驗證, 並且返回真/假的答覆, 來判定輸入是否有效.

You don't have to care about displaying the form again, mark the field with color red, display the error message to the user, etc.

您不再需要關注表單的顯示, 將必填欄位加上紅標, 或者傳回錯誤訊息給使用者.

This is all done for you automatically. These 2 functions are normally pretty easy and so small that even beginners can write them very quickly (they don't need any knowledge about the database, or HTML forms with heavy usage of Javascript).

這些事項都會自動完成. 而這兩個驗證用的函式, 通常非常簡單, 程式也很短, 就連初學者也都能夠快速上手 (不需要有資料庫或超文件表單的知識, 也不用寫一堆的 Javascript)

To make these functions smaller in size, you can define more than one functions for the validation of a field. This also helps you reuse functions (-> you automatically produce reusable code).

為了讓這些函示變得簡短, 可以設法針對一個欄位定義幾個函式. 不僅可以重用這些函式(->所建立的函式自然就能重用)

E.g. you want a field to be a positive number: Just write one function "is_numeric" that controls if the value is a number and a second one called "is_positive" that tests if it is positive.

例如, 若希望某一欄位為正數: 只要寫一個 "is_numeric" 的函式, 確保欄位為數字, 然後再編寫一個 "is_positive" 的函式來測試數值是否為正.


Of course, validating a German, English or ISO formatted date requires some work. Therefore a large number of functions for validating dates, strings and numbers is already shipped with Simple Groupware by default.

當然, 若要辨識德文, 英文或 ISO 格式的日期, 需要一些功夫. 因此這些用來辨識日期, 字串與數字的大型函式, 已經內建在 Simple Groupware 系統中.

Syntax: To collect these functions in a central place, all validators are stored in core/functions_user.php and have a ``"validate_"`` prefix, e.g. "validate_is_numeric". To define a validator in a sgsML file, write <validate function="is_numeric"/> between the <field>-tags to validate the field with the function validate_is_numeric.

語法: 為了將這些函式集中在一起, 所有的驗證函式都放在 core/functions_user.php 中, 並且以 ``"validate_"`` 作為開頭. 例如, "validate_is_numeric". 而在 sgsML 中定義驗證器, 則在 <field>-標註間寫入 <validate function="is_numeric" />, 就可以用來驗證該欄位所填入的內容, 是否為數字.

Filters

過濾器


Reading carefully you have read that Simple Groupware automatically displays your fields. But oftentimes you want to display fields differently from the value stored in the database. This is no conflict since you can define filters that change the value of a field before being displayed.

前面已經說過, Simple Groupware 會自動顯示欄位內容. 但有時希望顯示的內容, 可能與存在資料庫中的資料不同. 這時就可以使用過濾器的定義, 來改變欄位內容, 以便用來顯示.


This is elementary when working with dates. E.g. your database is configured for English dates, but you want to display them in German. Or you want to crop long texts to only show the first 20 words. Similar to validators you assign a function to the field that performs the filtering operation. This function takes the value of the field as input and returns the filtered value back to the program.

這在日期的使用上非常普遍. 例如, 資料庫中的日期設為英文格式, 而希望轉為德式習慣顯示. 或者將較長的內文, 只顯示前 20 個字等. 與驗證器類似, 可以指定一個過濾函式來處理資料過濾的操作. 此一函式以欄位值作為輸入, 而將過濾器處理過的資料傳回程式.

This is also very easy for beginners who don't need to care where the field is displayed or where the value comes from. As said Filters are similar to Validators, which means you can make the functions smaller in size by defining more than one function for the filtering process of a field. This also helps you reuse functions (-> you automatically produce reusable code).
E.g. you want a date field to be presented as a German date, take a look at the following code:

這樣的處理對初學者應該也會很簡單, 不用知道欄位資料會顯示在哪裡, 也不用知道資料從何而來. 就因為過濾器與驗證器相同, 因此也可以設計幾個小程式分別進行處理. 這樣就能重用這些函式 (所建立的函式自然就能重用)


<filter views="all" function="dateformat||m/d/Y"/>

This illustrates you the syntax of a filter and also the syntax for applying parameters to your functions (simply add a "|" to separate the parameters). To make working with dates easier for you, the function to format dates is already shipped with Simple Groupware.

這裡展示了過濾器的語法以及應用變數的方法, 在函式中, 只要加上"|" 就可以區隔變數. 為了讓日期的過濾更加簡易, Simple Groupware 已經內建這些函式.

The first parameter takes a verbal date modification, e.g. now + 1 month which returns the date increased by 1 month. The second parameter defines the format of the date.

第一個變數針對日期文字作了修改, 例如, now + 1 個月表示所傳回的月份會加上 1. 而第二個變數則定義了日期的格式.


An overview of the format parameters can be found at http://www.php.net/date. Examples dealing with modifications of dates are here: http://www.php.net/strtotime.

有關日期格式的說明, 請參考 http://www.php.net/date. 而處理日期顯示相關的範例則可參考 http://www.php.net/strtotime.

Syntax: To collect these functions in a central place, all filters are stored in core/functions_user.php and have a ``"modify_"`` prefix (because they modify data), e.g. "modify_dateformat". To define a filter in a sgsML file, write <filter views="all" function="truncate|20"/> between the <field>-tags to truncate the field to a maximum of 20 characters with the function modify_truncate.

語法: 為了將這些函式收集在一起, 所有的過濾器都存在 core/functions_user.php 中, 並且以 ``"modify_"`` 放在函式前面 (因為這些函式會修改 (modify) 資料), 例如, "modify_dateformat". 而在 sgsML 中則在 <field> 標註間, 寫成 <filter views="all" function="truncate|20"/> 可以透過 modify_truncate 函式, 將欄位資料裁截成只有 20 個字元.

(The "views=all" parameter indicates that this filter is used with every view and will be discussed later) Other functions are included to help you to manage files, URLs, source code highlighting, etc.

(而 "views=all" 變數表示此一過濾器會用在所有的 view, 隨後將會進一步討論) 其他還有包含處理 URLs 原始碼標示等之過濾器函式.

Note: for being neutral the date is stored in the database as timestamp (=an integer value).

注意: 為了在資料庫中置入中性資料, 日期以數字表示.

Store and Restore

資料存放與回復

Being as simple as possible, Simple Groupware automatically stores/reads data to/from the database. But sometimes you want to store inputs made by the user differently from the original value. E.g. the user types a date with a German formatting, but in the database it has to be a timestamp. Or you want to store URLs without a leading http:// in the database.

為了盡量保持簡潔, Simple Gropware  自動處理有關資料庫存/取與進/出相關動作. 但是有時使用者希望存入與使用者輸入不同格式的內容. 例如, 使用者在資料區輸入德式格式的日期, 但是資料庫則希望存入以數字表示的日期格式. 或者當存入資料庫 URLs 連結時, 不要放入 http:// 等.

Similar to validators and filters, functions used for storing the input get the value from the form as the first parameter and return the modified value back to the program. You don't have to care how the value is transferred from the form to your function. This makes things much easier, e.g. file uploads require big error handling routines that would boost up your code unnecessarily.

與驗證及過濾的動作相似, 用來處理輸入儲存的函式, 將表單資料當作第一變數, 將資料傳給程式, 使用者無需處理函式的進出. 可以簡單呼叫運用, 例如, 檔案上傳時需要較長的程式來處理錯誤辨識, 在這裡就不需要如此.

When modifying data before writing into the database, it is clear that there must be a re-transformation when being read from the database. This re-transformation is called restore. That's why there are restore functions, that are identical to filter functions regarding structure and functionality.

在資料存入資料庫前進行處理後, 就必須在資料取出時進行另一階段的回復處理. 而此一"再處理過程"就稱為"回復". 因此這些函式稱為回復函式, 就如同過濾函式資料處理流程.

Thus, writing store and restore functions is as easy as validators or filters. To reduce your functions in size you can also define multiple store or restore functions.

編寫儲存與回復函式的方法, 就如同驗證與過濾. 為了簡化個別函式, 可以將這些函式分成幾個儲存與回復函式.

Syntax: To collect these functions in a central place, all store and restore functions are kept in core/functions_user.php and have a ``"modify_"`` prefix (because they modify data), e.g. "modify_datetime_to_int" converts a date given as string to a timestamp using integer representation.

語法: 為了集中管理這些函式, 所有儲存與回復函式都放在 core/functions_user.php 中, 並且在函式前面加上 ``"modify_"`` (因為會修改資料), 例如, "modify_datetime_to_int" 就是將時間標示字串轉成整數的函式.

To define a store or restore function in a sgsML file, write <store function="datetime_to_int"/> and <restore function="dateformat||d.m.Y"/> between the <field>-tags to work with a date-field using the functions modify_datetime_to_int and modify_dateformat.

利用 sgsML 定義儲存與回復函式, 必須在 <field> 標註間, 寫成 <store function="datetime_to_int" /> 與 <restore function="dateformat||d.m.Y" />, 以便呼叫 modify_datetime_to_int 與 modify_dateformat.

As told before, Simple Groupware already knows a type called "date". Therefore you only need restore/store functions when defining your date-field with type "int". Using type "date" this is done automatically for you.

前面曾經提過, Simple Groupware 已經內建 date 型別. 因此只要在回復/儲存函式中將日期欄位定義成 "int" 就可以, 而 date 型別就會進行自動處理.

Note: The store functions are called after those used for validating the input.

注意: 儲存函式必須在輸入資料驗證後才進行呼叫.

Note: The restore functions are called before those used for filtering values from the database.

注意: 回復函式則在資料由資料庫取出後, 進行過濾後才進行呼叫.

Data sources

資料來源

Often it is necessary to build fields that already contain a set of data from which the user can choose the right values. E.g. this is a typical behavior for select-boxes. When writing an address book you might like to implement a field containing the gender of a person.

有時在建立欄位時, 可以提供一組資料, 以便讓使用者選取, 例如, 最常用的就是選項表. 當編寫通訊錄時, 可以建立一組性別欄位, 讓使用者選擇.

The preferred values are male and female. The type "select" defines a select-box in Simple Groupware. To define the preferred values you use the <data> construct in sgsML, e.g. <data values="male|female"/> Using more than one value, separate each with a "|". You can also define more than one <data> construct inside the <field>-tag.

也就是提供男性及女性讓使用者選擇. 而在 Simple Groupware 中是透過 "select" 來定義這些選項表.

為了定義這些選項, 可以採用 sgsML 中的 <data> 結構, 例如, <date values="male|female" /> 若有更多選擇, 各別以 "|" 隔開. 也可以在 <field> 標註中使用多個 <data> 結構.

The method shown before is used for including static data. But in reality, these values are often dynamic and need to be fetched from a special data source. To get these values you can define a function that searches the right values for you and returns them as an array.

前面所用的選項欄位為靜態資料, 有時這些資料會從特定的資料來源取出, 成為動態資料. 這時可以定義一個函式, 搜尋取得所要的資料後, 以陣列的格式傳回.

You don't have to care about transferring these values to forms or to the relevant components, this is done automatically for you. Simple Groupware automatically calls your function when it needs the data. Instead of the values-parameter you use the function parameter to tell it what function to call. E.g. you want to show a list of companies in your address book or predefined values:

使用者不需要特別知道如何在表單中處理這些資料, 系統會自動處理. Simple Groupware 會自動呼叫所需的函式, 取得所需要的資料.  與其提供數值變數, 使用者可以指定函式變數, 例如, 要在通訊錄中列出對應公司列表.

<data function="dbselect|simple_companies|companyname,companyname||companyname asc|10"/>

<data values="male|female"/>

To get these values you call the function dbselect which selects data from the database. To reduce this list we only want 10 items (parameter 5), if there are more, a search box is used to select relevant values.

在這裡呼叫 dbselect 函式, 進入資料庫取值. 這裡只取 10 筆 (變數 5), 若有更多資料, 可以利用搜尋來取得適當值.

All companies have to be listed sorted by the name of the company (=companyname) alphabetically (asc=ascending) (parameter 4). As the table "simple_companies" (parameter 1) can have more than one field we tell the function to use the field "companyname" (parameter 2). Parameter 3 is not used in this case.

所有公司資料會按照公司名稱 (=companyname) 來進行排序, 並且依照字母排序 (asc=ascending) (變數 4). 變數 1 則指定資料表 "simple_companies" (變數 1), 也可以指定多個欄位, 這裡使用 "companyname" 欄位 (變數 2), 這個例子並沒有使用變數 3.

With parameter 3 you can reduce the list of companies with an sql-where clause, e.g. "companyname like 'a%'" to get all companies starting with "a".

變數 3 可以利用 sql-where 的語法來圈定公司, 例如, "companyname like 'a%'" 就會只列出以 a 開頭的公司.

Syntax: To collect these functions in a central place, all data functions are kept in core/functions_user.php and have a ``"select_"`` prefix (because they select data), e.g. "select_dbselect" can be used to get data from the database.

語法: 為了將這些函式收集在一個地方, 所有的資料函式都放在 core/functions_user.php 中, 而且都有一個 ``"select_"`` 前置詞 (因為用來選擇資料), 例如, "select_dbselect" 可以從資料庫取得資料.

To define a data construct in a sgsML file, write <data function="getmydata"/> between the <field>-tags to call the function "select_getmydata". Here dbselect is illustrated because it is the most common function to get data from the database.

為了能在 sgsML 檔案中定義資料建構物件, 可以在 <field> 標註間放上一個 <data function="getmydata"/>, 以便呼叫 "select_getmydata" 函式. 這裡的 dbselect 特別標示出來的原因, 試通常利用這種方法從資料庫取得資料.

Note: To reduce the size of your functions you can define multiple <data function=> constructs between the <field>-tags.

注意: 為了減少函式定義的個數, 可以在 <field> 標註中定義多個 <data function=> 物件.

Tables

資料表

When looking at tables we see rows, columns. Our rows are assets, every column is a field (similar to database design). <table></table> is the main tag used in sgsML and includes all the others (e.g. fields, views, etc.). With the table tag you define the name of the module, e.g.

資料表有列位與欄位, 列代表資料, 而每一個欄位就如同資料庫中的資料表設計. <table></table> 是 sgsML 中經常會用到的標註, 而且其中還帶有其他標註, (例如, 欄位, 視圖等), 可以利用 table 標註來定義模組的名稱, 例如,

<table modulename="Contacts"></table>

特別在 table 標註中註明模組名稱為 "Contacts".

With a table you also define how the fields should be treated:

也可以在 table 中定義該欄位要如何因應:

What is the column the list or assets should be sorted by?

資料表列中要以那一欄位作為排序依據?

What order should be used?

次序要如何訂定?

How many items should be displayed on one page?

每一頁要列出多少資料?

Should the results be groups by a special column?

結果需不需要透過某一特殊欄位分組?

e.g.:
    
實際 table 標註應用如下:

<table modulename="Contacts" orderby="lastname" order="asc" groupby="categories" limit="20"></table>

Of course, these are only the default values you suggest to the user. He can later choose on his own if he needs different settings.

當然, 這些只是呈現給用戶的內定值, 使用者隨後可以根據需求選擇成其他設定.

Fields

欄位

All fields are defined inside the <table>-tag. A field can be seen as a column in a database, e.g. Last name, Street, Country in an address book. Every field has a type, in sgsML the type is called "simple_type".

所有欄位都定義在 <table> 標註中, 此欄位可以視為資料庫的資料表, 例如, 地址資料庫中的姓, 街道名稱, 國家名稱等, 而每一個欄位都有其型別, 如前所述, sgsML 中, 型別稱為 "simple_type".

A type can be a normal string (simple_type is "text") or a collection of lines (simple_type is "textarea"). There are even exotic types like "htmlarea" which represents lines formatted with HTML, or different types for using passwords, dates, times, datetimes, files, wikis, etc.
Every field has a name to be identified by the program.

型別可以是一行的字串 (simple_type 為 "text") 或者是幾行的字串 (simple_type 為 "textarea"). 也可以是比較特別的型別, 如 "htmlarea", 代表資料為 HTML, 或者是 passwords, dates, times, datetimes, files, wikis 等.
每一個欄位在程式裏都有一個型別名稱.

This is similar to column definitions in databases. Besides the internal name used by the program every column can contain a displayname which is the name displayed to the user.

這就如同資料庫定義中的資料表. 除了程式中用來代表欄位的內部名稱為, 每一個資料表也可以帶有一個用來顯示的名稱.

E.g. the name of a field can be "lastname", the displayname is "Last name". To separate these two has a lot of advantages:

例如, 欄位名稱可以是 "lastname", 而顯示的名稱則為 "Last name", 將這兩種名稱分開有許多好處:

The name used by the program is limited to numbers and characters, whereas displayname can contain all kinds of special characters or it can be translated into many languages without changing the internal name used by the program.

程式中欄位的名稱被限定只能用數字與字元, 而顯示用的名稱則可以包含各種特殊符號或者可以翻譯成許多不同語系中的名稱, 而無需更改程式中欄位的內部名稱.

This creates consistency when using internationalization with Simple Groupware.

如此就能在不同語系中使用 Simple Groupware, 程式可以保持一致.

Fields can be declared as unique, meaning that there can be no other asset having the same value within this field. To decide between required and optional fields, every field can be defined as "required", but is "optional" by default.

欄位可以宣告為獨一無二, 表示其他資料中不會有相同的欄位. 也可以宣告為必要或選項欄位, 所有欄位都可以定義為必要欄位, 內定則為選項欄位.

As written before, fields can be validated using validators, their data can be defined by some data sources and they can be modified before / after storing them in the database.

如前所述, 欄位可以利用驗證物件來進行驗證, 這些資料可以定義為特殊的資料來源, 也可以在存入資料庫之前或之後進行變更.

Some examples:
    
幾個範例:

contacts.xml:
    
聯繫模組

<field name="lastname" displayname="Last name" simple_type="text" required="true" />

欄位名稱為 "lastname", 顯示名稱為 "Last name", 資料型別為 "text", 為必要欄位.

<field name="zipcode" displayname="Zipcode" db_size="6" simple_type="text">
<validate function="numeric"/>
</field>

欄位名稱為 "zipcode", 顯示名稱為 "Zipcode", 資料庫欄位大小為 6 位數, 資料型別為 "text", 為選項欄位.

欄位驗證採用 numeric 物件, 只能填入數字.

<field name="description" displayname="Description" simple_type="textarea" simple_size="4" />

欄位名稱為 "description", 顯示名稱為 "Description", 資料型別為 "textarea", 資料欄位大小為 4 位數, 為選項欄位.

Views

視圖

The next element inside the sgsML language is a "view". At first "views" are groups of fields. E.g. you show "first name" and "last name" of a person in the view "display" and the field "address" and "description" in the view "details".

下一個 sgsML 語言中的元素為 "view", 首先 "views" 用來對欄位進行分組, 例如, 將某一用戶的 "first name" 與 "last name" 放在 "display" 視圖中, 並且將 "address" 與 "description" 欄位放在 "details" 視圖中.

But views can do a lot more: views are also used to edit and create assets. Since defining forms (for editing and creating assets) is not always easy and oftentimes requires Javascript usage, Simple Groupware creates all the forms automatically for you. So you only define a field as an html-editor (simple_type "htmlarea") and you're done.

但是視圖還有其他功能: 視圖還能用來編輯與建立資料. 因為定義用來編輯與建立資料的表單, 並不容易, 而且通常需要用到 Javascript. Simple Groupware 則自動建立所有的資料表單. 只要宣告欄位為 html-editor (simple_type 型別為 "htmlarea") 就可以了.

To present several fields, sgsML differs between the orientation in which a group of fields is presented: The horizontal view (sgsML "display") is a list where every field has one column (this is how Windows Explorer lists files).

為了呈現幾個欄位,  sgsML 就群組欄位的方位試圖有所不同: 水平視圖 (sgsML 中的 "display") 就是每一個欄位放在一行中的列表呈現 (與視窗中顯示檔案的方式相同).

The second one is called "details" (vertical orientation) and presents every field as one line, meaning the first column is the name of the field and the second column contains the value of it.

第二種方式稱為 "details" (垂直顯示) 讓每一個欄位都集中在一列中, 第一行為欄位名稱, 而第二行則為該欄位的值.

Both orientations have advantages and disadvantages, so you can decide on your own which one you use for what case: define template="display" or template="details" in the view-tag and you're done. Note: When naming a view "foobar", the template "asset_foobar.tpl" will be used. Using the attribute template="display" in the view tag overrides this automatic mapping.

這兩種呈現各有優缺點, 使用者可以自行決定要使用哪一種: 在檢視標註中設定 template="display" 或 template="details" 就可以了. 注意: 若將視圖設為 "foobar" 將會使用 "asset_foobar.tpl" 樣版檔案. 使用 template="display" 屬性, 則會改寫先前的自動對應.

When looking with web applications you often see a list of assets (horizontal orientation) and a "Details" button at the right side to switch to the vertical one for a selected row.

網際程式中, 經常會看到一組資料 (水平排列) 假如選擇右邊的 "Details" 按鍵, 就會將某一選擇的資料列轉為垂直排列.

If you need this behavior depends on you own, simply add a showinsingleview="true" as attribute to the details-view and you're done (sgsML defines the rows of a table as single view, the headline above is the "normal" view, thus "singlebuttons" are buttons displayed at the right side of every asset).

可以自行決定是否要採用此項功能, 只要加入 showinsingleview="true" 屬性到 details-view 就可以了. (sgsML 定義 single view 為表格的列, 顯示在上頭的標題為 "normal" view, 因此 "singlebuttons" 就是每一筆資料右上方的相關按鍵.

Similar to tables, views can have their own "order", "orderby", "limit" statements which override those defined by the table.

與資料表一樣, 視圖有其 "order", "orderby", "limit" 設定可以改寫表格先前的定義.

Other tags are "image_width" and "image_height" (both or only one of them) which enable you to automatically resize images (simple_type "files", images are detected automatically when extension is gif/jpeg/png). This is very useful when bandwidth is low.

其他標註為 "image_width" 與 "image_height" (同時啟用或只使用其中之一), 可用來自動調整影像大小 (simple_type "files", 副檔名為 gif/jpeg/png 的影像檔會自動辨識). 當傳輸頻寬不高時, 這功能就很有用.

Another way views can be used is to reduce the number of assets by a "where" clause, e.g. "lastname like 'a%'" to get all persons starting with "a" (this functionality is similar to views in databases using SQL-Views).

另一方面 views 可以利用 "where" 語法來減少所呈現的資料筆數, 例如 "lastname like 'a%'" 來取得資料中姓名以 "a" 開頭的內容 (類似資料庫 SQL-Views 中的資料 views 功能).

To group fields to special views, you define constructs like "notin" (exclusion method) or "onlyin" (inclusion method) inside the <field>-tags.

將欄位群組成特定的視圖, 可以在 <field> 標註中, 定義類似 "notin" 的語法 (排除) 或 "onlyin" (包含).

Some examples:

幾個範例:
    
contacts.xml:
    
通訊錄模組

<view name="display" displayname="{t}Display{/t}" groupby="category" />

視圖名稱為 display, 顯示名稱啟用 Display 的語系翻譯, 而且以 category 進行分組展示.

<view name="details" displayname="{t}Details{/t}" showinsingleview="true" />

視圖名稱為 details, 顯示名稱啟用 Details 的語系翻譯,  showsingleview 設為 true.

users.xml:

使用者模組

<view name="display" displayname="{t}Active{/t}" where="activated=1" />

視圖名稱為 display, 顯示名稱啟用 Active 的語系翻譯, 而且 activated 設為 1.

<view name="details" displayname="{t}Details{/t}" image_width="200" image_height="100" showinsingleview="true" />

視圖名稱為 details, 顯示名稱啟用 Details 的語系翻譯, 影像寬度設為 200, 高度設為 100, showsingleview 設為 true.

Tabs

視窗頁面

The last construct used by sgsML are tabs. Tabs are similar to views: They group fields and enable you to quickly switch from one group to another without overloading the screen.

最後要介紹的 sgsML 物件為視窗頁面. 視窗頁面與視圖類似: 用來將幾個欄位擺在一起, 讓使用者可以很快由某一群組切換到另一群組, 而無需重載畫面.

A view is static: This means when you click on a view, the program takes the required fields from the databases and presents the results to you. In contrast, tabs are subordinated to views. A view can contain several tabs, every tab is visible in every view (sounds a bit difficult at the first shot, but gets clearer when writing the first application).

視圖為靜態物件: 當按下某一視圖, 程式會從資料庫取出所需要的欄位資料, 然後將資料呈現出來. 相對的, 視窗頁面則包含在視圖當中. 一個視圖可以帶有幾個視窗頁面, 而且每一個視窗畫面都可由視圖物件中切換 (光這樣說明可能不容易理解, 但是寫完一個應用程式後, 就會越來越清楚).

Tabs are dynamic: E.g. you click on one view containing 5 tabs, all fields for the 5 tabs are loaded from the database and put into the (HTML-)output. To avoid overloading the screen, tabs use Javascript to make sure that only one tab is visible at once. When clicking another tab, the old one is hidden and the other is made visible. To assign fields to tabs, simply use <field ... simple_tab="mytab">.

視窗頁面是動態的: 例如, 點進一個擁有 5 個視窗頁面的視圖, 這 5 個頁面資料其實都已經從資料庫取出資料, 並且納入 (HTML) 的輸出畫面. 為了避免全部擠在畫面中, 視窗頁面利用 Javascript 的圖層進行處理, 讓每次只呈現一個畫面. 使用者按下其他頁面時, 舊頁面就會隱藏起來, 讓點選的頁面呈現出來. 要將欄位資料以視窗頁面呈現, 只要使用 <field ... simple_tab="mytab">.

Here is an example:
    
這裡有個範例:

<tab name="general" displayname="{t}General{/t}" />

頁面名稱為 "general", 顯示名稱則為 General 的語系翻譯詞.

<tab name="details" displayname="{t}Details{/t}" />

頁面名稱為 "details", 顯示名稱則為 Details 的語系翻譯詞.

<field name="description" displayname="{t}Description{/t}" simple_type="textarea" simple_size="4" simple_tab="details" />

欄位名稱為 "description", 顯示名稱則為 Description 的語系翻譯詞, simple_type 為 "textarea" simple_size 為 "4", simple_tab 為 "details".

Deploy your applications with sgsML

利用 sgsML 部署網際應用程式

Finally after writing your first sgsML application you will surely want to deploy it to your Simple Groupware installation. Therefore every module is a web application and stored in one .xml file. Simple Groupware distinguishes between two types of modules: Normal modules and system modules.

寫好了第一個 sgsML 應用程式後, 當然就是把它部署到 Simple Groupware 安裝當中. 因為每一個網際應用模組都將程式存在一個 .xml 格式檔案中. Simple Groupware 則將應用程式分為兩類: 一般模組與系統模組.

System modules are very special modules providing access to other data sources (e.g. the filesystem, other databases, IMAP, iCalendar, etc.) or providing system functionality (folders, statistics, events, search functionalities, session handling, etc.).

系統模組是較為特別的模組, 專門用來擷取特殊的資料來源 (例如, 檔案系統, 其他資料庫, IMAP, iCalendar 等) 或者提供系統功能 (檔案夾, 統計功能, 事件, 搜尋功能,  暫存檔案處理等).

A module is a system module if Simple Groupware cannot run without it.

沒有系統模組 Simple Groupware 就無法運行.

(There are even some modules like users and groups where this border cannot be clearly pulled, these modules remain system modules since you can't work without it).

使用者與群組模組雖然介於兩者之間, 但還是被視為系統模組, 因為沒有這些模組, 系統還是無法運行.

System modules are kept under "modules/schema_sys". If a module doesn't represent a schema from a table with data in the database than it carries a ``"nodb_"`` prefix in the filename (e.g. the filesystem has a schema, but it is not a schema from a table with data in the database). A module that is marked as ``"nodb_"`` needs to get its data from another data source.

系統模組被放在 "modules/schema_sys" 目錄中. 假如某一個模組沒有使用資料庫, 檔名就會帶有 ``"nodb_"`` 前置名稱. (亦即, 這個模組與檔案系統有關, 但是與資料庫中的資料表沒有關聯). 若模組標示為 ``"nodb_"`` , 表示這個模組需要從其他資料來源取得資料.

Therefore it uses its own functions for getting and setting data. These functions are very simple and are automatically called by the sql-handler of Simple Groupware. These functions are stored in modules/lib/* and are all following the Simple Groupware API. When learning sgsML you should try to understand system modules at last.

因此, 這些模組使用各自的函式來取得或設定資料. 這些函式通常非常簡單, 而且會自洞由 Simple Groupwaer 的 sql 處理器進行呼叫. 這些函式放在 modules/lib/* 當中, 通常使用 Simple Groupwaer 的 API 函式. 想要學習 sgsML 就必須要徹底了解這些系統模組.

以下這些 src/ 與 bin/ 的目錄架構, 在 0.8 版已經有了變更, 因此是否要對以下資料進行翻譯??

The Simple Groupware folder structure has two branches: src/ and bin/. If you install with language English, German, etc. all files from src/* are translated and written to bin/* during the setup process. Therefore if you installed with English or German, place your .xml file in bin/modules/schema/. If you installed with Developer as language, place your .xml file in src/modules/schema/.

Note: To be able to select a module in the list when creating a new folder, you need to add the module to "modules/schema/modules.txt". Every line in this file contains the module's name and the string that is displayed in the web-interface.


Note: Every .xml file defines a structure of a table in the database. The name of the table is automatically set by the filename and ``"simple_"`` as prefix. E.g. the table name for schema/tasks.xml is set to simple_tasks. If the module is a system module, the prefix will be ``"simple_sys_"``. E.g. the table name for schema_sys/users.xml will be simple_sys_users. The "modulename" attribute is only the name displayed above the tree on every page.


Translations

With Simple Groupware you can translate everything: It doesn't matter if the strings that should translated are inside XML, PHP, Html, sgsML, etc. Every string that needs to be translated is covered with {t} and {/t}. E.g. to make "username" translatable, use it as "{t}username{/t}".

That's the same using sgsML. Examples for translations inside sgsML are display-names for fields, date formats as validation / store parameters, etc. The translation process is done during the setup. So you select a language and all files from the src/ directory are translated into the bin/ directory.

When installing with Developer as language, the translation isn't done. All files reside in src/ and when viewing the output, {t} and {/t} are automatically removed. So using Simple Groupware as "Developer" you always get untranslated English values in the output.
Note: If you don't need translations, you won't need to add "{t}" and "{/t}".

Examples

blank.xml:

<table modulename="{t}Blank{/t}" default_view="display" default_sql="no_select">
<view name="display" displayname="{t}Display{/t}" />
<field name="id" simple_type="id" displayname="{t}Id{/t}" />
</table>

This module has the name blank. It will be displayed as {t}Blank{/t} where "{t}Blank{/t}" will be translated using the language files. As we defined one view (display), the default view is also display. The view "display" will be displayed as the translation of {t}Display{/t}.

In this example we have one field called "id" with the simple_type of "id" meaning this field will be used as a primary key for the table.

Also there is a default_sql statement: This overrides normal (automatic) SQL select statements. When using no_select, there will be no select statement being done. In this example we want the SQL statement to be done automatically, so we strip the default_sql attribute.

Now, let's make a second field called "Last name". Since every person should have a last name we want it to be required every time a new person is created or edited. Last name is a string and therefore we use simple_type "text" which is used for all strings that don't require line breaks. Last name should be named "lastname" in the program and displayed as the translation of {t}Last name{/t}.

blank.xml:

<table modulename="{t}Blank{/t}" default_view="display">
<view name="display" displayname="{t}Display{/t}" />
<field name="id" simple_type="id" displayname="{t}Id{/t}" />
<field name="lastname" displayname="{t}Last name{/t}" simple_type="text" required="true" />
</table>

Adding "first name" is done the same way:

<field name="firstname" displayname="{t}First name{/t}" simple_type="text" required="true" />

To help you finding your entries we want to sort them by lastname (default is Id). Therefore we expand the table statement with two attributes:

orderby="lastname" order="asc"

Orderby defines the field we want to sort by and asc means that the entries should be sorted ascending (instead of desc for descending). Having more than 100 entries makes the list very long, so we want to distribute the entries to several pages. To do this, only set a limit to the table:

limit="20"

To help you to remember the relationships to these assets we add a new field called description:

<field name="description" displayname="{t}Description{/t}" simple_type="textarea" simple_size="4" />

The field description will be displayed as the translation of {t}Description{/t}. The type used here is "textarea" which is similar to the "textarea" component used in HTML. Thus we have a text which can be longer than one line. Here simple_size indicates that textarea has a height of 4 rows.

Now we have:

blank.xml:

<table modulename="{t}Blank{/t}" default_view="display" orderby="lastname" order="asc" limit="20">
<view name="display" displayname="{t}Display{/t}" />
<field name="id" simple_type="id" displayname="{t}Id{/t}" />
<field name="lastname" displayname="{t}Last name{/t}" simple_type="text" required="true" />
<field name="firstname" displayname="{t}First name{/t}" simple_type="text" required="true" />
<field name="description" displayname="{t}Description{/t}" simple_type="textarea" simple_size="4" />
</table>

To rename our module from blank to "My Addresses", use ...

myaddresses.xml:

<table modulename="{t}My Addresses{/t}" default_view="display" orderby="lastname" order="asc" limit="20">
<view name="display" displayname="{t}Display{/t}" />
<field name="id" simple_type="id" displayname="{t}Id{/t}" />
<field name="lastname" displayname="{t}Last name{/t}" simple_type="text" required="true" />
<field name="firstname" displayname="{t}First name{/t}" simple_type="text" required="true" />
<field name="description" displayname="{t}Description{/t}" simple_type="textarea" simple_size="4" />
</table>

... and rename the file from "src/modules/schema/blank.xml" to "src/modules/schema/myaddresses.xml" if you installed Simple Groupware with language "Developer". If you installed it with English or German, rename the file from "bin/modules/schema/blank.xml" to "bin/modules/schema/myaddresses.xml".

Now we only have a simple view that can display entries. To enable you to create new entries, add the following attribute to the table tag:

enable_new="true"

This automatically adds the "New" view with the rights attributes.
To allow you to edit and delete existing entries, add these attributes to the table tag:

enable_edit="true" enable_delete="true"

This automatically adds the "Edit" view and the "Delete" buttons.
With Simple Groupware you assign one module to every folder. Therefore you may want to be able to delete all entries in the folder. To do this we use the "empty" attribute:

enable_empty="true"

This automatically adds the "Empty" button.

myaddresses.xml:

<table modulename="{t}My Addresses{/t}" default_view="display" orderby="lastname" order="asc" limit="20" enable_new="true" enable_edit="true" enable_delete="true" enable_empty="true">
<view name="display" displayname="{t}Display{/t}" />
<field name="id" simple_type="id" displayname="{t}Id{/t}" />
<field name="lastname" displayname="{t}Last name{/t}" simple_type="text" required="true" />
<field name="firstname" displayname="{t}First name{/t}" simple_type="text" required="true" />
<field name="description" displayname="{t}Description{/t}" simple_type="textarea" simple_size="4" />
</table>

To deploy your new web application, make sure that the module is stored in "src/modules/schema/myaddresses.xml" (Developer language) or "bin/modules/schema/myaddresses.xml" (English, German, etc. language).


Inside Simple Groupware, take a look at the tree. Go to a folder where you want to place the new application, e.g. click "Workspace". Below the tree, click "Options", enter a new folder name to the "New folder" form, choose "myaddresses" in the list and click Ok. This is all: The new module is running now!


Note: The modules in the list contain the filenames without the extension (.xml), not the modulename-attribute. Therefore you see "myaddresses" in the list instead of "{t}My Addresses{/t}".

To improve "My Addresses" we add some more fields:

<field name="street" displayname="{t}Street{/t}" simple_type="text" />
<field name="zipcode" displayname="{t}Zipcode{/t}" db_size="6" simple_type="text">
<validate function="numeric" />
</field>
<field name="city" displayname="{t}City{/t}" simple_type="text" />

All three are of type "text", but the zip code should be validated by some constraints: The first validation is done with db_size=6 which means that the field may not be longer than 6 characters. Since zip codes are numeric (in Germany) we add the validator "numeric" (when creating or editing a new asset the function "validate_numeric" is called). If your zip codes are not numeric, leave this step out.

But the "Display" quickly gets overloaded with fields. Thus we create a new view called "Details".

<view name="details" displayname="{t}Details{/t}" showinsingleview="true" tfield_1="firstname" tfield_2="lastname" />

We decide that Id and description are less important than the other fields and should be displayed in the second view "Details". Also the fields "lastname" and "firstname" should be displayed as a caption in the first line of the details view (indicated with the attributes "tfield_1" and "tfield_2").

This means we add new limitations to the fields:

<notin views="display" />

Notin tells the program not to display the field in the view "display". Notin uses "views" as attribute which means that you can add several views here using views="view1|view2" separated with "|".


Summarizing our activities

myaddresses.xml:

<table modulename="{t}My Addresses{/t}" default_view="display" orderby="lastname" order="asc" limit="20" enable_new="true" enable_edit="true" enable_delete="true" enable_empty="true">
<view name="display" displayname="{t}Display{/t}" />
<view name="details" displayname="{t}Details{/t}" showinsingleview="true" tfield_1="firstname" tfield_2="lastname" />
<field name="id" simple_type="id" displayname="{t}Id{/t}">
<notin views="display" />
</field>
<field name="lastname" displayname="{t}Last name{/t}" simple_type="text" required="true" />
<field name="firstname" displayname="{t}First name{/t}" simple_type="text" required="true" />
<field name="description" displayname="{t}Description{/t}" simple_type="textarea" simple_size="4">
<notin views="display" />
</field>
<field name="street" displayname="{t}Street{/t}" simple_type="text" />
<field name="zipcode" displayname="{t}Zipcode{/t}" db_size="6" simple_type="text">
<validate function="numeric"/>
</field>
<field name="city" displayname="{t}City{/t}" simple_type="text" />
</table>

When saving changes to the xml file you only need to hit the "Refresh" button in your browser to make Simple Groupware apply your changes.

Examples (continued)

To make the description field more usable we change simple_type from textarea to htmlarea:

simple_type="htmlarea"

Hit refresh and you have a complete HTML editor!

Another way to avoid overloading of the display view is using simple_tabs.

So we define two tabs, one for general information, the other one for the details (both displayed with the translation from the language file):

<tab name="general" displayname="{t}General{/t}" />
<tab name="details" displayname="{t}Details{/t}" />

The difference between "views" and "tabs" is the time when the information is loaded. With views, only the information for the current view is loaded. Using tabs all the information is loaded, but hided using Javascript until you hit the tab. Switching between tabs is much faster because you have already loaded all the information in your browser, but loading the page takes longer at the beginning.

The same example using tabs instead of views looks like this:

myaddresses.xml:

<table modulename="{t}My Addresses{/t}" default_view="display" orderby="lastname" order="asc" limit="20" enable_new="true" enable_edit="true" enable_delete="true" enable_empty="true">
<view name="display" displayname="{t}Display{/t}" />
<tab name="general" displayname="{t}General{/t}" />
<tab name="details" displayname="{t}Details{/t}" />
<field name="id" simple_type="id" displayname="{t}Id{/t}" simple_tab="details" />
<field name="lastname" displayname="{t}Last name{/t}" simple_type="text" required="true" />
<field name="firstname" displayname="{t}First name{/t}" simple_type="text" required="true" />
<field name="description" displayname="{t}Description{/t}" simple_type="htmlarea" simple_size="4" simple_tab="details" />
<field name="street" displayname="{t}Street{/t}" simple_type="text" />
<field name="zipcode" displayname="{t}Zipcode{/t}" db_size="6" simple_type="text">
<validate function="numeric" />
</field>
<field name="city" displayname="{t}City{/t}" simple_type="text" />
</table>

To add a gender selectbox with the values male, female, use:

<field name="gender" displayname="{t}Gender{/t}" db_size="10" simple_type="select" simple_size="1" simple_tab="details">
<data values="{t}male{/t}|{t}female{/t}"/>
</field>

The field gender has a maximum of 10 characters, is displayed as a selectbox (simple_type select) and the user can select 1 item (instead of multiple items).

Since every address has relations to other addresses we finally add a field to store these relationships:

<field name="isrelatedto" displayname="{t}Is related to{/t}" simple_type="select" simple_size="3" is_linked="simple_myaddresses|details|lastname" multiple="&lt;br&gt;" simple_tab="details" allow_custom="true">


<data function="dbselect|simple_myaddresses|lastname,lastname||lastname asc|10"/>
</field>

The field isrelatedto is displayed with the translation of {t}Is related to{/t}. The simple_type is a selectbox with a height of 3 lines, allowing the user to select multiple items. In the display these items are separated by "<br>" (= new line). The user can also type in his own items which is declared by allow_custom=true.

To get the data from the selectbox we use the select_dbselect function which does something like "select lastname from simple_myaddresses order by lastname asc limit 10". If there are more than 10 items, the user can select them by using a search box.

This field is also shown in the details tab. Furthermore when displaying the items of this field we want these items to be links. When a user clicks them the referenced address should be displayed.

This behavior is achieved by using the "is_linked" attribute. The first parameter names the table, the second the view we want to see in the popup and the third defines the field to choose from.


The complete code of the example

myaddresses.xml:

<table modulename="{t}My Addresses{/t}" default_view="display" orderby="lastname" order="asc" limit="20" enable_new="true" enable_edit="true" enable_delete="true" enable_empty="true">
<view name="display" displayname="{t}Display{/t}" />
<tab name="general" displayname="{t}General{/t}" />
<tab name="details" displayname="{t}Details{/t}" />
<field name="id" simple_type="id" displayname="{t}Id{/t}" simple_tab="details" />
<field name="gender" displayname="{t}Gender{/t}" db_size="10" simple_type="select" simple_size="1" simple_tab="details">
<data values="{t}male{/t}|{t}female{/t}"/>
</field>
<field name="lastname" displayname="{t}Last name{/t}" simple_type="text" required="true" />
<field name="firstname" displayname="{t}First name{/t}" simple_type="text" required="true" />
<field name="description" displayname="{t}Description{/t}" simple_type="htmlarea" simple_size="4" simple_tab="details" />
<field name="street" displayname="{t}Street{/t}" simple_type="text" />
<field name="zipcode" displayname="{t}Zipcode{/t}" db_size="6" simple_type="text">
<validate function="numeric"/>
</field>
<field name="city" displayname="{t}City{/t}" simple_type="text" />
<field name="isrelatedto" displayname="{t}Is related to{/t}" simple_type="select" simple_size="3" is_linked="simple_myaddresses|details|lastname" multiple="&lt;br&gt;" simple_tab="details" allow_custom="true">
<data function="dbselect|simple_myaddresses|lastname,lastname||lastname asc|10"/>
</field>
</table>

Note: Using translations normally takes more time, so it is on you to use them or not.

注意: 使用翻譯功能通常會花費較多時間, 可以決定是否要採用這項功能.

Screenshots of myaddresses.xml

myaddresses.xml 執行畫面

Search functionality

搜尋功能

All your data will automatically be searchable. If simple_type is files, each file will be indexed using the binary tools (catdoc, xlhtml, ImageMagick, Xpdf, UnZip, gzip, tar). These tools are included as windows binaries, if using Linux/Unix you need to install these packages from your distribution (see Installation).

所有資料都可以查詢. 若 simple_type 為檔案, 每一個檔案都會透過二位元工具 (catdoc, xlhrml, ImageMagick, Xpdf, UnZip, gzip, tar) 進行索引. 這些工具具都有 windows 二位元檔案, 假如使用 Linux/Unix 則需要自行安裝這些套件. (參見安裝說明).

Summary

總結

To demonstrate the efficiency of Simple Groupware and sgsML:
    
為了驗證 Simple Groupware 與 sgsML 的效能:

We have written a complete web application including 9 fields with only 26 lines of code.

可以用 26 行 9  欄位寫一個完整的網際應用程式.

You can create / edit / delete assets. With the built-in tree of Simple Groupware you can create different folders for special groups of addresses.

使用者可以建立/編輯/刪除應用程式中的資料. 透過內建的 Simple Groupware 樹狀架構, 可以針對不同群組建立不同的資料目錄.

All your changes are logged in the history.

所有的變更都會在程序檔案中註記

And maybe the most important benefit all the values are already searchable via the global search function. (You can even try using phonetic searches!)

最重要的好處是, 所有內容都可以透過全域搜尋函式進行搜尋 (也可以使用同音搜尋功能)

I hope you got a first introduction into the world of sgsML and already understood most parts of it.

希望經過這個簡短的介紹, 可以跨入 sgsML 的世界, 並對大部分的內容都能有所理解.

For more examples, see the "src/modules/schema" directory (including examples using files, dates, codeareas, wikiareas etc.).

更多的範例, 可以查看 "/src/modues/schema" 目錄 (包含使用 files, dates, codeareas, wikiareas 等功能的範例)

To go deeper into sgsML there is "src/modules/schema_sys" (containing the Simple Groupware system modules and handlers for external data sources).
This is only a small tutorial describing the basic ideas and elements behind sgsML. If you write your own modules, and there is something not working or not clear, feel free to mail me.

想要更深入了解 sgsML, 可以查看 "src/modules/schema_sys" (包含 Simple Groupware 系統模組與外部資料來源的處理器).
這個簡介只說明有關 sgsML 的基本概念與元件. 您若自行編寫模組, 有哪些功能無法運作或不清楚, 可以寫信給我.
.. @+node:amd_yen.20130319174748.1563: *4* peerreview 模組
以下 Simple Groupwae 模組 Peer Review:

模組檔案為 peereview.xml, 部署時必須在 bin/modules/schema/modules.txt 中登錄, peereview|Peer Review

.. code-block:: xml

    <table modulename="Peer Review" default_view="display" orderby="studentno" order="asc" limit="20" enable_new="true" enable_edit="true" enable_delete="true" enable_asset_rights="owner_read">
    <view name="display" displayname="Display" />
    <view name="details" displayname="Details" showinsingleview="true" tfield_1="studentname" tfield_2="score" />
    <field name="id" simple_type="id" displayname="Id">
    <notin views="display" />
    </field>
    <field name="studentname" displayname="姓名" simple_type="text" required="true" />
    <field name="studentno" displayname="學號" simple_type="text" required="true">
    <validate function="regexp|/^[0-9]{8}+$/|學號必須為 8 位數數字"/>
    </field>
    <field name="score" displayname="分數" simple_type="text" required="true">
    <validate function="regexp|/^[0-9]{2}+$/|分數必須為 2 位數數字"/>
    </field>
    <field name="description" displayname="評分說明" simple_type="textarea" simple_size="4">
    <notin views="display" />
    </field>
    </table> 
.. @+node:amd_yen.20130309155804.1711: *4* 齒輪減速機專案
協同小組每組 6 人, 協同大組每組 18 人, 請各組分別啟動 Simple Groupware, 以 IMAP authentication 為主, 讓各小組與大分組的成員可以登入到各組的主機.

每一學員都有三台主機可以登入, 即本小組主機與其他兩個大組的分組主機.

請以每大組 18 人的協同模式下, 完成一份大分組的前三週分組課程內容整理報告.

請說明各分組的協同群組軟體在此一模式下可以提供哪些功能?各組員分別扮演哪些角色?

請討論如何以協同模式完成網際`正齒輪減速機_`的產品開發, 此一開發流程分別包含哪些工作?請根據各組員所擔任的角色, 繪出協同產品開發流程圖, 並明確列出各組員在特定階段的專案管理過程, 分別需要熟悉哪些技術?分別選擇如何完成所被交付的任務工作?

1. CMSimple XH 模式下, 使用者完成延伸程式齒輪尺寸設計 (齒面寬) 後, 隨即在網際介面提供減速機所屬的相關零組件.

2. 將齒輪減速機設計程式轉為 Simple Groupware 格式的延伸程式.

3. 配合上述相關設計流程, 完成一套單機版本的齒輪減速機輔助設計程式 (若以 Python 程式為例, 可以選擇 tkinter 與 PyQt 介面).

貴大組需要多久時間完成此一產品開發的工作?

.. _正齒輪減速機: https://github.com/chiamingyen/CMSimpleGearPlugin

Python3 tkinter 正齒輪輪廓圖程式:

.. 請注意: 以下採用程式檔案直接載入文書內容的模式取得對應的程式原始碼.

.. literalinclude:: ../cd/gearcontour.py
   :language: python
   :linenos:

參考資料:

https://github.com/joostn/OpenJsCad/tree/gh-pages

http://joostn.github.com/OpenJsCad/

http://joostn.github.com/OpenJsCad/gearsdemo.html

http://joostn.github.com/OpenJsCad/grilledemo.html

http://joostn.github.com/OpenJsCad/lampshadedemo.html
.. @+node:amd_yen.20130316100629.1527: *4* sgsML 語言
基本概念:
    
   Simple Groupware 中的相關模組基本上都是利用 sgsml 所編寫, 並且位於 bin/modules/schema, 並且所有的模組都登錄在 bin/modules/schema/modules.txt 中, 而且模組所對應的 .xml 位於 bin/modules/schema 目錄中.
    
資產的權限管理:

    Simple Groupware 除了文件夾可以設定權限外，也可以設定個別模組下相對資產(asset)的權限。共有下列三種不同類型的資產權限設定：
    
    “Full”是指賦予該資產讀取與編寫的權限，默認設置對象為匿名者。換言之，若將模組的資產擷取權限設為 Full, 表示所有的用戶對於該模組項下的所有內容都具備讀取與編寫的權限。
    
    “Owner write”是指賦予該資產的所有人具有編寫的權限，默認設置對象為資產所有人。換言之，若將模組的資產擷取權限設為 Owner write, 表示所有的用戶對於該模組項下的所有內容只具備讀取的權限，而資料的擁有人則具備修改的權限。
    
    “Owner read”是指賦予該資產的所有人具有讀取的權限，默認設置對象為資產所有人。換言之，若將模組的資產擷取權限設為 Owner read, 表示只有該資料的擁有人則具備修改與讀取的權限。
    
使用資產權限模塊的案例：
    
    Files 與 CMS 就是採用 Full 資產權限設定，Forum 則採用 Owner write，Timesheets 與 Expenses 則使用 Owner read 權限設定。
    
    使用者可以在各模組對應的資料編輯區中的 permissions 檢視各模組的資產權限設定。
    
    以下則為 My Addresses 模組的資產設定 (為 owner_read):
    
    <table modulename="My Addresses" default_view="display" orderby="lastname" order="asc" limit="20" enable_new="true" enable_edit="true" enable_delete="true" enable_empty="true" enable_asset_rights="owner_read">
    
    其中的 enable_asset_rights="owner_read" 表示將此模組設為: 只有資料的擁有者 (以及管理者) 可以看到自己新增的資料, 當然資料擁有者 (以及管理者) 也可以修改自己的資料, 其他用戶則看不到其他人所建立的相關資料.
    
資產的刪除權限設定:
    
    假設模組的權限設定使用 enable_empty="true", 表示具有編輯權限的用戶, 可以透過 empty 指令 (垃圾桶) 將整個模組中的 assets 全部刪除 (其中包括他人所建立的 assets).

    假如拿掉 enable_empty="true", 而讓使用者對該模組有編輯權限, 則使用者只能刪除自己新增的相關資料.

    此外, 某一檔案夾中的特定模組需要讓使用者擁有寫入編輯的權限, 該檔案夾應該只需要能夠讓使用者讀取即可, 而無需給 write access 的權限(因為 write access 同時擁有刪除的權限), 但是必須在 view 中設定 write 的權限.
    
    亦即, 可以將某一檔案夾設為成員可以讀取, 但無法寫入, 然後在 view 的部分設定

    |new,edit:write:anonymous|
    
    也就是任何人都可以擁有 new 與 edit 的寫入權限, 就可以有效保護該檔案夾, 不被成員刪除或改名, 但是成員可以新增與編輯, 然而卻無 delete 的功能, 若也要讓成員對於 assets 有刪除權限, 則必須要修改 write 的權限, 將內定的檔案夾權限刪除與改名權限由 write 提升到 admin, 然後授與該檔案夾的 write 權限給相關成員, 就可以讓成員對檔案夾內的 assets 有 delete 權限.
    
Simple Groupware 模組欄位的修改:
    
    從 0.720 版開始, 各模組的欄位可以直接在線上進行修改, 修改步驟:

        1. 登入管理者帳號.
        
        2. 進入 Workspace/System/Customize/Fields.
        
        3. 直接輸入要應用到對應欄位的規則, 每一筆規則會對應到某一欄位.
        
        自動系統欄位:

            在表單中不會顯示.

        id: 每一筆資料的唯一代號 (primary key). 包含資料 ID 與伺服器 ID (兩位數), 例如: 若資料代號為 201, 表示資料編號 為 2, 且伺服器編號為 01.
        
        folder: 代表檔案夾編號.
        
        created: 資料建立時間戳記.
        
        lastmodified: 最後更新時間戳記.
        
        createdby: 資料建立者的使用者名稱.
        
        lastmodifiedby: 最後資料修改者名稱.
        
        dsize: 與資料附加檔案的容量大小.
        
        history: 用來追蹤用戶更新資料與欄位的文字資料.
.. @-all
.. @-leo
