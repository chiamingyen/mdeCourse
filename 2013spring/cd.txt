.. @+leo-ver=5-thin
.. @+node:amd_yen.20130308210411.2392: * @file cd.txt
.. @@language rest
.. @@tabwidth -4

.. @+at @rst-options
..  call_docutils=False
..  code_mode=False
..  generate_rst=True
..  http_server_support = False
..  show_organizer_nodes=True
..  show_headlines=True
..  show_leo_directives=True
..  stylesheet_path=..\doc
..  write_intermediate_file = True
..  verbose=True
.. @@c

.. @+all
.. @+node:amd_yen.20130308210411.2393: ** @rst document\cd.html
################################################
協同產品設計實習
################################################

.. index:: 協同產品設計實習

.. contents::
    :depth: 3
.. @+node:amd_yen.20130308210411.2394: *3* @rst-no-head Links
.. @+node:amd_yen.20130308214521.2420: *3* CD 第一週
以下資料從課程電子書所對應的 springlink 網站取出, 此內容為公開資料.

http://link.springer.com/chapter/10.1007/978-0-387-47321-5_1

Collaborative Design Approach in Product Design and Development

Abstract

This chapter presents an integrated framework for distributed and collaborative environment, which could assist organizations to achieve integrated design goals. The proposed system emphasizes the integration of the software tools and the resources involved in the design process to collaborate the geographically dispersed design teams and vendors. The advancement in information technology (IT) is the driving force for the development of this environment. Also, the early participation of vendors in the design process is considered critical in order to improve the product quality and reduce the development cycle time.

Advances in IT have enabled designers to more effectively communicate, collaborate, obtain, and exchange a wide range of design resources during development [1]. Many manufacturing companies are publishing their product information on the Internet. The network-oriented design environment is a new design paradigm for product development. An integrative framework that enables designers to rapidly construct performance models of complex problems can provide both design insight and a tool to evaluate, optimize, and select better alternatives. Furthermore, a design problem constructed from modeling components made available over Internet might facilitate the collaborative development of analytical system models in addition to the exchange of design information. A well-defined integrated model will predict the required product properties and evaluate alternative solutions in order to meet the defined design objectives and performances.

Key to the analysis of any problem is the identification of what functions are performed and the relationships between them [18]. A collaborative engineering development process includes a set of activities and functions arranged in a specific order with clearly defined inputs and outputs. Each activity in the process will take a set of inputs and transforms it into an output of some value. The process is considered efficient, when the output of the process satisfies the general customer and product requirements and meets management objectives and cost. New technologies and tools along with advancement in IT are helping these organizations in several ways [2, 17]. However, there is no established generic implementation model for wide range of industries.

Software vendors may provide “custom” software packages for individual firms. Different industries have different product development strategies, which demand a generic framework that will help them collaborate efficiently irrespective of their product, organizational structure, and/or geographical location. Two of the more important elements in this changing environment are increased product sophistication and variation. Minimizing the total costs and being quick to develop and market new products is the key for survival. Product development is a complex process requiring expertise from several fields. This will demand integrating the diverse functional areas of an organization on a common platform [22].

In this chapter, an integrative framework that would enable the design teams rapidly construct performance models of complex design problems is presented. This framework can provide both design insight and a tool to evaluate, optimize, and select better alternatives. Interaction between the elements at every level of design is a critical issue. The framework should not be limited only to internal function integration but it should also consider the external functions such as vendors. The vendors have precise and detailed knowledge for their items. This expertise should be incorporated in the main development system to ensure and optimize the product as a complete system. The templates for different processes and/or procedures should be designed systematically to assist in evaluating and optimizing the design alternatives through proper integration and analysis.

Reference

Albrecht R. and Nicol N. (2002), Microsoft Access Projects with Microsoft SQL server, Microsoft Press.

Agnar G., Harry B., and Mariano C. (2004), The implementation process of standardization, Journal of Manufacturing Technology Management, Vol. 15, No. 4, pp. 335–342.

Bhandari V. (2000), Design of Machine Elements, Tata-McGraw Hill Publications.

Borland N. (1997), DOME—MoDeL Language Reference, MIT, Cambridge, MA.

Charles N. (2002), New type of standard for accessibility, designed to foster the competition and innovation of designers, developers, and project and business management, Behavior and Information Technology, Vol. 21, No. 3, pp. 155–169. 

Chen Y. and Liang ?. (2000), Design and implementation of a collaborative engineering information system for allied concurrent engineering, International Journal of Computer Integrated Manufacturing, Vol. 13, pp. 11–30.

Cutkosky M., Toye G., Leifer L., Tenenbaum J., and Glicksman J. (1993), SHARE: A Methodology and Environment for Collaborative Product Development, Post-Proceedings of IEEE Infrastructure for Collaborative Enterprise.

Deutschman D., Michels J., and Wilson C. (1975), Machine Design: Theory and Practice, Macmillan Publishing Co. Inc.
Dudley D. (1962), Gear Handbook: The Design, Manufacture and Applications of Gears, First Edition, McGraw Hill Book Company.

Eddy M. and Anthony D. (1999), Web-centric systems: A new paradigm for collaborative engineering, Journal of Management in Engineering, Vol. 15, No. 1, pp. 39–45.

Emilda S., Alex L., and Shaik ?. (2004), COVES: An e-business case study in the engineering domain, Business Process Management Journal, Vol. 10, No. 1, pp. 115–125.

Gupta A. and Wilemon D. (1998), Managing Global Product Development Teams, IEEE— 1998, 0-7803-5082-0.

Khalid H. (2001), Towards Effective Collaborative Design, Proceedings of HCI International, Mahwah, NJ.

Koufteros X., Vonderembse ?., and Doll W. (2001), Concurrent engineering and its consequences, Journal of Operations Management, Vol. 19, No. 1, pp. 97–115.

Lawry ?. (1997), SDRC I-DEAS Master Series Guide, SDRC Press.

Lee R., Tasi J., Kao Y., Lin G., and Fan K. (2003), STEP-based product modeling system for remote collaborative reverse engineering, Robotics and Computer-Integrated Manufacturing, Vol. 19, No. 6, pp. 543–553.

Manuel C., Pedro C., Carlos V., and Nuria A. (2002), Product data quality and collaborative engineering, IEEE Computer Graphics and Applications, Vol. 22, No. 3, pp. 32–42.

Pahl G. and Beitz W. (1996), Engineering Design: A Systematic Approach, Springer Publications.

Pahng F., Senin N., and Wallace D. (1998), Web-Based Collaborative Design Modeling and Decision Support, ASME-DETC 1998.

Park H. and Cutkosky ?. (1999), Framework for modeling dependencies in collaborative engineering processes, Research in Engineering Design, Vol. 11, No. 1, pp. 84–102.

Pawar K. and Sharifi S. (1997), Physical or virtual team collocation: Does it matter?, International Journal on Production Economics, Vol. 52, No. 1, pp. 283–290.

Rouibah K. and Caskey K. (2003), A workflow system for the management of inter-company collaborative engineering process, Journal of Engineering Design, Vol. 14, No. 3, pp. 273–293.

Senin N., Borland N., and Wallave D. (1997), Distributed Modeling of Product Design Problems in a Collaborative Design Environment, CIRP International Design Seminar Proceedings: Multimedia Technologies for Collaborative Design and Manufacturing.

Sethi R. and Nicholoson C. (2001), Structural and contextual correlates of charged behavior in product development teams, Journal of Product Innovation Management, Vol. 18, No. 3, pp. 154–168.

Srinivasan V., Williams S., Love J., and David B. (1997), Integrated product design for marketability and manufacturability, Journal of Marketing Research, Vol. XXXIV, No. 1, pp. 154–163.

Ulrich K. and Eppinger S. (2000), Product Design and Development, Second Edition, McGraw-Hill Publication.

Wallace, D. and Senin N. (1997), A Framework for Mixed Parametric and Catalog Based Product Design, MIT, CADLab.

Wallace D., Senin N., and Sferro P. (2000), Integrated design in a service marketplace, Computer-Aided Design, Vol. 32, No. 2, pp. 97–107.

Wang B. (Ed.) (1998), Concurrent Design of Products, Manufacturing Processes and Systems (Automation and Production Systems: Methodologies and Applications), Vol. 3, Gordon and Breach Science Publishers.
.. @+node:amd_yen.20130308214521.2427: *3* CD 第二週
Simple Groupware 安裝

兩種安裝模式:

1. local 主機安裝

2. 雲端 OpenShift 主機安裝
.. @+node:amd_yen.20130308214521.2428: *4* 有關 reading 與考試
期中考前有兩篇從教科書中選出的章節, 希望學員能夠充分了解內容的涵義, 由於是英文的資料, 因此至少要能夠先將單字篩選出來, 進行字意了解, 然後再套進基本的字句解析, 接著則是"希望"學員經過多次閱讀後, 能夠了解段落涵義, 最後則是了解該章節所點出與協同產品開發有關的基本概念與內容.

至於教學內容的評量, 則是希望將章節內容以閱讀的方式轉為 mp3 語音, 考試時則以撥放相關內容的英文 mp3 檔案, 以單選題或複選題讓學員於線上考試作答, 以測試學員是否理解章節中的英文內容.

由於協同產品設計過程, 若需於線上直接透過英文與其他研發團隊進行溝通, 許多的對話與反應幾乎都必須是及時進行, 因此利用 mp3 的英文語音來訓練機械設計工程師的協同設計流程, 應該是合理的流程.

此外, 將教科書的英文章節轉為 mp3 語音檔案, 也是希望能夠將檔案放在手機中, 可以隨時以耳機練習英文聽力, 希望能降低學員對於閱聽英文對話的恐懼與障礙.

協同產品設計實習前半段教科書內容的 mp3 朗讀: http://cae.mde.tw?download=cdmp3.7z
.. @+node:amd_yen.20130308214521.2429: *4* Simple Groupware 管理
兩種身分: 管理者與一般使用者

管理者權限

如何讓使用者登入 sgw:

採用 IMAP 進行 user authentication, 設定讓 Gmail

進行登入認證

.. code-block:: none
    :linenos:

    1. main menu - > change settings
    
    Authentication Mode 選擇 IMAP
    
    Host: 填入 imap.gmail.com:993:ssl
    
    並且勾選 下方的
        
    Enable automatic user creation
    [htaccess, NTLM, LDAP, IMAP, SMTP]
    
    讓系統在使用者登入時能夠建立對應帳號.
    
    設定修改後, 按最下方的 Save 後, 登出管理帳號.
    
    以 gmail 帳號與密碼登入 Simple Groupware
    
    例如:
    
    myaccount@gmail.com 作為帳號
    然後輸入與此 gmail 帳號對應的密碼
    
    就可以利用 Gmail 的 IMAP server 認證, 讓使用者登入 sgw 並且由系統建立一個對應帳號, 並且出現下列訊息.
    
    Notification
    
    Item successfully created. (101)
    
    Processing modules/core/users.xml ...
    
    Folder structure created. ( / Personal folders / 2012c1@mde.tw / )
    
    Folder created. (../simple_store/home/2012c1@mde.tw/)
    
    Item successfully created. (101)
    
    2. 當所有的組員完全帳號建立後, 就可以修改設定, 讓 anonymous 帳號無法登入, 並且取消
    
    Enable automatic user creation
    [htaccess, NTLM, LDAP, IMAP, SMTP]
    
    自動建立對應帳號的設定, 如此就只有與專案執行相關的組員可以利用 IMAP \
    模式登入協同系統, 管理者 (admin) 則依然透過 Simple Groupware 資料庫中的帳號設定登入系統.
.. @+node:amd_yen.20130320201815.1573: *4* Simple Groupware 系統研究
1. 要逐一檢視 sgw 的原始碼並不容易, 因為核心碼的行數就有 3 萬行, 而導入的其他開源程式碼更有超過 15 萬行, 因此不僅需要花時間, 而且要很有耐心.

http://en.wikipedia.org/wiki/Simple_Groupware

sgw 是一套少數在安裝階段, 便逐一在特定語系的選擇下, 直接將語系文件寫入 php 程式執行檔案中的套件, 好處是執行會比多語系查詢的模式快許多, 而壞處則是無法在安裝之後彈性更改語系, 更改語系等同重新安裝, 因此若需要更改語系, 必須要先確認是否累積一段時間後的資料內容, 可以無縫轉到其他語系模式下繼續運行.

這是一個值得嘗試的語系轉換機制, 但是若能始終在英文語系下工作, 則可兼顧到全球各語系協同成員的整體需求, 因此若無法在安裝英文版後無法正確轉換到其他語系, 管理者還是可以回到英文模式下繼續運作.

bin

simple_store

simple_cache

假如檢視 sgw 在手動操作下, 系統程式對於資料庫中資料表與欄位資料的交互處理情況, 可以得知希望利用外部程式直接編寫資料庫中的內容, 機會是不太大的, 因為其中包含許多沒有明說的內部運作機制, 而且在 1.0 正式到來之前, 各版次的架構變化仍然很大,  目前就導入中小企業使用上著力較深的部門仍在系統模組的中文化, 以及自行編寫協同設計模組的能力培養上.

就 sgw 的操作使用, 每週都必須備份程式碼與資料庫內容, 並且不定期進行各種壓力測試, 以其在正式導入商用之前, 能夠徹底掌握各項相關運作.

2. sgw 的系統設計, 可以讓管理者自由轉移主機, 而無需因轉移主機而修改設定檔內容.

sgw 的系統包括所有 php 檔案, 使用者上傳檔案, 以及資料庫檔案等三大類, 轉移主機時, 必須同時移動實體檔案 (php 與 上傳檔), 以及資料庫檔案.

轉移主機時必須特別注意上傳檔在不同操作系統的問題, 目前已知, 當上傳中文命名檔或特殊長檔名的檔案, 會造成轉移主機時的問題. 
.. @+node:amd_yen.20130308214521.2430: *4* SpreadSheet 的應用
由以下的資料格式出發

.. code-block:: none
    :linenos:
    
    dbCells = [
    
      [0,0,"1",""], // A1
      
      [1,0,"4",""], // B1
      
      [3,0,"=graph(\"line\",\"測試\",A1:A3,B1:B3,\"x 軸\",\"y 軸\")",""], // D1
    
      [0,1,"2",""], // A2
      
      [1,1,"1",""], // B2
    
      [0,2,"3",""], // A3
      
      [1,2,"2",""], // B3
      
    ];

利用程式方法, 建立 0~2PI 的 Sin 與 Cos 繪圖
.. @+node:amd_yen.20130308214521.2431: *4* sgw 版本
先前附在 portableKMOL 的 sgw 無法搜尋, 且中文試算表無法使用, 因此在

https://github.com/chiamingyen/sgw745 

上傳新的版本.
.. @+node:amd_yen.20130309155804.1709: *3* CD 第三週
利用 Python 程式進行 Sin 與 Cos 函式的運算, 然後套進 Simple Groupware 的 Spreadsheet 模組資料格式, 以便能夠利用網際協同群組中的各組員檢視結果.

以下為 Sin 與 Cos 的繪圖程式:

.. 請注意: 以下採用程式檔案直接載入文書內容的模式取得對應的程式原始碼.

.. literalinclude:: ../cd/spreadsheet.py
    :language: python
   
將上列程式輸出結果, 以轉貼方式複製到 Simple Groupware Spreadsheet 中的 JS 資料介面, 然後按下 Load, 就可以顯示出 Sin() 與 Cos() 的繪圖結果.

另外一種將資料傳入 Simple Groupware 的方式為: 將運算結果以 URL 方式載入.

Simple Groupware graphviz 模組的中文化:

1. 取得 fireflysung.ttf, 放入 V:\extensions\sgw\ext\tools\bin_win32\graphviz\bin 目錄下

2. 利用下列 graphviz 就可以顯示出中文化的流程圖.

.. code-block:: none
    :linenos:
    
    digraph G {
    node[fontname="使用內定字型"]
    "在 Projecs 目錄下\n建立一個專案\n並指定專案參與人員"->
    "系統會採\n project_專案名稱 \n自動建立對應群組"->
     "使用者可以由\n Personal projects \n目錄中進入檢視相關資料"->
    "專案參與人員\n在其他目錄下\n所建立的相關資料\n
    只要綁上該專案名稱\n 相關資料就會統一彙整到\n 
    Personal projects 所屬資料分類下"
        }
    
.. code-block:: none
    :linenos:
    
    digraph G {
    node[fontsize = 14,fontname = "內定字型"]
    開始->執行->結束
    }

Simple Groupware 在 `mongoose web server`_ [#]_ 環境下執行, 使用上傳檔案模組 (files) 時會發生 ajax 的錯誤, 目前無法解決, 而 nginx 在 nginx.conf 設定中, 增加 client_max_body_size 的設定, 就可以正常上傳檔案 [#]_ .

.. [#] 目前單獨使用 mongoose web server 的情況只剩下 Python3 Tutor 的 cgi-bin 執行. 
.. [#] 這裡限制最大上傳檔案為 50MB.

.. code-block:: none
    :linenos:

    http {
        include       mime.types;
        default_type  application/octet-stream;
        client_max_body_size 50M;
        
只是在上傳"中文命名"檔案時, 會發生 php 的 basename() `截斷 sgw 中文檔名問題`_, 即使在 simple_store/config.php 中設定 setlocale(LC_ALL, 'en_US.UTF8'); 仍然無法解決, 目前已知在"中文命名檔"之前加上一個"-", 可以暫時解決問題.

.. _mongoose web server: https://github.com/valenok/mongoose

.. _截斷 sgw 中文檔名問題: http://sourceforge.net/p/simplgroup/support-requests/344/

以下則為 Simple Groupware 程式執行的流程, 若希望針對上述問題全面解決, 必須同時面對 php 與 javascript 交互處理的問題:

    1. 需要 simple_store/config.php 與 bin/core/functions.php 以及 smarty class 進行啟動.
    
    2. 以 bin/core/functions.php 中的 sys_build_output() 將套入 main.tpl 後的頁面, 以 echo 的方式送回瀏覽器, 其中的 $output 最前方放入處理程式所花的時間.
    
    3. simple_cache 目錄中則分門別類存放各種執行程式所需的暫存檔案, 若相關設定或程式更新, 則必須要先清除對應的 cache 檔案, 否則會依照舊的內容執行.
    
    4. 上傳檔案的檔名利用 bin/core/functions.php 中的 sys_build_filename() 進行命名, 某些中文長檔名就是因為此一函式的處理造成實際存檔的名稱過長, 超過 256 個字元而造成無法正確存檔, 因此若必須使用檔名很長的中文命名, 則要修改 sys_build_filename() 函式.

其次, 上傳檔案實際執行程式為 bin/upload.php, 必須考量 config.php 中 INVALID_EXTENSIONS 所不允許上傳的副檔名.

上傳檔案過程的 ajax 則由 bin/core/classes/ajax.php 中的 upload_file($filename) 函式負責處理, 並且透過 bin/ext/js/functions_edit.js 中的 handle_upload(item_name, max_file_size, max_file_count, files, input_id) 進行呼叫.

經過上述 Simple Groupware 執行流程的追蹤, 終於找到實際解決"中文命名檔案"上傳問題的方案.

以下為 ajax.php 檔案的修改:

.. code-block:: php
    :linenos:
    
    // setlocale() 必須放到 V:\extensions\sgw\bin\core\classes\ajax.php 第 242 與 243 行, 才會有作用
    static function upload_file($filename) {
      if (empty($filename) or empty($_SESSION["username"])) exit("Upload failed");
      if (strpos($filename,"://")) {
        $target = sgsml::getfile_url($filename);
      } else {
        $target = sgsml::getfile_upload($filename);
      }
      if ($target=="" or !file_exists($target)) {
        exit("Upload failed: Failed to write file to disk.");
      }
        // 為了避免中文命名檔案前面被斷頭的問題
        setlocale(LC_ALL, 'en_US.UTF8');
      return array("tmp_path"=>$target, "basename"=>modify::basename($target), "filesize"=>modify::filesize($target));
    }
    
截至目前使用 Simple Groupware 的檔案上傳與中文處理結論:

1. 目前的 mongoose web server (3.7版) 仍然無法正確處理 Simple Groupware 的 ajax 檔案傳送, 目前採 nginx 在 ssl 模式下運作.

2. 中文命名檔案的處理已經有理想方案, 亦即在 V:/extensions/sgw/bin/core/classes/ajax.php 中的 upload_file() 函式中, 加上 setlocale(LC_ALL, 'en_US.UTF8');

3. 為了讓 nginx 處理 Simple Groupware 的解譯, 在 nginx.conf 加入 ssl 的 server 設定, 完整的設定如下:

.. code-block:: none
    :linenos:

    worker_processes  1;

    events {
        worker_connections  1024;
    }
    
    
    http {
        include       mime.types;
        default_type  application/octet-stream;
        client_max_body_size 50M;
    
        #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
        #                  '$status $body_bytes_sent "$http_referer" '
        #                  '"$http_user_agent" "$http_x_forwarded_for"';
    
        #access_log  logs/access.log  main;
    
        sendfile        on;
        #tcp_nopush     on;
    
        #keepalive_timeout  0;
        keepalive_timeout  65;
    
        #gzip  on;
    
        server {
            listen       89;
            server_name  localhost;
    
            #charset koi8-r;
            charset utf-8;
    
            #access_log  logs/host.access.log  main;
    
            location / {
                root   V:/www/cmsimpleSpring2013;
                index  index.html index.htm index.php;
            }
    
            #error_page  404              /404.html;
    
            # redirect server error pages to the static page /50x.html
            #
            error_page   500 502 503 504  /50x.html;
            location = /50x.html {
                root   html;
            }
    
            # proxy the PHP scripts to Apache listening on 127.0.0.1:80
            #
            #location ~ \.php$ {
            #    proxy_pass   http://127.0.0.1;
            #}
    
            # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
            #
           # location ~ \.php$ {
              location ~ ^(.+\.php)(.*)$ {
                root   V:/www/cmsimpleSpring2013;
                fastcgi_split_path_info ^(.+\.php)(.*)$;
                fastcgi_pass   127.0.0.1:9000;
                fastcgi_index  index.php;
            #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
            #    orig    fastcgi_param SCRIPT_FILENAME ./html/$fastcgi_script_name;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                fastcgi_param PATH_INFO $fastcgi_script_name;
                include        fastcgi_params;
            }
        
        # for perl
        #location ~ \.pl$ {
        #gzip off;
        #include /etc/nginx/fastcgi_params;
        #fastcgi_pass  127.0.0.1:8999;
        #fastcgi_index index.pl;
        #fastcgi_param  SCRIPT_FILENAME  /srv/www/www.example.com/public_html$fastcgi_script_name;
        
            location /django{
                fastcgi_pass 127.0.0.1:8088;
                fastcgi_param SERVER_NAME $server_name;
                fastcgi_param SERVER_PORT $server_port;
                fastcgi_param SERVER_PROTOCOL $server_protocol;
                fastcgi_param PATH_INFO $fastcgi_script_name;
                fastcgi_param REQUEST_METHOD $request_method;
                fastcgi_param QUERY_STRING $query_string;
                fastcgi_param CONTENT_TYPE $content_type;
                fastcgi_param CONTENT_LENGTH $content_length;
                fastcgi_pass_header Authorization;
                fastcgi_intercept_errors off;
                }
            # deny access to .htaccess files, if Apache's document root
            # concurs with nginx's one
            #
            #location ~ /\.ht {
            #    deny  all;
            #}
    # hide index.php for Yii
    #location /yii/demos/blog {
    #try_files $uri /yii/demos/blog/index.php;
        }
    
    server {
        server_name localhost;
        listen 9443;
        ssl on;
        ssl_certificate V:/certificates/ssl_cert.pem;
        ssl_certificate_key V:/certificates/ssl_cert.pem;
    
            location / {
                root   V:/www/cmsimpleSpring2013;
                index  index.html index.htm index.php;
            }
    
              location ~ ^(.+\.php)(.*)$ {
                root   V:/www/cmsimpleSpring2013;
                fastcgi_split_path_info ^(.+\.php)(.*)$;
                fastcgi_pass   127.0.0.1:9000;
                fastcgi_index  index.php;
            #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
            #    orig    fastcgi_param SCRIPT_FILENAME ./html/$fastcgi_script_name;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                fastcgi_param PATH_INFO $fastcgi_script_name;
                include        fastcgi_params;
            }
        }
    
    server {
        server_name localhost;
        listen 6443;
        ssl on;
        ssl_certificate V:/certificates/ssl_cert.pem;
        ssl_certificate_key V:/certificates/ssl_cert.pem;
    
            location / {
                root   V:/extensions/sgw;
                index  index.html index.htm index.php;
            }
    
              location ~ ^(.+\.php)(.*)$ {
                root   V:/extensions/sgw;
                fastcgi_split_path_info ^(.+\.php)(.*)$;
                fastcgi_pass   127.0.0.1:9000;
                fastcgi_index  index.php;
            #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
            #    orig    fastcgi_param SCRIPT_FILENAME ./html/$fastcgi_script_name;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                fastcgi_param PATH_INFO $fastcgi_script_name;
                include        fastcgi_params;
            }
        }
    }


.. @+node:amd_yen.20130316100629.1526: *4* Simple Groupware 上傳檔名
bin/core/functions.php 中的 sys_build_filename() 對於較長的上傳中文檔案名稱 ,經過轉換後, 會超過系統允許的 255 字元限制, 在 Linux 可以依照論壇中的修改因應, 但是 Windows 環境則必須限制中文檔案名稱的上傳.

.. code-block: php

    function sys_build_filename($filename,$table="") {
    //Yen 修正中文命名檔案轉成 sha1 造成檔案名稱過長的問題, 
    // https://groups.google.com/forum/?fromgroups=#!topic/simple-groupware/yD9CyH7CL7E
    // 在 Windows 只能要求使用較短的中文檔案名稱
      $filename = NOW."-".sha1(uniqid(rand(), true).uniqid(rand(), true))."--".urlencode(basename($filename));
      if ($table=="" or strpos($table,"_nodb_")) {
        return array(SIMPLE_CACHE."/upload/",$filename);
      }
    // 存入資料庫的檔案名稱在某些情況有誤, 但是存檔則是正確的檔名轉換, \
    因此判斷是 Javascript  ajax 轉換時出問題
      return array(SIMPLE_STORE."/".$table."/",$filename);
    }
    
在 Windows 環境使用 Simple Groupware 的相關限制:

    1. 建立使用英文命名的檔案上傳, 若真要使用中文命名檔案上傳, 建議在檔名之前一律加上"-" (dash), 以避免某些中文檔名無法上傳的問題 (即使已經利用 setlocale(LC_ALL, 'en_US.UTF8'); 設定試圖修正 php basename() 處理中文命名檔案的問題, 但是仍有部分特定中文檔案名稱無法正確被解讀, 目前懷疑是檔名經過 php 轉 ajax 時所產生的問題).
    
    2. 若真要使用"-"+中文命名檔案, 也不可使用過長的檔案名稱, 否則會產生檔名過長無法上傳的錯誤.
.. @+node:amd_yen.20130310161901.1489: *3* CD 第四週
.. code-block:: python
    :linenos:

    # 執行以下程式時, 將滑鼠定在此內文的標題上, 然後按下 Ctrl+b
    '''
    c is the commander of the outline containing the script.
    g is Leo's leo.core.leoGlobals module.
    p is the presently selected position, the same as c.p.
    '''
    # p 為 position, subtree 為子節點, 下列程式會逐一列出子節點的 body text
    for p in p.subtree():
        g.es(p.b)
    
    # g 為核心全域模組, 取其應用程式的圖形介面, 並且執行 AskOkDialog 對話視窗
    g.app.gui.runAskOkDialog(c,"輸入密碼",message="請輸入網誌的密碼:",text='Ok')
    
    def getInput (event=None):
    
       stateName = 'get-input'
       k = c.k
       state = k.getState(stateName)
    
       if state == 0:
           k.setLabelBlue('Input: ',protect=True)
           k.getArg(event,stateName,1,getInput)
       else:
           k.clearState()
           g.es_print('你輸入的值為: %s' % k.arg)
    
    # 執行上述 getInput 函式
    getInput()


.. @+node:amd_yen.20130317094520.1540: *4* 四次考試的 mp3 內容
協同產品設計實習前半段教科書內容的 mp3 朗讀: http://cae.mde.tw?download=cdmp3.7z
.. @+node:amd_yen.20130316100629.1537: *4* @url SGW 最新原始碼
https://github.com/simplegroupware/Simple-Groupware

從這裡可以發現 0.8 版正在打造中, 0.8 alpha 已經重新更動程式安裝架構與下拉式功能表:
    
    1. 大大簡化安裝流程, 過去從 src 加載語系資料, 並且複製到 bin 目錄的架構已經變更, bin 目錄不存在, 應該是採一組程式碼讀取語系資料的方式執行.
    
    2. 管理者功能一分為二, home 為原先的更改設定選單, 而 settings 獨立存在, 全部都在下拉式選單第一層, 操作更加簡潔.
    
    3. 目前為 alpha 版, spreadsheet 在英文語系設定下會將圖檔存在 V:\, 顯然仍有錯誤尚未修改.
    
    4. 許多 0.8x 預計新增的功能都還未加入, 應該是先整理基本架構, 之後才會一一納入.
    
    5. 移除 SSL 設定模式, 建議全時在 SSL 模式下運作.
    
    6. Webdav server 功能已經移除, 建議採用網際硬碟 (google drive 或 dropbox) 進行 offline 同步), 實際操作流程仍有待確認.
.. @+node:amd_yen.20130314194325.1511: *4* Simple Groupware 郵件設定
Simple Groupware 可在執行專案過程利用電子郵件通知參與專案的相關人員, 因此除各組員必須提供與帳號相關的電子郵箱外, 管理者必須設定寄信用的 email identity.

Organisation -> Mail identities

Id: admin
E-mail: 管理者電子郵箱
Name: admin
SMTP: username:password[:port[:tls]]@hostname

若 username 與 password 包含 @, 則必須以 %% 取代

若 username 與 password 包含 : 則以 == 取代

寄信郵件設定範例:
    
    1. 若希望使用 Gmail 電子郵箱: myemail@gmail.com 且密碼為 mypassword 來設定寄信, 則
    SMTP 欄位必須填入: myemail:mypassword:465:tls@smtp.gmail.com
    
    2. 若希望使用 Gmail 電子郵箱: myemail@gm.domain.name 且密碼為 mypassword 來設定寄信, 則
    SMTP 欄位必須填入: myemail%%gm.domain.name:mypassword:465:tls@smtp.gmail.com
.. @+node:amd_yen.20130316100629.1532: *5* 用戶管理
完成安裝後, 就可以利用總管理者的帳號登入系統. 內建的總管理者帳號為 admin, 密碼也是 admin, 但是若在安裝過程已經進行設定, 系統就不會採用內建的總管理者帳號密碼.

若使用者連結到完成安裝的系統, 將會以訪客 (anonymous) 的身份進入系統. 假如不希望使用者以無法辨識身份的訪客帳號進入系統, 則必須以管理者登入後在

main menu - administration - Change setup settings 中去除

Enable anonymous access 選項的勾選.

總管理者登入之後, 若希望建立零星的用戶帳號, 可以進入

Workspace - Organization - Users 項下建立帳號.

使用者帳號至少三個字元, 而密碼至少 5 個字元, 並且要提供至少一個電子郵箱, 其餘欄位則為選項, 接著就是在帳號頁面設定 SMTP 寄信主機.

總管理者若忘記密碼, 則必須刪除 simple_store 目錄下的 config.php, 然後重新進行設定, 總管理者在 simple_sys_users 資料表中並沒有存入任何資料, 而是存在 config.php 中.

新建帳號登入後, 系統會轉到該帳號下的個人目錄區, 也就是 Workspace - Personal folders, 假如要改變此一轉址, 則必須在 Users 目錄下的帳號頁面, 於 Home folder id 中加以設定.

假如要在個人帳號區內使用 IMAP 收信則必須要設定對應的 Mountpoints.

假如登入後希望改變帳號所對應的密碼則進入Main menu - Change settings 中修改, 而與帳號對應的 status 更改也是在 Change settings.

總管理者若刪除用戶, 則該用戶資料會被丟入 trash 區, 之後使用者可以利用剪下複製的方式回復該帳號, 也可以永久刪除該用戶資料.

使用剪貼的方式回復目錄資料後, 總管理者必須手動設定該目錄中的各項使用權限, 系統並不會自動回復原先的相關權限設定.

一個使用者帳號, 可以分別加入不同的群組 (group), 但是群組中則不可以加入群組, 以免產生後續管理上的問題.
.. @+node:amd_yen.20130316100629.1533: *5* 群組管理
有關 Simple Groupware 的群組:

- 總管理者可以在 Workspace - Organization - Groups 中建立群組.
    
- 刪除的群組會被視為暫停使用, 該群組目錄資料則會被移到 Workspace - System - Trash. 總管理者之後可以採用剪貼方式回復或永久刪除該群組. 已經被移到 Trash 區的群組, 總管理者仍然可以處理與該群組有關的設定, 因為總管理者具有進入 Trash 區查閱該群組資料.
    
- 專案 (project) 與部門 (department) 的內建群組, 建立一個部門後, 以 department_群組名稱 進行命名的群組會自動建立, 並且將該部門的所有成員納入該自動建立的群組之中. 而列在個人部門中的檔案, 該部門人員可以進入讀寫該部門所建立的各種資料.
    
- 而建立一個新專案後, 以 project_專案名稱 命名的群組也會自動建立, 任何屬於 internal participants 中的成員則會自動被歸屬到該群組中. 而且該群組成員可以讀寫在個人專案下屬於該新增專案目錄下所屬的相關資料.
    
- 唯一必須特別注意的是, 管理者 (manager) 或外部參與專案或部門的成員, 並不會對於目錄或群組成員的擷取屬性有任何影響, 亦即, 設定一個新專案時, 列名為管理者 (manger) 也必須加入該專案的 internal participants, 而各個列名外部參與者的帳號則沒有該專案所屬的各項存取權.
    
- 群組成員屬性只有在該帳號登入後, 才會刷新資料, 亦即才會反映出最新的屬性修改, 換句話說, 若某一位成員的屬性被修改後, 管理者或許必須刷新所對應的 session 資料, 並且強制該帳號重新登入系統, 該群組或專案的新設定才會生效, 否則系統仍然以舊 session 中的資料為准.
.. @+node:amd_yen.20130314194325.1512: *5* 建立專案
在 Simple Groupware 中建立專案步驟:

先建立專案目錄:

- 以管理者身分(admin) 登入系統後, 在樹狀結構下方點選 options.
    
- 樹狀結構上方會出現兩個區域, 亦即 Rename folder 與 New folder 等兩區.
    
- 在 New folder 區中填入專案目錄建立的相關資料.
    
- Name: 輸入專案目錄名稱
    
- Module: 選擇 Projects
    
- Icon: 選擇 Default 或其他圖示
    
- Description: 輸入專案目錄說明
    
- 若要將此專案目錄放在列表最前頭, 則勾選 First in list.
    
- 完成後, 按下 OK

接著在專案目錄下, 建立與產品設計相關的專案計畫.

- 點選上列所建立的專案目錄.
    
- 選擇右上方的 New, 準備建立新的專案計畫.
    
- Name: 輸入專案計畫名稱
    
- 選擇 Participants (參與專案計畫的成員)
    
- 選擇 Manager: 選擇右方的分組成員, 然後按下 << 箭頭, 移入左方的表單中.
    
- 選擇 Participants (internal): 由右方分組成員選擇要加入專案計畫的人員.
    
- 選擇 Scheduling (執行期限)
    
- 選擇專案起始日期與預定結束日期.
    
- 按下 Save 就可完成專案計畫的建立.
    
完成上述專案計畫建立後, Simple Groupware 會自動建立對應的群組, 並且以 project_專案名稱 加以命名.

此後, 參與該專案計畫的成員登入系統後, 就可進入 Personal projects 目錄中檢視各種與該專案有關的資料.

參與專案的成員在其他目錄建立相關資料時, 只要綁上該專案名稱, 資料就會統一彙整到 Personal projects 所屬資料分類下, 其餘參與專案之組員也可以根據專案權限的設定, 在相關 Personal project 所屬的目錄下看到這些與專案執行相關的協同資料.

其他與建立專案相關的說明:
    
    1. 先確認所有組員可以登入系統, 其中可使用的認證方式, 　包括, mysql, ldap, imap 等.
    
    2. 在資料區建立一個 project folder, and create related project under that project folder.
    
    3. As the administrator create one project, participants can be added into the project, sgw will automatically create related group named project_project_title, and all participants will added into this group.
    
    4. All participants will grant read and write rights for the associated project, and related project template will appear under all participants' personal folder.
    
    5. The project folder which uses to group certain project definition need to let all project participants to read and write right can be directed to admin_project group as the default sgw system setting does.
.. @+node:amd_yen.20130314194325.1513: *5* 專案管理
所謂專案, 就是指在一定時間內, 一定資源支撐下, 由特定群組依照共同目標所擬定完成的任務規劃.

專案執行過程中, 群組中的成員各司其職, 必須在約定期限內依照特定的工作流程完成特定工作項目.

What is Project Management?

More specifically, what is a project? It's a temporary group activity designed to produce a unique product, service or result.

A project is temporary in that it has a defined beginning and end in time, and therefore defined scope and resources.

And a project is unique in that it is not a routine operation, but a specific set of operations designed to accomplish a singular goal. So a project team often includes people who don't usually work together – sometimes from different organizations and across multiple geographies.

The development of software for an improved business process, the construction of a building or bridge, the relief effort after a natural disaster, the expansion of sales into a new geographic market — all are projects.

And all must be expertly managed to deliver the on-time, on-budget results, learning and integration that organizations need.

Project management, then, is the application of knowledge, skills and techniques to execute projects effectively and efficiently. It's a strategic competency for organizations, enabling them to tie project results to business goals — and thus, better compete in their markets.

It has always been practiced informally, but began to emerge as a distinct profession in the mid-20th century. PMI's A Guide to the Project Management Body of Knowledge (PMBOK® Guide) identifies its recurring elements:

Project management processes fall into five groups:

- Initiating
    
- Planning
    
- Executing
    
- Monitoring and Controlling
    
- Closing

Project management knowledge draws on nine areas:

- Integration
    
- Scope	
    
- Time
    
- Cost
    
- Quality
    
- Procurement
    
- Human resources
    
- Communications
    
- Risk management
    
All management is concerned with these, of course. But project management brings a unique focus shaped by the goals, resources and schedule of each project. The value of that focus is proved by the rapid, worldwide growth of project management:

as a recognized and strategic organizational competence

as a subject for training and education

as a career path
.. @+node:amd_yen.20130316100629.1528: *5* @url 專案使用案例
https://groups.google.com/forum/?fromgroups=#!topic/simple-groupware/m5R3IzniasA

以下為論壇中,  某一用戶針對 Simple Groupware 在專案管理項目, 實際使用的基本流程描述.

我將專案模組用在建築事務所. 其中大約有 35 個專案, 使用電子郵件匣作為收信, 任務, 聯繫工作, 還有專案日誌等資料存檔用.

基本上由一位管理者指派任務與聯繫工作. 另一位管理人則待在辦公室中, 透過列表得知有哪些任務指派給他, 並且依照所指定的任務, 打電話給相關人等.

亦即, 一有新任務, 管理者就會建立相關專案內的任務指派, 並將該任務交付給相關負責人.

而在該任務負責人的個人資料匣中, 就會有收納交付給他的所有任務列表. 由於各任務會依照不同專案分類, 因此在他的任務資料匣中, 也會依照不同專案進行任務的分類.

此外, 各任務與聯繫工作也分別掛在不同類別中, 這些類別主要是用來建立特定列表. 其中一個類別為"待批准" (approval of bill), 因此在相關人等的個人資料匣中, 就會有一個列表集中在"待批准"的類別中, 等待其在指定日期之前必須完成審核批准.

而這些待批的文件, 會按照日期排序. 因此相關人等不僅從待批文件匣, 就可以得知期間內所必須完成的工作, 一點都無法偷懶.

目前在專案模組仍然缺乏的功能, 則是針對不同專案成員賦予其各自不同角色的權限, 目前的用法是將所有專案成員都視為相同角色.

爾後若能按照規劃加入企業資源規劃與計價模組, 將能讓專案管理模組的功能往上提升.
.. @+node:amd_yen.20130316100629.1529: *5* 目錄權限
每一個目錄的權限都可以單獨設定, 但是新增一個子目錄則會套用父目錄的相關權限.

目錄共有三個可以設定的權限:

讀取 (read), 寫入 (write) 與管理 (admin) 等三種, 只有對該目錄擁有管理 (admin) 權限的使用者, 可以對目錄 (及其子目錄) 設定所謂的 read, write 與 admin 權限, 總管理者則擁有所有系統內各目錄的管理權限.

有關目錄權限的設定, 必須使用 Folder 下拉式功能表中的 Rights: Show 或 Rights: Edit, 來檢視或更動相關目錄的權限設定.

假如要將目錄所設定的權限套用到所有該目錄項下的所有子目錄, 可以使用 Folder 下的 Apply rights to subfolders

除了管理目錄的權限外, 管理者也可以針對特定目錄設定容量管制 (quota), 設定的單位為 MB, 以其目錄與子目錄下所有上傳的檔案作為管理標的, 管理者可以在各目錄編輯欄位中的 Quota 項下加以設定.

且目錄的設定除了可以使用 read, write, admin 設定外, 也可以透過 View access (users) 與 View access (group) 進行更細化的擷取設定.

可採用的語法如下:

- View access (users)
    
- Syntax: ``|::|``
    
- Examples:
        
- ``|freebusy:read:anonymous|``
    
- ``|freebusy:read:anonymous|details:no_read:anonymous|``
    
- Group access (groups)
    
- Syntax: ``|::|``
    
- Examples:
        
- ``|freebusy:read:internals|``
    
- ``|freebusy:read:internals|details:no_read:guests|``
    
- Right: read, no_read, write, no_write 

採用上述 view 權限設定, 可以允許使用者建立或編輯內容, 但是無法 rename folder 或 建立子目錄.

View 權限不會影響其剪貼或刪除的操作.

允許 anonymous 擷取的目錄, 表示所有用戶 (若系統允許訪客進入, 則包括訪客) 都可以擷取該目錄, 但是若 anonymous 的擷取權被移除, 而且沒有其他用戶可擷取的設定, 則該目錄只有總管理者可以擷取.

總管理者登入後, 可以在 Main menu - administration 下的 Permissions  中檢視系統中所有目錄的相關權限設定.

目錄中各筆資料的權限設定:

- 除了可以透過目錄權限管理外, 可以針對目錄中的各筆資料進行權限管理, 而每一筆內容所能設定的權限:
    
- Full 權限表示對各筆內容擁有讀寫權, 並且內建為 anonymous 可以讀寫.
    
- Owner write 權限表示只有擁有人可以寫入, 而擁有人就是建立該筆資料的用戶.
    
- Owner read 權限表示只有永有人可以讀取, 而擁有人就是建立該筆資料的用戶.
    
- cms 與 files 模組都是採用 Full 內定權限, forum 模組則採用 owner write, timesheet 與 expenses 模組則採用 owner read.
    
- 通常各筆內容的權限設定, 在 new 資料表中的 permissions 頁面中加以設定.
.. @+node:amd_yen.20130316100629.1531: *5* Session 管理
Every user has a session where some settings are stored.

每一用戶登入後, 系統都會針對該連線進行所謂的"連線管理".

這些與用戶連線有關的管理資料可依目錄來存檔, 或依照目錄中的特定檢視權限來存檔, 或可檢視的模組為依據來存檔.

而每一連線以所謂的 session_id 來加以辨識, 並且與客戶的 IP 位址進行連結.

當使用者每次登入時系統就會重新建立此一 session_id

當使用者仍然在線時, 此一連線資料就會進行複製.

當登入的使用者超過 30 分鐘沒有任何動作, 原先的登入連線資料就會被視為無效, 使用者就必須重新登入.

有關連線內容所登錄的資料:

Global: username, client IP address, current folder, current theme, group memberships, read messages for POP3 / IMAP (max. 100), server id (used for creating unique dataset ids), allowed paths in the filesystem, form data tickets, cut-copy-paste data, folder states (open/closed), calendar day begin/end, tree type (folders, categories), tree page (if tree contains 100+ items), tree visible, data visible (calendar)

Per folder: calendar view (day, week, month, year, custom, all), calendar week start, calendar today / tomorrow, search string, selected page (datasets), current view, current folders (in categories mode)

Per folder+view: selected items, dataset filters

Per module+view: form finished (internal), dataset order/group by, dataset limit 

當使用者在畫面中按下 [All], 則連線資料就會刪除 folder+view, search string 與 folders 等相關資料.

若按下上方功能表中的 "Reset view" 則將移除與folder , module+view 有關的資料.
.. @+node:amd_yen.20130316100629.1535: *5* 取消 anonymous 登入
1. 以管理者身分登入系統

2. 進入上方的  Main Menu->Administration

3. 進入 Change Setup Settings

4. 取消下列兩設定的勾選

Enable anonymous access 	
Enable anonymous CMS

5. 設定存檔後, 必須透過帳號才可以登入系統.
.. @+node:amd_yen.20130316100629.1534: *5* 取消 too many wrong login 保護
在某些情況中, 若開放大批用戶使用測試中的 Simple Groupware, 很有可能在初學者的錯誤密碼輸入下, 導致在同一區段的管理者也無法登入系統, 可以將 bin/core/functions.php 中相關的保護程式暫時蓋掉, 就可以避開上述問題.

修改的程式碼如下:

.. code-block:: php

    $file = SIMPLE_CACHE."/ip/".str_replace(".","-",$ip);
    //if (file_exists($file."_3") and $trials = file_get_contents($file."_3") and strlen($trials)>3 \
    and filemtime($file."_3") > time()-900) {
     // $_REQUEST["logout"] = true;
      //sys_alert("Too many wrong logins. Please wait 15 minutes.");
    IMPLE_CACHE."/ip/".str_replace(".","-",$ip);
    //if (file_exists($file."_3") and $trials = file_get_contents($file."_3") and strlen($trials)>3 \
    and filemtime($file."_3") > time()-900) {
     // $_REQUEST["logout"] = true;
      //sys_alert("Too many wrong logins. Please wait 15 minutes.");
    if(0){
    //never happen
    }
.. @+node:amd_yen.20130316100629.1536: *5* @url 建立延伸模組
http://www.simple-groupware.de/cms/ExtensionManagerDeveloper
.. @+node:amd_yen.20130318140025.2834: *4* sgsML
使用 sgsML 建立網際程式的優勢:
    
- 無需處理網際欄位與背後資料庫欄位的連結
    
網際程式欄位類別 (types)
    
- sgsML 會自動配額欄位屬性, 建立對應的資料庫欄位
    
- sgsML 會採整合的方式, 處理各模組的搜尋、分類與檢視
    
- Syntax: Types are declared with simple_type="type" where type is one of int, float, text, password, id, hidden, select, wikiarea, codearea, textarea, htmlarea, checkbox, files, date, time, datetime ... for a complete list, see src/modules/schema/!examples.html.
    
欄位查驗 (validator)

- Syntax: To collect these functions in a central place, all validators are stored in core/functions_user.php and have a ``"validate_"`` prefix, e.g. "validate_is_numeric". To define a validator in a sgsML file, write <validate function="is_numeric"/> between the <field>-tags to validate the field with the function validate_is_numeric.
    
過濾器 (filter)

- 當使用者所要呈現在網頁上的資料, 與資料庫中所存放的內容不同時, 就必須使用過濾器.
    
- Syntax: To collect these functions in a central place, all filters are stored in core/functions_user.php and have a ``"modify_"`` prefix (because they modify data), e.g. "modify_dateformat". To define a filter in a sgsML file, write <filter views="all" function="truncate|20"/> between the <field>-tags to truncate the field to a maximum of 20 characters with the function modify_truncate. (The "views=all" parameter indicates that this filter is used with every view and will be discussed later) Other functions are included to help you to manage files, URLs, source code highlighting, etc.
    
store 與 restore (以 modify 為代號)

- 當使用者要存在資料庫的格式, 與 Simple Groupware 存值的標準處理法不同時, 就必須使用 store 與 restore.
    
- Syntax: To collect these functions in a central place, all store and restore functions are kept in core/functions_user.php and have a ``"modify_"`` prefix (because they modify data), e.g. "modify_datetime_to_int" converts a date given as string to a timestamp using integer representation. To define a store or restore function in a sgsML file, write <store function="datetime_to_int"/> and <restore function="dateformat||d.m.Y"/> between the <field>-tags to work with a date-field using the functions modify_datetime_to_int and modify_dateformat.
    
As told before, Simple Groupware already knows a type called "date". Therefore you only need restore/store functions when defining your date-field with type "int". Using type "date" this is done automatically for you.

資料來源 (以 select 為代號)

- 當欄位需要從特定資料選擇時, 採用資料來源.

- Syntax: To collect these functions in a central place, all data functions are kept in core/functions_user.php and have a ``"select_"`` prefix (because they select data), e.g. "select_dbselect" can be used to get data from the database.
    
To define a data construct in a sgsML file, write <data function="getmydata"/> between the <field>-tags to call the function "select_getmydata". Here dbselect is illustrated because it is the most common function to get data from the database.

``############################################################``

以下為 sgsML 的翻譯

sgsML Manual

sgsML 手冊  (simple groupware system markup language, 簡單群組系統標註語言)

2013 版 sgsML 的全文由 system 改為 solutions.

sgsML 手冊  (simple groupware solutions markup language, 簡單群組解決方案標註語言)

This is a small tutorial intended to help you to understand and develop web applications with sgsML.

這是一個協助使用者了解如何以 sgsML 語言開發網際應用程式的簡短教學.

Introduction

簡介

For many years now I'm writing web applications. Using PHP, Java, HTML, CSS, Javascript in combination with MySQL, Oracle, MsSQL, etc. always struggling with the complexity of web applications.

多年來,我一直在寫網際應用程式. 使用 PHP, Java, HTML, CSS, Javascript 與各種資料庫管理系統 MySQL, Oracle, MsSQL 等結合的方式, 讓網際應用程式的開發變得太過複雜.

Making changes in one point always influences many other parts of the program.
 
程式中的某一個點的改變會影響到程式的其他部分.

Often applications have several thousand lines of code (or even more).

經常這些應用程式有幾千行, 甚至更多.

Searching bugs or making daily changes like adding fields takes a lot of time because you need to test the whole application again.
 
尋找錯誤或經常必須更動的修改, 如增加表單欄位, 常會耗費許多時間, 因為整個程式必須要再測試一遍.

Since time is rare and deadline are sharp, it's time to optimize the common web application architecture.

因為時間經常不夠, 而且交期緊迫. 該是對常用的網際程式架構進行最佳化了.

Looking at bigger programs with many web applications, people start writing frameworks for common functions, managing users and parts of the user interface.

看看現今的許多大型的網際程式, 大家開始寫框架, 以處理常用的函式,管理用戶與使用者介面.

But these frameworks are often very limited in functionality or require too much time to learn.

但是, 這些框架要不是功能有限, 就是要花許多時間學習.

Using a small framework, you still need to deal with the full complexity of coding PHP, Java, HTML, etc.

即使採用小型框架, 還是得處理 PHP, Java, HTML 在程式方面所衍生的複雜度.

Moreover when working in bigger teams with a small framework, everyone writes its own specializations for his part.

尤有甚者, 若開發者眾多而卻採用小框架, 每個人都得決定各自的規範

This creates a unmanageable lack of consistency and increases costs for adding new functionality and fixing bugs.

將會因規範不一致而造成無法管理, 在開發新功能或除錯時, 成本就會跟著增加.

Therefore many companies create bigger frameworks to prevent programmers from getting too individual with their code.

因此, 許多公司建立大型框架, 以避免程式師建立太過個人化的程式碼.

With Java this is enforced using object-oriented programming (maybe also with PHP in the future).

對 Java 而言, (強制的要求)就是必須採用物件導向(未來 PHP 也是如此)

But I think that all these concepts are still too difficult to learn and understand in short time.

個人則認為這些概念仍然難以學習, 也不容易在短時間內能夠理解.

That's why I created a new programming language only intended for web applications.

這也就是為甚麼我要建立一種新的程式語言, 只用於網際程式.

You might ask: Hey, are you just creating another language with the intention to replace all the others?

或許有人會問: 哼, 難道要建立一種語言, 以取代其他語言?

The answer is no. The other languages are still used, but in a different way.

答案當然是: 不. 其他語言仍會被使用, 只不過以不同的方法加以應用.

This is important to understand, because today programming languages are so complex in usage and syntax, and this gets harder every year.

這點認知非常重要,因 為今天的程式語言無論是用法或語法, 都很複雜, 並且越來越複雜.

So what is different when working with sgsML?

那採用 sgsML 到底有甚麼不同?

You no longer need to be the super nerd of a programming language.

你不再需要是程式語言的專家(才能寫網際應用程式)

Now you can create good web applications without having learned programming for ten years.

不用學 10 年程式, 就能寫很棒的網際程式.

To build web applications with sgsML it is enough if you can write functions with 5 to 10 lines of code.

利用 sgsML 編寫網際程式, 只要用 5 到 10 行的函式程式就夠了.

You no longer write functions to store or load data in the database.

不再需要寫資料庫存取用的函式.

You no longer write GUI components just like HTML editors, spreadsheets or data selectors. How can this work?

不再需要寫使用者介面, 處理超文件編輯器, 試算表, 或者資料選單. 這到底要如何辦到?

The name sgsML already indicates a relation to XML.

從 sgsML 名稱就可以知道與 XML 有關.

To produce applications written in sgsML, XML version 1.0 has been chosen as the syntax for sgsML files.

利用 sgsML 編寫應用程式, 採用 XML 1.0 的格式語法.

This format is easier to read and interpret than many other formats (e.g. ini, CSV, CSS, etc.).

這種格式比其他格式(像 ini, CSV, CSS 等)更容易解讀.

As said before we are talking about sgsML files, meaning that one module (e.g. companies or appointments) is written into one file with the extension ".xml".

如前所述, sgsML 檔案就是一個模組(如,公司或約會模組), 寫成一個以 xml 為副檔名的檔案.

Types

型別

With sgsML a field is generally defined by its type.

在 sgsML 中, 欄位依照其型別加以定義.

This can be a text, a date, a number, etc. So when you define a field as text with sgsML, Simple Groupware creates this field in the database with the correct type and size in the corresponding table.

可以是文字, 日期, 數字等. 在 sgsML 中將欄位定義為文字型別, sgw 就會在資料庫中依照正確的型別與長度, 在資料庫中建立此一欄位.

Furthermore Simple Groupware already knows how to display this field (You only have to decide between a horizontal or a vertical view) including sorting, searching, etc. Additionally, forms to create or edit this field inside a dataset are created automatically for you.

而且, sgw 也會正確顯示此一欄位(只要決定水平或垂直檢視), 也會正確完成諸如排序, 搜尋等工作.
至於表單, 欄位編輯等資料處理, 也會自動完成.


Syntax: Types are declared with simple_type="type" where type is one of int, float, text, password, id, hidden, select, wikiarea, codearea, textarea, htmlarea, checkbox, files, date, time, datetime ... for a complete list, see src/modules/schema/!examples.html.

語法: 型別採 simple_type="type" 的方式宣告,其中 type 為 int, float, text, password, id, hidden, select, wikiarea, codearea, textarea, htmlarea, checkbox, files, date, time, datetime 中的一種, 完整的型別表列, 可以參考 src/modules/schema/!examples.html

Validators

驗證器

To be able to validate inputs made by a user you are able define functions that take care of this.

為能驗證使用者所提供的輸入, 就必須定義處理的函式.

E.g. you define a field as type text and also declare that it has to be validated with the two functions myvalidate1 and myvalidate2.

例如, 將欄位定義為文字型別, 必須要宣告, 以 myvalidate1 與 myvalidate2 等兩個函式加以驗證.

When a user wants to save a new dataset these two functions are called with the value of the field as a parameter and you only have to return a true/false-like answer to tell the program that the input is valid or not.

當使用者希望存一新的欄位資料時, 這兩個函式就會被呼叫, 並且以欄位變數加以驗證, 並且返回真/假的答覆, 來判定輸入是否有效.

You don't have to care about displaying the form again, mark the field with color red, display the error message to the user, etc.

您不再需要關注表單的顯示, 將必填欄位加上紅標, 或者傳回錯誤訊息給使用者.

This is all done for you automatically. These 2 functions are normally pretty easy and so small that even beginners can write them very quickly (they don't need any knowledge about the database, or HTML forms with heavy usage of Javascript).

這些事項都會自動完成. 而這兩個驗證用的函式, 通常非常簡單, 程式也很短, 就連初學者也都能夠快速上手 (不需要有資料庫或超文件表單的知識, 也不用寫一堆的 Javascript)

To make these functions smaller in size, you can define more than one functions for the validation of a field. This also helps you reuse functions (-> you automatically produce reusable code).

為了讓這些函示變得簡短, 可以設法針對一個欄位定義幾個函式. 不僅可以重用這些函式(->所建立的函式自然就能重用)

E.g. you want a field to be a positive number: Just write one function "is_numeric" that controls if the value is a number and a second one called "is_positive" that tests if it is positive.

例如, 若希望某一欄位為正數: 只要寫一個 "is_numeric" 的函式, 確保欄位為數字, 然後再編寫一個 "is_positive" 的函式來測試數值是否為正.

Of course, validating a German, English or ISO formatted date requires some work. Therefore a large number of functions for validating dates, strings and numbers is already shipped with Simple Groupware by default.

當然, 若要辨識德文, 英文或 ISO 格式的日期, 需要一些功夫. 因此這些用來辨識日期, 字串與數字的大型函式, 已經內建在 Simple Groupware 系統中.

Syntax: To collect these functions in a central place, all validators are stored in core/functions_user.php and have a ``"validate_"`` prefix, e.g. "validate_is_numeric". To define a validator in a sgsML file, write <validate function="is_numeric"/> between the <field>-tags to validate the field with the function validate_is_numeric.

語法: 為了將這些函式集中在一起, 所有的驗證函式都放在 core/functions_user.php 中, 並且以 ``"validate_"`` 作為開頭. 例如, "validate_is_numeric". 而在 sgsML 中定義驗證器, 則在 <field>-標註間寫入 <validate function="is_numeric" />, 就可以用來驗證該欄位所填入的內容, 是否為數字.

Filters

過濾器

Reading carefully you have read that Simple Groupware automatically displays your fields. But oftentimes you want to display fields differently from the value stored in the database. This is no conflict since you can define filters that change the value of a field before being displayed.

前面已經說過, Simple Groupware 會自動顯示欄位內容. 但有時希望顯示的內容, 可能與存在資料庫中的資料不同. 這時就可以使用過濾器的定義, 來改變欄位內容, 以便用來顯示.

This is elementary when working with dates. E.g. your database is configured for English dates, but you want to display them in German. Or you want to crop long texts to only show the first 20 words. Similar to validators you assign a function to the field that performs the filtering operation. This function takes the value of the field as input and returns the filtered value back to the program.

這在日期的使用上非常普遍. 例如, 資料庫中的日期設為英文格式, 而希望轉為德式習慣顯示. 或者將較長的內文, 只顯示前 20 個字等. 與驗證器類似, 可以指定一個過濾函式來處理資料過濾的操作. 此一函式以欄位值作為輸入, 而將過濾器處理過的資料傳回程式.

This is also very easy for beginners who don't need to care where the field is displayed or where the value comes from. As said Filters are similar to Validators, which means you can make the functions smaller in size by defining more than one function for the filtering process of a field. This also helps you reuse functions (-> you automatically produce reusable code).
E.g. you want a date field to be presented as a German date, take a look at the following code:

這樣的處理對初學者應該也會很簡單, 不用知道欄位資料會顯示在哪裡, 也不用知道資料從何而來. 就因為過濾器與驗證器相同, 因此也可以設計幾個小程式分別進行處理. 這樣就能重用這些函式 (所建立的函式自然就能重用)

<filter views="all" function="dateformat||m/d/Y"/>

This illustrates you the syntax of a filter and also the syntax for applying parameters to your functions (simply add a "|" to separate the parameters). To make working with dates easier for you, the function to format dates is already shipped with Simple Groupware.

這裡展示了過濾器的語法以及應用變數的方法, 在函式中, 只要加上"|" 就可以區隔變數. 為了讓日期的過濾更加簡易, Simple Groupware 已經內建這些函式.

The first parameter takes a verbal date modification, e.g. now + 1 month which returns the date increased by 1 month. The second parameter defines the format of the date.

第一個變數針對日期文字作了修改, 例如, now + 1 個月表示所傳回的月份會加上 1. 而第二個變數則定義了日期的格式.

An overview of the format parameters can be found at http://www.php.net/date. Examples dealing with modifications of dates are here: http://www.php.net/strtotime.

有關日期格式的說明, 請參考 http://www.php.net/date. 而處理日期顯示相關的範例則可參考 http://www.php.net/strtotime.

Syntax: To collect these functions in a central place, all filters are stored in core/functions_user.php and have a ``"modify_"`` prefix (because they modify data), e.g. "modify_dateformat". To define a filter in a sgsML file, write <filter views="all" function="truncate|20"/> between the <field>-tags to truncate the field to a maximum of 20 characters with the function modify_truncate.

語法: 為了將這些函式收集在一起, 所有的過濾器都存在 core/functions_user.php 中, 並且以 ``"modify_"`` 放在函式前面 (因為這些函式會修改 (modify) 資料), 例如, "modify_dateformat". 而在 sgsML 中則在 <field> 標註間, 寫成 <filter views="all" function="truncate|20"/> 可以透過 modify_truncate 函式, 將欄位資料裁截成只有 20 個字元.

(The "views=all" parameter indicates that this filter is used with every view and will be discussed later) Other functions are included to help you to manage files, URLs, source code highlighting, etc.

(而 "views=all" 變數表示此一過濾器會用在所有的 view, 隨後將會進一步討論) 其他還有包含處理 URLs 原始碼標示等之過濾器函式.

Note: for being neutral the date is stored in the database as timestamp (=an integer value).

注意: 為了在資料庫中置入中性資料, 日期以數字表示.

Store and Restore

資料存放與回復

Being as simple as possible, Simple Groupware automatically stores/reads data to/from the database. But sometimes you want to store inputs made by the user differently from the original value. E.g. the user types a date with a German formatting, but in the database it has to be a timestamp. Or you want to store URLs without a leading http:// in the database.

為了盡量保持簡潔, Simple Gropware  自動處理有關資料庫存/取與進/出相關動作. 但是有時使用者希望存入與使用者輸入不同格式的內容. 例如, 使用者在資料區輸入德式格式的日期, 但是資料庫則希望存入以數字表示的日期格式. 或者當存入資料庫 URLs 連結時, 不要放入 http:// 等.

Similar to validators and filters, functions used for storing the input get the value from the form as the first parameter and return the modified value back to the program. You don't have to care how the value is transferred from the form to your function. This makes things much easier, e.g. file uploads require big error handling routines that would boost up your code unnecessarily.

與驗證及過濾的動作相似, 用來處理輸入儲存的函式, 將表單資料當作第一變數, 將資料傳給程式, 使用者無需處理函式的進出. 可以簡單呼叫運用, 例如, 檔案上傳時需要較長的程式來處理錯誤辨識, 在這裡就不需要如此.

When modifying data before writing into the database, it is clear that there must be a re-transformation when being read from the database. This re-transformation is called restore. That's why there are restore functions, that are identical to filter functions regarding structure and functionality.

在資料存入資料庫前進行處理後, 就必須在資料取出時進行另一階段的回復處理. 而此一"再處理過程"就稱為"回復". 因此這些函式稱為回復函式, 就如同過濾函式資料處理流程.

Thus, writing store and restore functions is as easy as validators or filters. To reduce your functions in size you can also define multiple store or restore functions.

編寫儲存與回復函式的方法, 就如同驗證與過濾. 為了簡化個別函式, 可以將這些函式分成幾個儲存與回復函式.

Syntax: To collect these functions in a central place, all store and restore functions are kept in core/functions_user.php and have a ``"modify_"`` prefix (because they modify data), e.g. "modify_datetime_to_int" converts a date given as string to a timestamp using integer representation.

語法: 為了集中管理這些函式, 所有儲存與回復函式都放在 core/functions_user.php 中, 並且在函式前面加上 ``"modify_"`` (因為會修改資料), 例如, "modify_datetime_to_int" 就是將時間標示字串轉成整數的函式.

To define a store or restore function in a sgsML file, write <store function="datetime_to_int"/> and <restore function="dateformat||d.m.Y"/> between the <field>-tags to work with a date-field using the functions modify_datetime_to_int and modify_dateformat.

利用 sgsML 定義儲存與回復函式, 必須在 <field> 標註間, 寫成 <store function="datetime_to_int" /> 與 <restore function="dateformat||d.m.Y" />, 以便呼叫 modify_datetime_to_int 與 modify_dateformat.

As told before, Simple Groupware already knows a type called "date". Therefore you only need restore/store functions when defining your date-field with type "int". Using type "date" this is done automatically for you.

前面曾經提過, Simple Groupware 已經內建 date 型別. 因此只要在回復/儲存函式中將日期欄位定義成 "int" 就可以, 而 date 型別就會進行自動處理.

Note: The store functions are called after those used for validating the input.

注意: 儲存函式必須在輸入資料驗證後才進行呼叫.

Note: The restore functions are called before those used for filtering values from the database.

注意: 回復函式則在資料由資料庫取出後, 進行過濾後才進行呼叫.

Data sources

資料來源

Often it is necessary to build fields that already contain a set of data from which the user can choose the right values. E.g. this is a typical behavior for select-boxes. When writing an address book you might like to implement a field containing the gender of a person.

有時在建立欄位時, 可以提供一組資料, 以便讓使用者選取, 例如, 最常用的就是選項表. 當編寫通訊錄時, 可以建立一組性別欄位, 讓使用者選擇.

The preferred values are male and female. The type "select" defines a select-box in Simple Groupware. To define the preferred values you use the <data> construct in sgsML, e.g. <data values=``"male|female"``/> Using more than one value, separate each with a ``"|"``. You can also define more than one <data> construct inside the <field>-tag.

也就是提供男性及女性讓使用者選擇. 而在 Simple Groupware 中是透過 "select" 來定義這些選項表.

為了定義這些選項, 可以採用 sgsML 中的 <data> 結構, 例如, <date values=``"male|female"`` /> 若有更多選擇, 各別以 "|" 隔開. 也可以在 <field> 標註中使用多個 <data> 結構.

The method shown before is used for including static data. But in reality, these values are often dynamic and need to be fetched from a special data source. To get these values you can define a function that searches the right values for you and returns them as an array.

前面所用的選項欄位為靜態資料, 有時這些資料會從特定的資料來源取出, 成為動態資料. 這時可以定義一個函式, 搜尋取得所要的資料後, 以陣列的格式傳回.

You don't have to care about transferring these values to forms or to the relevant components, this is done automatically for you. Simple Groupware automatically calls your function when it needs the data. Instead of the values-parameter you use the function parameter to tell it what function to call. E.g. you want to show a list of companies in your address book or predefined values:

使用者不需要特別知道如何在表單中處理這些資料, 系統會自動處理. Simple Groupware 會自動呼叫所需的函式, 取得所需要的資料.  與其提供數值變數, 使用者可以指定函式變數, 例如, 要在通訊錄中列出對應公司列表.

<data function=``"dbselect|simple_companies|companyname,companyname||companyname asc|10"``/>

<data values=``"male|female"``/>

To get these values you call the function dbselect which selects data from the database. To reduce this list we only want 10 items (parameter 5), if there are more, a search box is used to select relevant values.

在這裡呼叫 dbselect 函式, 進入資料庫取值. 這裡只取 10 筆 (變數 5), 若有更多資料, 可以利用搜尋來取得適當值.

All companies have to be listed sorted by the name of the company (=companyname) alphabetically (asc=ascending) (parameter 4). As the table "simple_companies" (parameter 1) can have more than one field we tell the function to use the field "companyname" (parameter 2). Parameter 3 is not used in this case.

所有公司資料會按照公司名稱 (=companyname) 來進行排序, 並且依照字母排序 (asc=ascending) (變數 4). 變數 1 則指定資料表 "simple_companies" (變數 1), 也可以指定多個欄位, 這裡使用 "companyname" 欄位 (變數 2), 這個例子並沒有使用變數 3.

With parameter 3 you can reduce the list of companies with an sql-where clause, e.g. "companyname like 'a%'" to get all companies starting with "a".

變數 3 可以利用 sql-where 的語法來圈定公司, 例如, "companyname like 'a%'" 就會只列出以 a 開頭的公司.

Syntax: To collect these functions in a central place, all data functions are kept in core/functions_user.php and have a ``"select_"`` prefix (because they select data), e.g. "select_dbselect" can be used to get data from the database.

語法: 為了將這些函式收集在一個地方, 所有的資料函式都放在 core/functions_user.php 中, 而且都有一個 ``"select_"`` 前置詞 (因為用來選擇資料), 例如, "select_dbselect" 可以從資料庫取得資料.

To define a data construct in a sgsML file, write <data function="getmydata"/> between the <field>-tags to call the function "select_getmydata". Here dbselect is illustrated because it is the most common function to get data from the database.

為了能在 sgsML 檔案中定義資料建構物件, 可以在 <field> 標註間放上一個 <data function="getmydata"/>, 以便呼叫 "select_getmydata" 函式. 這裡的 dbselect 特別標示出來的原因, 試通常利用這種方法從資料庫取得資料.

Note: To reduce the size of your functions you can define multiple <data function=> constructs between the <field>-tags.

注意: 為了減少函式定義的個數, 可以在 <field> 標註中定義多個 <data function=> 物件.

Tables

資料表

When looking at tables we see rows, columns. Our rows are assets, every column is a field (similar to database design). <table></table> is the main tag used in sgsML and includes all the others (e.g. fields, views, etc.). With the table tag you define the name of the module, e.g.

資料表有列位與欄位, 列代表資料, 而每一個欄位就如同資料庫中的資料表設計. <table></table> 是 sgsML 中經常會用到的標註, 而且其中還帶有其他標註, (例如, 欄位, 視圖等), 可以利用 table 標註來定義模組的名稱, 例如,

<table modulename="Contacts"></table>

特別在 table 標註中註明模組名稱為 "Contacts".

With a table you also define how the fields should be treated:

也可以在 table 中定義該欄位要如何因應:

What is the column the list or assets should be sorted by?

資料表列中要以那一欄位作為排序依據?

What order should be used?

次序要如何訂定?

How many items should be displayed on one page?

每一頁要列出多少資料?

Should the results be groups by a special column?

結果需不需要透過某一特殊欄位分組?

e.g.:
    
實際 table 標註應用如下:

<table modulename="Contacts" orderby="lastname" order="asc" groupby="categories" limit="20"></table>

Of course, these are only the default values you suggest to the user. He can later choose on his own if he needs different settings.

當然, 這些只是呈現給用戶的內定值, 使用者隨後可以根據需求選擇成其他設定.

Fields

欄位

All fields are defined inside the <table>-tag. A field can be seen as a column in a database, e.g. Last name, Street, Country in an address book. Every field has a type, in sgsML the type is called "simple_type".

所有欄位都定義在 <table> 標註中, 此欄位可以視為資料庫的資料表, 例如, 地址資料庫中的姓, 街道名稱, 國家名稱等, 而每一個欄位都有其型別, 如前所述, sgsML 中, 型別稱為 "simple_type".

A type can be a normal string (simple_type is "text") or a collection of lines (simple_type is "textarea"). There are even exotic types like "htmlarea" which represents lines formatted with HTML, or different types for using passwords, dates, times, datetimes, files, wikis, etc.

型別可以是一行的字串 (simple_type 為 "text") 或者是幾行的字串 (simple_type 為 "textarea"). 也可以是比較特別的型別, 如 "htmlarea", 代表資料為 HTML, 或者是 passwords, dates, times, datetimes, files, wikis 等.

Every field has a name to be identified by the program.

每一個欄位在程式裏都有一個型別名稱.

This is similar to column definitions in databases. Besides the internal name used by the program every column can contain a displayname which is the name displayed to the user.

這就如同資料庫定義中的資料表. 除了程式中用來代表欄位的內部名稱為, 每一個資料表也可以帶有一個用來顯示的名稱.

E.g. the name of a field can be "lastname", the displayname is "Last name". To separate these two has a lot of advantages:

例如, 欄位名稱可以是 "lastname", 而顯示的名稱則為 "Last name", 將這兩種名稱分開有許多好處:

The name used by the program is limited to numbers and characters, whereas displayname can contain all kinds of special characters or it can be translated into many languages without changing the internal name used by the program.

程式中欄位的名稱被限定只能用數字與字元, 而顯示用的名稱則可以包含各種特殊符號或者可以翻譯成許多不同語系中的名稱, 而無需更改程式中欄位的內部名稱.

This creates consistency when using internationalization with Simple Groupware.

如此就能在不同語系中使用 Simple Groupware, 程式可以保持一致.

Fields can be declared as unique, meaning that there can be no other asset having the same value within this field. To decide between required and optional fields, every field can be defined as "required", but is "optional" by default.

欄位可以宣告為獨一無二, 表示其他資料中不會有相同的欄位. 也可以宣告為必要或選項欄位, 所有欄位都可以定義為必要欄位, 內定則為選項欄位.

As written before, fields can be validated using validators, their data can be defined by some data sources and they can be modified before / after storing them in the database.

如前所述, 欄位可以利用驗證物件來進行驗證, 這些資料可以定義為特殊的資料來源, 也可以在存入資料庫之前或之後進行變更.

Some examples:
    
幾個範例:

contacts.xml:
    
聯繫模組

<field name="lastname" displayname="Last name" simple_type="text" required="true" />

欄位名稱為 "lastname", 顯示名稱為 "Last name", 資料型別為 "text", 為必要欄位.

<field name="zipcode" displayname="Zipcode" db_size="6" simple_type="text">
<validate function="numeric"/>
</field>

欄位名稱為 "zipcode", 顯示名稱為 "Zipcode", 資料庫欄位大小為 6 位數, 資料型別為 "text", 為選項欄位.

欄位驗證採用 numeric 物件, 只能填入數字.

<field name="description" displayname="Description" simple_type="textarea" simple_size="4" />

欄位名稱為 "description", 顯示名稱為 "Description", 資料型別為 "textarea", 資料欄位大小為 4 位數, 為選項欄位.

Views

視圖

The next element inside the sgsML language is a "view". At first "views" are groups of fields. E.g. you show "first name" and "last name" of a person in the view "display" and the field "address" and "description" in the view "details".

下一個 sgsML 語言中的元素為 "view", 首先 "views" 用來對欄位進行分組, 例如, 將某一用戶的 "first name" 與 "last name" 放在 "display" 視圖中, 並且將 "address" 與 "description" 欄位放在 "details" 視圖中.

But views can do a lot more: views are also used to edit and create assets. Since defining forms (for editing and creating assets) is not always easy and oftentimes requires Javascript usage, Simple Groupware creates all the forms automatically for you. So you only define a field as an html-editor (simple_type "htmlarea") and you're done.

但是視圖還有其他功能: 視圖還能用來編輯與建立資料. 因為定義用來編輯與建立資料的表單, 並不容易, 而且通常需要用到 Javascript. Simple Groupware 則自動建立所有的資料表單. 只要宣告欄位為 html-editor (simple_type 型別為 "htmlarea") 就可以了.

To present several fields, sgsML differs between the orientation in which a group of fields is presented: The horizontal view (sgsML "display") is a list where every field has one column (this is how Windows Explorer lists files).

為了呈現幾個欄位,  sgsML 就群組欄位的方位視圖有所不同: 水平視圖 (sgsML 中的 "display") 就是每一個欄位放在一行中的列表呈現 (與視窗中顯示檔案的方式相同).

The second one is called "details" (vertical orientation) and presents every field as one line, meaning the first column is the name of the field and the second column contains the value of it.

第二種方式稱為 "details" (垂直顯示) 讓每一個欄位都集中在一列中, 第一行為欄位名稱, 而第二行則為該欄位的值.

Both orientations have advantages and disadvantages, so you can decide on your own which one you use for what case: define template="display" or template="details" in the view-tag and you're done. Note: When naming a view "foobar", the template "asset_foobar.tpl" will be used. Using the attribute template="display" in the view tag overrides this automatic mapping.

這兩種呈現各有優缺點, 使用者可以自行決定要使用哪一種: 在檢視標註中設定 template="display" 或 template="details" 就可以了. 注意: 若將視圖設為 "foobar" 將會使用 "asset_foobar.tpl" 樣版檔案. 使用 template="display" 屬性, 則會改寫先前的自動對應.

When looking with web applications you often see a list of assets (horizontal orientation) and a "Details" button at the right side to switch to the vertical one for a selected row.

網際程式中, 經常會看到一組資料 (水平排列) 假如選擇右邊的 "Details" 按鍵, 就會將某一選擇的資料列轉為垂直排列.

If you need this behavior depends on you own, simply add a showinsingleview="true" as attribute to the details-view and you're done (sgsML defines the rows of a table as single view, the headline above is the "normal" view, thus "singlebuttons" are buttons displayed at the right side of every asset).

可以自行決定是否要採用此項功能, 只要加入 showinsingleview="true" 屬性到 details-view 就可以了. (sgsML 定義 single view 為表格的列, 顯示在上頭的標題為 "normal" view, 因此 "singlebuttons" 就是每一筆資料右上方的相關按鍵.

Similar to tables, views can have their own "order", "orderby", "limit" statements which override those defined by the table.

與資料表一樣, 視圖有其 "order", "orderby", "limit" 設定可以改寫表格先前的定義.

Other tags are "image_width" and "image_height" (both or only one of them) which enable you to automatically resize images (simple_type "files", images are detected automatically when extension is gif/jpeg/png). This is very useful when bandwidth is low.

其他標註為 "image_width" 與 "image_height" (同時啟用或只使用其中之一), 可用來自動調整影像大小 (simple_type "files", 副檔名為 gif/jpeg/png 的影像檔會自動辨識). 當傳輸頻寬不高時, 這功能就很有用.

Another way views can be used is to reduce the number of assets by a "where" clause, e.g. "lastname like 'a%'" to get all persons starting with "a" (this functionality is similar to views in databases using SQL-Views).

另一方面 views 可以利用 "where" 語法來減少所呈現的資料筆數, 例如 "lastname like 'a%'" 來取得資料中姓名以 "a" 開頭的內容 (類似資料庫 SQL-Views 中的資料 views 功能).

To group fields to special views, you define constructs like "notin" (exclusion method) or "onlyin" (inclusion method) inside the <field>-tags.

將欄位群組成特定的視圖, 可以在 <field> 標註中, 定義類似 "notin" 的語法 (排除) 或 "onlyin" (包含).

Some examples:

幾個範例:
    
contacts.xml:
    
通訊錄模組

<view name="display" displayname="{t}Display{/t}" groupby="category" />

視圖名稱為 display, 顯示名稱啟用 Display 的語系翻譯, 而且以 category 進行分組展示.

<view name="details" displayname="{t}Details{/t}" showinsingleview="true" />

視圖名稱為 details, 顯示名稱啟用 Details 的語系翻譯,  showsingleview 設為 true.

users.xml:

使用者模組

<view name="display" displayname="{t}Active{/t}" where="activated=1" />

視圖名稱為 display, 顯示名稱啟用 Active 的語系翻譯, 而且 activated 設為 1.

<view name="details" displayname="{t}Details{/t}" image_width="200" image_height="100" showinsingleview="true" />

視圖名稱為 details, 顯示名稱啟用 Details 的語系翻譯, 影像寬度設為 200, 高度設為 100, showsingleview 設為 true.

Tabs

視窗頁面

The last construct used by sgsML are tabs. Tabs are similar to views: They group fields and enable you to quickly switch from one group to another without overloading the screen.

最後要介紹的 sgsML 物件為視窗頁面. 視窗頁面與視圖類似: 用來將幾個欄位擺在一起, 讓使用者可以很快由某一群組切換到另一群組, 而無需重載畫面.

A view is static: This means when you click on a view, the program takes the required fields from the databases and presents the results to you. In contrast, tabs are subordinated to views. A view can contain several tabs, every tab is visible in every view (sounds a bit difficult at the first shot, but gets clearer when writing the first application).

視圖為靜態物件: 當按下某一視圖, 程式會從資料庫取出所需要的欄位資料, 然後將資料呈現出來. 相對的, 視窗頁面則包含在視圖當中. 一個視圖可以帶有幾個視窗頁面, 而且每一個視窗畫面都可由視圖物件中切換 (光這樣說明可能不容易理解, 但是寫完一個應用程式後, 就會越來越清楚).

Tabs are dynamic: E.g. you click on one view containing 5 tabs, all fields for the 5 tabs are loaded from the database and put into the (HTML-)output. To avoid overloading the screen, tabs use Javascript to make sure that only one tab is visible at once. When clicking another tab, the old one is hidden and the other is made visible. To assign fields to tabs, simply use <field ... simple_tab="mytab">.

視窗頁面是動態的: 例如, 點進一個擁有 5 個視窗頁面的視圖, 這 5 個頁面資料其實都已經從資料庫取出資料, 並且納入 (HTML) 的輸出畫面. 為了避免全部擠在畫面中, 視窗頁面利用 Javascript 的圖層進行處理, 讓每次只呈現一個畫面. 使用者按下其他頁面時, 舊頁面就會隱藏起來, 讓點選的頁面呈現出來. 要將欄位資料以視窗頁面呈現, 只要使用 <field ... simple_tab="mytab">.

Here is an example:
    
這裡有個範例:

<tab name="general" displayname="{t}General{/t}" />

頁面名稱為 "general", 顯示名稱則為 General 的語系翻譯詞.

<tab name="details" displayname="{t}Details{/t}" />

頁面名稱為 "details", 顯示名稱則為 Details 的語系翻譯詞.

<field name="description" displayname="{t}Description{/t}" simple_type="textarea" simple_size="4" simple_tab="details" />

欄位名稱為 "description", 顯示名稱則為 Description 的語系翻譯詞, simple_type 為 "textarea" simple_size 為 "4", simple_tab 為 "details".

Deploy your applications with sgsML

利用 sgsML 部署網際應用程式

Finally after writing your first sgsML application you will surely want to deploy it to your Simple Groupware installation. Therefore every module is a web application and stored in one .xml file. Simple Groupware distinguishes between two types of modules: Normal modules and system modules.

寫好了第一個 sgsML 應用程式後, 當然就是把它部署到 Simple Groupware 安裝當中. 因為每一個網際應用模組都將程式存在一個 .xml 格式檔案中. Simple Groupware 則將應用程式分為兩類: 一般模組與系統模組.

System modules are very special modules providing access to other data sources (e.g. the filesystem, other databases, IMAP, iCalendar, etc.) or providing system functionality (folders, statistics, events, search functionalities, session handling, etc.).

系統模組是較為特別的模組, 專門用來擷取特殊的資料來源 (例如, 檔案系統, 其他資料庫, IMAP, iCalendar 等) 或者提供系統功能 (檔案夾, 統計功能, 事件, 搜尋功能,  暫存檔案處理等).

A module is a system module if Simple Groupware cannot run without it.

沒有系統模組 Simple Groupware 就無法運行.

(There are even some modules like users and groups where this border cannot be clearly pulled, these modules remain system modules since you can't work without it).

使用者與群組模組雖然介於兩者之間, 但還是被視為系統模組, 因為沒有這些模組, 系統還是無法運行.

System modules are kept under "modules/schema_sys". If a module doesn't represent a schema from a table with data in the database than it carries a ``"nodb_"`` prefix in the filename (e.g. the filesystem has a schema, but it is not a schema from a table with data in the database). A module that is marked as ``"nodb_"`` needs to get its data from another data source.

系統模組被放在 "modules/schema_sys" 目錄中. 假如某一個模組沒有使用資料庫, 檔名就會帶有 ``"nodb_"`` 前置名稱. (亦即, 這個模組與檔案系統有關, 但是與資料庫中的資料表沒有關聯). 若模組標示為 ``"nodb_"`` , 表示這個模組需要從其他資料來源取得資料.

Therefore it uses its own functions for getting and setting data. These functions are very simple and are automatically called by the sql-handler of Simple Groupware. These functions are stored in modules/lib/* and are all following the Simple Groupware API. When learning sgsML you should try to understand system modules at last.

因此, 這些模組使用各自的函式來取得或設定資料. 這些函式通常非常簡單, 而且會自動由 Simple Groupwaer 的 sql 處理器進行呼叫. 這些函式放在 modules/lib/* 當中, 通常使用 Simple Groupwaer 的 API 函式. 想要學習 sgsML 就必須要徹底了解這些系統模組.

以下這些 src/ 與 bin/ 的目錄架構, 在 0.8 版已經有了變更, 因此是否要對以下資料進行翻譯??

The Simple Groupware folder structure has two branches: src/ and bin/. If you install with language English, German, etc. all files from src/* are translated and written to bin/* during the setup process. Therefore if you installed with English or German, place your .xml file in bin/modules/schema/. If you installed with Developer as language, place your .xml file in src/modules/schema/.

Note: To be able to select a module in the list when creating a new folder, you need to add the module to "modules/schema/modules.txt". Every line in this file contains the module's name and the string that is displayed in the web-interface.

Note: Every .xml file defines a structure of a table in the database. The name of the table is automatically set by the filename and ``"simple_"`` as prefix. E.g. the table name for schema/tasks.xml is set to simple_tasks. If the module is a system module, the prefix will be ``"simple_sys_"``. E.g. the table name for schema_sys/users.xml will be simple_sys_users. The "modulename" attribute is only the name displayed above the tree on every page.

Translations

With Simple Groupware you can translate everything: It doesn't matter if the strings that should translated are inside XML, PHP, Html, sgsML, etc. Every string that needs to be translated is covered with {t} and {/t}. E.g. to make "username" translatable, use it as "{t}username{/t}".

That's the same using sgsML. Examples for translations inside sgsML are display-names for fields, date formats as validation / store parameters, etc. The translation process is done during the setup. So you select a language and all files from the src/ directory are translated into the bin/ directory.

When installing with Developer as language, the translation isn't done. All files reside in src/ and when viewing the output, {t} and {/t} are automatically removed. So using Simple Groupware as "Developer" you always get untranslated English values in the output.
Note: If you don't need translations, you won't need to add "{t}" and "{/t}".

Examples

blank.xml:

<table modulename="{t}Blank{/t}" default_view="display" default_sql="no_select">

<view name="display" displayname="{t}Display{/t}" />

<field name="id" simple_type="id" displayname="{t}Id{/t}" />

</table>

This module has the name blank. It will be displayed as {t}Blank{/t} where "{t}Blank{/t}" will be translated using the language files. As we defined one view (display), the default view is also display. The view "display" will be displayed as the translation of {t}Display{/t}.

In this example we have one field called "id" with the simple_type of "id" meaning this field will be used as a primary key for the table.

Also there is a default_sql statement: This overrides normal (automatic) SQL select statements. When using no_select, there will be no select statement being done. In this example we want the SQL statement to be done automatically, so we strip the default_sql attribute.

Now, let's make a second field called "Last name". Since every person should have a last name we want it to be required every time a new person is created or edited. Last name is a string and therefore we use simple_type "text" which is used for all strings that don't require line breaks. Last name should be named "lastname" in the program and displayed as the translation of {t}Last name{/t}.

blank.xml:

<table modulename="{t}Blank{/t}" default_view="display">

<view name="display" displayname="{t}Display{/t}" />

<field name="id" simple_type="id" displayname="{t}Id{/t}" />

<field name="lastname" displayname="{t}Last name{/t}" simple_type="text" required="true" />

</table>

Adding "first name" is done the same way:

<field name="firstname" displayname="{t}First name{/t}" simple_type="text" required="true" />

To help you finding your entries we want to sort them by lastname (default is Id). Therefore we expand the table statement with two attributes:

orderby="lastname" order="asc"

Orderby defines the field we want to sort by and asc means that the entries should be sorted ascending (instead of desc for descending). Having more than 100 entries makes the list very long, so we want to distribute the entries to several pages. To do this, only set a limit to the table:

limit="20"

To help you to remember the relationships to these assets we add a new field called description:

<field name="description" displayname="{t}Description{/t}" simple_type="textarea" simple_size="4" />

The field description will be displayed as the translation of {t}Description{/t}. The type used here is "textarea" which is similar to the "textarea" component used in HTML. Thus we have a text which can be longer than one line. Here simple_size indicates that textarea has a height of 4 rows.

Now we have:

.. code-block:: none

    blank.xml::
    
        <table modulename="{t}Blank{/t}" default_view="display" orderby="lastname" order="asc" limit="20">
        
        <view name="display" displayname="{t}Display{/t}" />
        
        <field name="id" simple_type="id" displayname="{t}Id{/t}" />
        
        <field name="lastname" displayname="{t}Last name{/t}" simple_type="text" required="true" />
        
        <field name="firstname" displayname="{t}First name{/t}" simple_type="text" required="true" />
        
        <field name="description" displayname="{t}Description{/t}" simple_type="textarea" simple_size="4" />
        
        </table>

To rename our module from blank to "My Addresses", use ...

myaddresses.xml:

.. code-block:: none

    <table modulename="{t}My Addresses{/t}" default_view="display" orderby="lastname" order="asc" limit="20">
    <view name="display" displayname="{t}Display{/t}" />
    <field name="id" simple_type="id" displayname="{t}Id{/t}" />
    <field name="lastname" displayname="{t}Last name{/t}" simple_type="text" required="true" />
    <field name="firstname" displayname="{t}First name{/t}" simple_type="text" required="true" />
    <field name="description" displayname="{t}Description{/t}" simple_type="textarea" simple_size="4" />
    </table>

and rename the file from "src/modules/schema/blank.xml" to "src/modules/schema/myaddresses.xml" if you installed Simple Groupware with language "Developer". If you installed it with English or German, rename the file from "bin/modules/schema/blank.xml" to "bin/modules/schema/myaddresses.xml".

Now we only have a simple view that can display entries. To enable you to create new entries, add the following attribute to the table tag:

enable_new="true"

This automatically adds the "New" view with the rights attributes.
To allow you to edit and delete existing entries, add these attributes to the table tag:

enable_edit="true" enable_delete="true"

This automatically adds the "Edit" view and the "Delete" buttons.
With Simple Groupware you assign one module to every folder. Therefore you may want to be able to delete all entries in the folder. To do this we use the "empty" attribute:

enable_empty="true"

This automatically adds the "Empty" button.

myaddresses.xml::

    <table modulename="{t}My Addresses{/t}" default_view="display" orderby="lastname" order="asc" limit="20" enable_new="true" enable_edit="true" enable_delete="true" enable_empty="true">
    
    <view name="display" displayname="{t}Display{/t}" />
    
    <field name="id" simple_type="id" displayname="{t}Id{/t}" />
    
    <field name="lastname" displayname="{t}Last name{/t}" simple_type="text" required="true" />
    
    <field name="firstname" displayname="{t}First name{/t}" simple_type="text" required="true" />
    
    <field name="description" displayname="{t}Description{/t}" simple_type="textarea" simple_size="4" />
    
    </table>

To deploy your new web application, make sure that the module is stored in "src/modules/schema/myaddresses.xml" (Developer language) or "bin/modules/schema/myaddresses.xml" (English, German, etc. language).

Inside Simple Groupware, take a look at the tree. Go to a folder where you want to place the new application, e.g. click "Workspace". Below the tree, click "Options", enter a new folder name to the "New folder" form, choose "myaddresses" in the list and click Ok. This is all: The new module is running now!

Note: The modules in the list contain the filenames without the extension (.xml), not the modulename-attribute. Therefore you see "myaddresses" in the list instead of "{t}My Addresses{/t}".

To improve "My Addresses" we add some more fields:

<field name="street" displayname="{t}Street{/t}" simple_type="text" />

<field name="zipcode" displayname="{t}Zipcode{/t}" db_size="6" simple_type="text">

<validate function="numeric" />

</field>

<field name="city" displayname="{t}City{/t}" simple_type="text" />

All three are of type "text", but the zip code should be validated by some constraints: The first validation is done with db_size=6 which means that the field may not be longer than 6 characters. Since zip codes are numeric (in Germany) we add the validator "numeric" (when creating or editing a new asset the function "validate_numeric" is called). If your zip codes are not numeric, leave this step out.

But the "Display" quickly gets overloaded with fields. Thus we create a new view called "Details".

<view name="details" displayname="{t}Details{/t}" showinsingleview="true" tfield_1="firstname" tfield_2="lastname" />

We decide that Id and description are less important than the other fields and should be displayed in the second view "Details". Also the fields "lastname" and "firstname" should be displayed as a caption in the first line of the details view (indicated with the attributes "tfield_1" and "tfield_2").

This means we add new limitations to the fields:

<notin views="display" />

Notin tells the program not to display the field in the view "display". Notin uses "views" as attribute which means that you can add several views here using views=``"view1|view2"`` separated with ``"|"``.

Summarizing our activities

myaddresses.xml:

<table modulename="{t}My Addresses{/t}" default_view="display" orderby="lastname" order="asc" limit="20" enable_new="true" enable_edit="true" enable_delete="true" enable_empty="true">

<view name="display" displayname="{t}Display{/t}" />

<view name="details" displayname="{t}Details{/t}" showinsingleview="true" tfield_1="firstname" tfield_2="lastname" />

<field name="id" simple_type="id" displayname="{t}Id{/t}">

<notin views="display" />

</field>

<field name="lastname" displayname="{t}Last name{/t}" simple_type="text" required="true" />

<field name="firstname" displayname="{t}First name{/t}" simple_type="text" required="true" />

<field name="description" displayname="{t}Description{/t}" simple_type="textarea" simple_size="4">

<notin views="display" />

</field>

<field name="street" displayname="{t}Street{/t}" simple_type="text" />

<field name="zipcode" displayname="{t}Zipcode{/t}" db_size="6" simple_type="text">

<validate function="numeric"/>

</field>

<field name="city" displayname="{t}City{/t}" simple_type="text" />

</table>

When saving changes to the xml file you only need to hit the "Refresh" button in your browser to make Simple Groupware apply your changes.

Examples (continued)

To make the description field more usable we change simple_type from textarea to htmlarea:

simple_type="htmlarea"

Hit refresh and you have a complete HTML editor!

Another way to avoid overloading of the display view is using simple_tabs.

So we define two tabs, one for general information, the other one for the details (both displayed with the translation from the language file):

<tab name="general" displayname="{t}General{/t}" />

<tab name="details" displayname="{t}Details{/t}" />

The difference between "views" and "tabs" is the time when the information is loaded. With views, only the information for the current view is loaded. Using tabs all the information is loaded, but hided using Javascript until you hit the tab. Switching between tabs is much faster because you have already loaded all the information in your browser, but loading the page takes longer at the beginning.

The same example using tabs instead of views looks like this:

myaddresses.xml:

<table modulename="{t}My Addresses{/t}" default_view="display" orderby="lastname" order="asc" limit="20" enable_new="true" enable_edit="true" enable_delete="true" enable_empty="true">

<view name="display" displayname="{t}Display{/t}" />

<tab name="general" displayname="{t}General{/t}" />

<tab name="details" displayname="{t}Details{/t}" />

<field name="id" simple_type="id" displayname="{t}Id{/t}" simple_tab="details" />

<field name="lastname" displayname="{t}Last name{/t}" simple_type="text" required="true" />

<field name="firstname" displayname="{t}First name{/t}" simple_type="text" required="true" />

<field name="description" displayname="{t}Description{/t}" simple_type="htmlarea" simple_size="4" simple_tab="details" />

<field name="street" displayname="{t}Street{/t}" simple_type="text" />

<field name="zipcode" displayname="{t}Zipcode{/t}" db_size="6" simple_type="text">

<validate function="numeric" />

</field>

<field name="city" displayname="{t}City{/t}" simple_type="text" />

</table>

To add a gender selectbox with the values male, female, use:

<field name="gender" displayname="{t}Gender{/t}" db_size="10" simple_type="select" simple_size="1" simple_tab="details">

<data values="{t}male{/t}|{t}female{/t}"/>

</field>

The field gender has a maximum of 10 characters, is displayed as a selectbox (simple_type select) and the user can select 1 item (instead of multiple items).

Since every address has relations to other addresses we finally add a field to store these relationships:

<field name="isrelatedto" displayname="{t}Is related to{/t}" simple_type="select" simple_size="3" is_linked="simple_myaddresses|details|lastname" multiple="&lt;br&gt;" simple_tab="details" allow_custom="true">


``<data function="dbselect|simple_myaddresses|lastname,lastname||lastname asc|10"/>``

</field>

The field isrelatedto is displayed with the translation of {t}Is related to{/t}. The simple_type is a selectbox with a height of 3 lines, allowing the user to select multiple items. In the display these items are separated by "<br>" (= new line). The user can also type in his own items which is declared by allow_custom=true.

To get the data from the selectbox we use the select_dbselect function which does something like "select lastname from simple_myaddresses order by lastname asc limit 10". If there are more than 10 items, the user can select them by using a search box.

This field is also shown in the details tab. Furthermore when displaying the items of this field we want these items to be links. When a user clicks them the referenced address should be displayed.

This behavior is achieved by using the "is_linked" attribute. The first parameter names the table, the second the view we want to see in the popup and the third defines the field to choose from.

The complete code of the example

myaddresses.xml:

<table modulename="{t}My Addresses{/t}" default_view="display" orderby="lastname" order="asc" limit="20" enable_new="true" enable_edit="true" enable_delete="true" enable_empty="true">

<view name="display" displayname="{t}Display{/t}" />

<tab name="general" displayname="{t}General{/t}" />

<tab name="details" displayname="{t}Details{/t}" />

<field name="id" simple_type="id" displayname="{t}Id{/t}" simple_tab="details" />

<field name="gender" displayname="{t}Gender{/t}" db_size="10" simple_type="select" simple_size="1" simple_tab="details">

<data values="{t}male{/t}|{t}female{/t}"/>

</field>

<field name="lastname" displayname="{t}Last name{/t}" simple_type="text" required="true" />

<field name="firstname" displayname="{t}First name{/t}" simple_type="text" required="true" />

<field name="description" displayname="{t}Description{/t}" simple_type="htmlarea" simple_size="4" simple_tab="details" />

<field name="street" displayname="{t}Street{/t}" simple_type="text" />

<field name="zipcode" displayname="{t}Zipcode{/t}" db_size="6" simple_type="text">

<validate function="numeric"/>

</field>

<field name="city" displayname="{t}City{/t}" simple_type="text" />

<field name="isrelatedto" displayname="{t}Is related to{/t}" simple_type="select" simple_size="3" is_linked=``"simple_myaddresses|details|lastname"`` multiple="&lt;br&gt;" simple_tab="details" allow_custom="true">

``<data function="dbselect|simple_myaddresses|lastname,lastname||lastname asc|10"/>``

</field>

</table>

Note: Using translations normally takes more time, so it is on you to use them or not.

注意: 使用翻譯功能通常會花費較多時間, 可以決定是否要採用這項功能.

Screenshots of myaddresses.xml

myaddresses.xml 執行畫面

Search functionality

搜尋功能

All your data will automatically be searchable. If simple_type is files, each file will be indexed using the binary tools (catdoc, xlhtml, ImageMagick, Xpdf, UnZip, gzip, tar). These tools are included as windows binaries, if using Linux/Unix you need to install these packages from your distribution (see Installation).

所有資料都可以查詢. 若 simple_type 為檔案, 每一個檔案都會透過二位元工具 (catdoc, xlhrml, ImageMagick, Xpdf, UnZip, gzip, tar) 進行索引. 這些工具具都有 windows 二位元檔案, 假如使用 Linux/Unix 則需要自行安裝這些套件. (參見安裝說明).

Summary

總結

To demonstrate the efficiency of Simple Groupware and sgsML:
    
為了驗證 Simple Groupware 與 sgsML 的效能:

We have written a complete web application including 9 fields with only 26 lines of code.

可以用 26 行 9  欄位寫一個完整的網際應用程式.

You can create / edit / delete assets. With the built-in tree of Simple Groupware you can create different folders for special groups of addresses.

使用者可以建立/編輯/刪除應用程式中的資料. 透過內建的 Simple Groupware 樹狀架構, 可以針對不同群組建立不同的資料目錄.

All your changes are logged in the history.

所有的變更都會在程序檔案中註記

And maybe the most important benefit all the values are already searchable via the global search function. (You can even try using phonetic searches!)

最重要的好處是, 所有內容都可以透過全域搜尋函式進行搜尋 (也可以使用同音搜尋功能)

I hope you got a first introduction into the world of sgsML and already understood most parts of it.

希望經過這個簡短的介紹, 可以跨入 sgsML 的世界, 並對大部分的內容都能有所理解.

For more examples, see the "src/modules/schema" directory (including examples using files, dates, codeareas, wikiareas etc.).

更多的範例, 可以查看 "/src/modues/schema" 目錄 (包含使用 files, dates, codeareas, wikiareas 等功能的範例)

To go deeper into sgsML there is "src/modules/schema_sys" (containing the Simple Groupware system modules and handlers for external data sources).
This is only a small tutorial describing the basic ideas and elements behind sgsML. If you write your own modules, and there is something not working or not clear, feel free to mail me.

想要更深入了解 sgsML, 可以查看 "src/modules/schema_sys" (包含 Simple Groupware 系統模組與外部資料來源的處理器).
這個簡介只說明有關 sgsML 的基本概念與元件. 您若自行編寫模組, 有哪些功能無法運作或不清楚, 可以寫信給我.
.. @+node:amd_yen.20130426235501.4330: *5* 目錄權限管理
View Access 主要權限設定的目錄在於進行 tabs 的進階管理:

例如::

    ``|answers:no_read:users_self_registration|details:no_read:users_self_registration|``

表示要將 answers 與 details tabs 以群組 View Access 設定, 全部設為 no_read

設定完成後, 必須要清除 schema cache, 並且以清除 session 方式, 讓所有用戶登出後再登入, 設定才可以生效.

特別注意: 若未能以清除 session 方式強迫登入的用戶登出再登入, 則用戶將會以先前的 session 資料權限執行各目錄模組功能.
.. @+node:amd_yen.20130319174748.1563: *4* peerreview 模組
以下 Simple Groupwae 模組 Peer Review:

模組檔案為 peereview.xml, 部署時必須在 bin/modules/schema/modules.txt 中登錄, peereview|Peer Review

.. code-block:: none

    <table modulename="Peer Review" default_view="display" orderby="studentno" order="asc" limit="20" enable_new="true" enable_edit="true" enable_delete="true" enable_asset_rights="owner_read">
    <view name="display" displayname="Display" />
    <view name="details" displayname="Details" showinsingleview="true" tfield_1="studentname" tfield_2="score" />
    <field name="id" simple_type="id" displayname="Id">
    <notin views="display" />
    </field>
    <field name="studentname" displayname="姓名" simple_type="text" required="true" />
    <field name="studentno" displayname="學號" simple_type="text" required="true">
    <validate function="regexp|/^[0-9]{8}+$/|學號必須為 8 位數數字"/>
    </field>
    <field name="score" displayname="分數" simple_type="text" required="true">
    <validate function="regexp|/^[0-9]{2}+$/|分數必須為 2 位數數字"/>
    </field>
    <field name="description" displayname="評分說明" simple_type="textarea" simple_size="4">
    <notin views="display" />
    </field>
    </table> 
.. @+node:amd_yen.20130309155804.1711: *4* 齒輪減速機專案
協同小組每組 6 人, 協同大組每組 18 人, 請各組分別啟動 Simple Groupware, 以 IMAP authentication 為主, 讓各小組與大分組的成員可以登入到各組的主機.

每一學員都有三台主機可以登入, 即本小組主機與其他兩個大組的分組主機.

請以每大組 18 人的協同模式下, 完成一份大分組的前三週分組課程內容整理報告.

請說明各分組的協同群組軟體在此一模式下可以提供哪些功能?各組員分別扮演哪些角色?

請討論如何以協同模式完成網際`正齒輪減速機_`的產品開發, 此一開發流程分別包含哪些工作?請根據各組員所擔任的角色, 繪出協同產品開發流程圖, 並明確列出各組員在特定階段的專案管理過程, 分別需要熟悉哪些技術?分別選擇如何完成所被交付的任務工作?

1. CMSimple XH 模式下, 使用者完成延伸程式齒輪尺寸設計 (齒面寬) 後, 隨即在網際介面提供減速機所屬的相關零組件.

2. 將齒輪減速機設計程式轉為 Simple Groupware 格式的延伸程式.

3. 配合上述相關設計流程, 完成一套單機版本的齒輪減速機輔助設計程式 (若以 Python 程式為例, 可以選擇 tkinter 與 PyQt 介面).

貴大組需要多久時間完成此一產品開發的工作?

.. _正齒輪減速機: https://github.com/chiamingyen/CMSimpleGearPlugin

Python3 tkinter 正齒輪輪廓圖程式:

.. 請注意: 以下採用程式檔案直接載入文書內容的模式取得對應的程式原始碼.

.. literalinclude:: ../cd/gearcontour.py
   :language: python
   :linenos:

參考資料:

https://github.com/joostn/OpenJsCad/tree/gh-pages

http://joostn.github.com/OpenJsCad/

http://joostn.github.com/OpenJsCad/gearsdemo.html

http://joostn.github.com/OpenJsCad/grilledemo.html

http://joostn.github.com/OpenJsCad/lampshadedemo.html
.. @+node:amd_yen.20130320201815.1568: *5* Creo 零件程式化組立
先組立第一個零件後, 第二個零件與第一個零件進行約束組立

.. code-block:: javascript

    <script src="jscript/weblink/pfcUtils.js">
    </script><script language="JavaScript">
          if (!pfcIsWindows())
    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
      var session = pfcGetProESession();
    // 建立擺放零件的位置矩陣
      var identityMatrix = pfcCreate ("pfcMatrix3D");
      for (var x = 0; x < 4; x++)
        for (var y = 0; y < 4; y++)
          {
        if (x == y)
          identityMatrix.Set (x, y, 1.0);
        else
          identityMatrix.Set (x, y, 0.0);
          }
      var transf = pfcCreate ("pfcTransform3D").Create (identityMatrix);
    // 取得目前的工作目錄
      var currentDir = session.getCurrentDirectory();
    // 以目前已開檔, 作為 model
      var model = session.CurrentModel;
    // 查驗有無 model, 或 model 類別是否為組立件
      if (model == void null || model.Type != pfcCreate ("pfcModelType").MDL_ASSEMBLY)
        throw new Error (0, "Current model is not an assembly.");
     
      var assembly = model;
     
      var descr =
        pfcCreate ("pfcModelDescriptor").CreateFromFileName ("link1.prt");
    // 若 link1.prt 在 session 則直接取用
      var componentModel = session.GetModelFromDescr (descr);
     
    // 若 link1.prt 不在 session 則從工作目錄中載入 session
      var componentModel = session.RetrieveModel(descr);
    // 若 link1.prt 已經在 session 則放入組立檔中
      if (componentModel != void null)
        {
    // 注意這個 asmcomp 即為設定約束條件的本體
    // asmcomp 為特徵物件,直接將零件, 以 transf 座標轉換放入組立檔案中
      var asmcomp = assembly.AssembleComponent (componentModel, transf);
        }
    var ids = pfcCreate ("intseq");
    // 取得 assembly 項下的元件 id, 因為只有一個零件, 採用 index 0 取出其 featID
      var components = assembly.ListFeaturesByType(true, pfcCreate ("pfcFeatureType").FEATTYPE_COMPONENT);
    var featID = components.Item(0).Id;
    ids.Append(featID);
    // 在 assembly 模型中建立子零件所對應的路徑
    var subPath =
        pfcCreate ("MpfcAssembly").CreateComponentPath( assembly, ids );
    document.write("id 為:"+subPath.ComponentIds(0));
          subassembly = subPath.Leaf;
    //  設定組立檔中的三個定位面, 注意內定名稱與 Pro/E WF 中的 ASM_D_FRONT 不同, 而是 ASM_FRONT
      var asmDatums = new Array ("COM_D_FRONT", "COM_D_TOP", "COM_D_RIGHT");
    // 設定零件檔中的三個定位面, 名稱與 Pro/E WF 中相同
      var compDatums = new Array ("COM_D_FRONT",
                      "COM_D_TOP",
                      "COM_D_RIGHT");
    // 建立約束條件變數
      var constrs = pfcCreate ("pfcComponentConstraints");
    // 利用迴圈分別約束組立與零件檔中的三個定位平面
      for (var i = 0; i < 3; i++)
        {
    // 設定組立參考面, asmItem 為 model item
          var asmItem =
        subassembly.GetItemByName (pfcCreate ("pfcModelItemType").ITEM_SURFACE,
                    asmDatums [i]);
    // 若無對應的組立參考面, 則啟用互動式平面選擇表單 flag
          if (asmItem == void null)
        {
          interactFlag = true;
          continue;
        }
    // 設定零件參考面, compItem 為 model item
          var compItem =
        componentModel.GetItemByName (pfcCreate ("pfcModelItemType").ITEM_SURFACE,
                          compDatums [i]);
    // 若無對應的零件參考面, 則啟用互動式平面選擇表單 flag
          if (compItem == void null)
        {
          interactFlag = true;
          continue;
        }
    // 採用互動式設定相關的變數
          var MpfcSelect = pfcCreate ("MpfcSelect");
          var asmSel = MpfcSelect.CreateModelItemSelection (asmItem, subPath);
          var compSel = MpfcSelect.CreateModelItemSelection (compItem, void null);
          var constr = pfcCreate ("pfcComponentConstraint").Create (
                                    pfcCreate ("pfcComponentConstraintType").ASM_CONSTRAINT_ALIGN);
          
          constr.AssemblyReference  = asmSel;
          constr.ComponentReference = compSel;
          
          constr.Attributes = pfcCreate ("pfcConstraintAttributes").Create (false, false);
    // 將互動選擇相關資料, 附加在程式約束變數之後
          constrs.Append (constr);
        }
    // 設定組立約束條件, 以 asmcomp 特徵進行約束條件設定
    // 請注意, 第二個變數必須為 void null 表示零件對零件進行約束, 若為 subPath, 則零件會與原始零件的平面進行約束
    asmcomp.SetConstraints (constrs, void null);
            try
            {
                      document.write("目前 Creo 的工作目錄:<br />"+currentDir);
                }
        catch (err)
            {
                alert ("Exception occurred: "+pfcGetExceptionType (err));
            }
      assembly.Regenerate (void null);
      session.GetModelWindow (assembly).Repaint();
    </script>
.. @+node:amd_yen.20130320201815.1571: *5* 正齒輪參數繪圖
Creo 使用步驟

1. 設定工作目錄
2. 設定設計尺寸單位與重量單位
3. 在工作目錄區儲存 config.pro
4. 開啟新檔, 執行設計繪圖

// 正齒輪設計輸入參數
// n 為齒數
n
// m 為模數
m
// a 為壓力角
a

// dp 為節圓直徑
dp=n*m
// rp 為節圓半徑
rp=dp/2
// rb 為基圓半徑
rb=rp*cos(a)
// ha 為齒頂長度
ha=m
// hf 為齒根長度
hf=1.2*m
// ra 為齒頂圓半徑
ra=rp+ha
// rd 為齒根圓半徑
rd=rp-hf
rc=0.38*m
c=sqrt(1/(cos(a)*cos(a))-1)/PI

//involute datum curve equations
// t from 0 to 1 and get the (x,y) coordinates on the involute curve
angle=t*90
deg=PI/180
s=rb angle*deg=rb*angle*PI/180=rb*t90*PI/180
xc=rb*cos(angle)
yc=rb*sin(angle)
x=xc+s*sin(angle)
y=yc-s*cos(angle)
z=0

計算 involute curve 與 360/n/2 的回扣角度 in radian (theta)

theta in rad
s=rb*theta
xc=rb*cos(theta)
yc=rb*sin(theta)
x=rb cos(theta)+ssin(theta)
y=rb sin(theta)-scos(theta)

x^2+y^2=(rb cos(theta))^2+(ssin(theta))^2+(rb sin(theta))^2+(scos(theta))^2=rp^2
rb^2(1+theta^2)=rp^2
theta=sqrt((1/cos(a)^2)-1) 
.. @+node:amd_yen.20130320201815.1570: *5* 報告範例
正齒輪零組件之網際協同參數設計

C. Yen

摘要

Abstract

Keywords:

簡介

隨著全球化經濟的崛起, 世界各地的用戶得以透過網際網路的連線, 以最高效益, 輕易找到各種適合自己的產品, 在面對此一趨勢的發展, 全球各地的產品開發者, 也必須運用網路無遠弗屆的優勢, 整合各級零組件供應商, 甚至終端客戶, 以協同設計的模式, 將各協同團隊的效能進行最高發揮, 才能如願在競爭日益劇烈的環境中, 取得一席之地.

本研究即在此一網際環境發展的驅使下, 希望利用具有代表性的正齒輪零組件參數設計, 與網際平台結合, 希望獲得的效益除了能夠依照零組件供應商的屬性, 依序整合進所開發的網際程式平台外, 也能夠及早讓目標客戶有機會利用隨選或客製化的產品訂製環境, 進行參與, 以盡量達到"先下單, 後設計" (Design to Order) 的理想.

本篇論文, 除簡介外, 將逐一介紹現階段協同整合框架的組成元素與功能, 並且透過整合設計目標的探討, 明確列出本系統所要達成的目標. 接著, 將介紹本項研究參與成員在此一網際協同整合框架中, 各自扮演的角色與任務執行過程. 並將在這些過程中, 介紹系統搭建流程, 使用操作設定與系統進行步驟, 隨後並將各模組所能延伸的相關功能加以介紹. 接著將介紹本研究所獲致的結果與討論, 最後, 並就此一系統建構過程所獲致的心得與建議.

協同整合框架 – 含Textbook 第一章之相關環境與系統功能描述.

整合設計目標 – 說明報告所要達成的目標

協同規劃與分工 – 含時間規劃, 分工內容與擬採行之方法或工具

網際系統與工具 – 實際系統搭建, 為達成目標所擬導入或學習之操作說明

進行步驟說明 – 各細部分組或組員實際進行之步驟說明

結果與討論 – 所獲致之結果, 所達成之功能項目說明與討論

心得與建議 – 針對報告內容之執行所獲得之心得感想與相關檢討建議

參考資料

附錄 – 包含所有相關文件與檔案 

1.3 Case Study: Design of Single-Stage Spur Gearbox

案例研究: 單階正齒輪箱設計

The  design  problem  is  decomposed  into  modules  such  as  physical  components, design  constraints,  parametric  models,  analysis  procedures,  and  CAD  modeling.

此一設計問題細分為實體零件, 設計約束, 參數模型, 分析步驟與 CAD 模擬等模組.

The  important  aspect  of  the  framework  is  an  integration  of  these  modules  used during the design process in the collaborative environment.

此一框架重要工作, 為在協同環境中的設計流程, 如何進行模組的整合.

The proposed collaborative  framework  allows  the  integration,  which  is  capable  of  revision  for  the functional model at that instance with any changes made by individuals.

這裡所提出的協同框架允許這項整合, 能在個別設計變更的當下, 完成功能模型的改版.
   
The tools used during the product development process vary with the design teams and the vendors.

而在產品開發過程中所使用的工具則因設計團隊與供應商而有所不同.

Problems may arise in sharing the information in different forms.

資訊以不同形式分享時, 也可能產生問題.

Also, sometimes it is very difficult to convert the data or information from one form to the other. This necessitates the  vendors’ involvement at early stages of the development process.

而且, 將某一資訊轉成另外一種格式也並不容易. 因此才需要供應商, 在開發流程的起始階段就務必參與.

The developed system allows the designer to collaborate with the vendors and other team members to optimize the design process considering the relationship within these modules.

此一開發系統允許設計人員, 供應商與其他團隊成員進行協同, 以求能在這些模組的結合下進行設計最佳化流程.

1.3.1 System Overview    系統概述

The  problem  of  gearbox  design  is  decomposed  and  distributed  among  the different  design  teams.

齒輪箱設計問題細分並分配給不同的設計團隊.

At  the  system  level  the  gearbox  design  problem  has the requirements in terms of design variables and the required output performance characteristics.

在系統層級, 齒輪箱設計問題必須表示為設計變數以及所需的輸出品質特性.

Along with the design variables there are design constraints like low weight and low cost. Table  1.1  shows the decomposition and distribution of the problem.

配合各設計變數, 各有諸如最小重量與最小成本的設計約束. 表 1.1 中顯示此一問題的區分與分配.

The distribution of tasks is done on the basis of the tools used. For this particular design problem different tools and modules considered are analysis tool, optimization team, vendor catalogs, and CAD modeling.

而各任務的分工以所使用的工具作為 (考量) 因素. 針對此一特殊的設計問題, 不同工具與模組的考量包括分析工具, 最佳化團隊, 供應商型錄, 以及 CAD 模擬.

These phases represent different design teams  that  are  geographically  dispersed.  The  original  equipment  manufacturing (OEM) team is the final user of the system.

這些階段代表散佈在不同地理位置的不同設計團隊. 原始設備製造商團隊為此一系統的最終用戶.

The OEM user enters or changes the design variables and constraints according to the product requirements.

原始設備製造商用戶能夠針對產品需求, 輸入或改變設計變數與約束條件.

The user interface is illustrated in Fig.  1.6 .

使用者介面如 1.6 圖所示.

These variables and constraints are mapped to the  analysis tool  with the use of file  wrappers. 

這些變數與約束條件則對應到分析工具與相關說明文件.

The  analysis  module  is  the  team  of  individuals  who  compose  the design  problem.  The  analysis  module  team  performs  the  numerical  analysis  and generates the possible alternatives. The design problem and the alternatives are then evaluated at the  optimization module.

分析模組是由處理設計問題的團隊成員所組成. 分析模組團隊負責數值分析並提出可能的替代方案. 這些設計問題與替代方案, 再交由最佳化模組進行評估.

The optimization module retrieves the catalogs from the vendor(s) and generates the results in the form of best configuration of the system components.

最佳化模組由供應商型錄中擷取資料, 產生這些系統元件的最佳組合結果.

The  optimization tool  put the catalogs in every instance of the design procedure and evaluates against the design problem and constraint. “Vendor A” is the supplier for the gears and has the set of design catalogs for different gears.

The catalogs are the replaceable modules containing technical specification of the components. The CAD modeling group is responsible for creating the parametric models for the system components.

The optimization group sends the results to the CAD station.

These results include the geometric details, material specifications, and the analysis data.

The CAD modeling group then generates the solid models on the basis of these results. If there are any modifications, the new parameters are sent
back to the analysis module for the analysis.

This  cycle  continues  until  all  the  groups  approve  the  design  and  it  meets  the functional requirements. Once the design is finalized, the CAD models are created and sent to the user interface.

1.4    System Structure and the Components

The proposed framework is shown in the Fig.  1.7 . It consists of five phases: analysis tool,  collaborative  environment,  optimization  module,  CAD  modeling,  and  vendors’ catalogs.

An  integrated product  design approach for the design of single-stage speed reducer with a pair of spur gear is structured using the developed system.

The design  problem  is  composed  of  analysis  for  performance  characteristics,  catalog selection for vendor supplied items, and CAD modeling for selected alternatives.

The product is decomposed into the primary functional system, subsystems, and the components.  Maintaining  interdependency  among  these  subsystems  and  components is very important so as to work as a system.

It is also important to consider the attributes such as standardization, modularity, future changes, and ease of manufacture and assembly.

For the outsource components, the vendors have to contribute with associated design and engineering.

In the detail design process, further engineering is done for individual components in the system.

The automated generation of 3-D computer models for different alternatives can serve as unique data model throughout  the  development  process  and  eliminate  and/or  reduce  the  changes  of redundancies. 

1.4.1    Collaborative Environment

Software integration is a complex process that requires a courtly solution.

There has been significant advancement in the data-sharing techniques.

The critical issue is maintaining the relationships and dependencies among the different types of data.

The data and the information in the proposed system are categorized and defined as modules.

The collaborative environment is the integration of all the  modules  and the  catalogs.

The ModelCenter ®  is used as a service protocol, which connects different modules and catalogs keeping the corresponding relationship as shown in Fig.  1.8.

ModelCenter ®  is an application that allows users to graphically interact with the modules and generate links between dissimilar applications.

During the assembly and the integration of these modules, the design teams can perform the analysis, the optimization, and the trade studies of system level parameters.

AnalysisServer ®  is another  application  by  Phoenix  Integration,  Inc.,  that  integrates  these  models  by wrapping techniques over the network.

The parameters defined in the design problem are the elements of these models.

The file wrappers are created to link the input data file (user interface) and the analysis tool.

Once the analysis tool calculates the preliminary parameters, the file wrapper maps these values for the optimization module.

The results of optimization are returned to the user interface where the user can comprehend these for further changes.

Concurrently,  this  set  of  results  is  sent  to  the  CAD  modeling  module.  Solid models are automatically generated for different components of the product. 

1.4.2    Analysis Phase

The design problem is composed of input parameters entered by the user.

These are the input and output performance characteristics for the design analysis.

The design problem is mapped to variables and synchronized with the analysis tool using the ModelCenter ®  wrapper file.

The analysis tool is introduced to set the decision variables  and  their  evaluation.

This  application  anatomizes  the  design  problem  and gives feedback in terms of the performance requirements for different elements in
the system.

When the user enters/changes the parameters and run the analysis, the wrappers map these as variables and the AnalysisServer ®  updates the associated variables in the model file.

The analysis tool evaluates these parameters and generates  the  possible  alternatives.

These  alternatives  are  then  further  analyzed  along with the optimization criterions. 

1.4.3    Optimization Phase

The  catalogs  are  the  structured  databases  at  the  vendors’  site.

The  optimization module  team  can  retrieve  these  catalogs  on  limited  access  basis. 

Here  “limited access”  means  that  the  optimization  module  team  can  only  retrieve  the  specific information but cannot modify it.

During the optimization run the queries are created which retrieve only a particular catalog from the vendor station.

It eliminates some of the issues for the information security. The optimization tool maps these replaceable modules from the catalogs for every instance and places them in the current  design  alternative  until  the  suitable  match(s)  is  found.

The  optimization module selects the components from the catalogs and returns to the user interface as  results .

This gives the user the detailed specifications for the product and its elements.

The  results  obtained  are  the  parameters  obtained  from  the  catalogs, which  gives  the  optimum  performance  for  the  given  design  requirements  and
constraints. A sample code is listed in Fig.  1.9.

The  results  obtained  from  the  analysis  tool  gives  theoretical  values  for  the parameters that are acquired from empirical relations.

The optimization model is developed to get the configuration, which satisfy the given constraints optimally.

The relationships are imposed between the design variables from the design problem and  the  constraints  from  the  modules.

The  optimization  tool  runs  an  iterative procedure.

The modules from the catalogs are retrieved and placed into the current design instance.

The modules that satisfy the design constraints and the available components from the vendor catalogs are then selected as alternatives.

The graphical comparison of these alternatives is presented at the user interface, which helps the user to trade off for size and cost.

Depending on the requirement, the user can then manipulate the design variables to get the best possible configuration.

Once the  configuration  is  finalized,  the  program  files  for  CAD  modeling  are  created automatically to generate the solid models of the components.

In this case study, a pair of gear is selected from the catalogs and then evaluated for load, power, and other characteristics defined in the design problem.

Figure  1.10  illustrates the comparison chart used by the engineer in order to evaluate the alternatives.

1.4.4    Parametric CAD Modeling

Another important module of the proposed framework is  parametric CAD Modeling.

The parametric models for different components are created (Fig.  1.11 ).

The results obtained from the optimization module are used to create the 3-D solid models of each element in the system.

These CAD models assist the designer to visualize the interaction  of  the  components  for  a  given  configuration.

An  automated  design dramatically reduces the time spent in generating the results for several alternatives.

It also serves as a basis for generating detailed documentation for the manufacturing.

A Visual Basic code is used to edit the program files with the newly calculated variables.

The parametric models are created for each component in the system for optimized configuration.

IDEAS  is the CAD tool used in the system. However, any CAD software can be used.

For the synchronous, real-time application, parametric models are created.

The parametric model allows the user to update the model according  to  any  change  in  the  design  process.

For  the  gear  models,  pitch  circle diameter is a reference dimension and all the other geometric dimensions are constrained and defined using the equations. Once the optimization module generates the alternatives and the results, they are conveyed to the parametric models.

The change in pitch circle diameter updates the geometry.

The solid models of the components are generated and can be displayed at the user interface in picture format.

Solid model for a gear and the respective shaft is shown in Fig.  1.12.

For every change in the design process, the users can retrieve the corresponding CAD models.

This gives the designer a chance to visualize the different alternatives and the optimum configuration of the component.

The proposed framework provides the means of integrating software tools that enables  the  designers  to  foresee  the  overall  product  and  enterprise  fulfillment during development phases.

It will reduce the time required for repetitive analysis for different alternatives.

Thus the designer can evaluate more alternatives and can obtain the optimal solution.

This integrated system allows the designers to participate in the design process irrespective of geographical location.

The developed system provides the capability for design of templates for catalog-based design.

Vendors can participate in the development process with their items as catalogs.

The optimization phase offers the designers a chance to evaluate different alternatives and the trade-offs.

1.5    Conclusions

Today’s  manufacturers  encounter  various  difficulties  involved  in  the  product development process and these must be overcome for international competitiveness.

The  obstacles  include  shortened  product  life  cycle,  high-quality  product,  highly diversified  and  global  markets,  and  unexpected  changes  in  technologies  and customer needs.

Any delays in development and you run the risk of losing revenue to your competition.

Also the companies are heading toward vendor-based manufacturing (i.e., the manufacturers are trying to get most of the work done by the vendors  so  as  to  minimize  the  time-to-market).

Hence  it  is  essential  to  utilize  a computer-aided  system  in  designing,  manufacturing,  testing,  and  distributing  the products  to  minimize  the  time-to-market.

For  the  integration  of  information  at every stage of product development there is need for collaborative technology for job collaboration.

As the assistant of the design and development of new products, integrated design technology plays a very important role.

The described framework confirms design assumptions and predicts product performance in the early stages of  the  design  process.

This  results  in  a  faster  product  development  cycle—with lower associated costs—achieved by eliminating the need to constantly build, test,
and redesign. 
.. @+node:amd_yen.20130320201815.1572: *6* 參考資料
@nocolor

This  chapter  presents  an  integrated  framework  for  distributed  and collaborative environment, which could assist organizations to achieve integrated design goals.

本章提出了一種可用於分散式協同環境使用之整合框架,可協助組織實現整合設計目標.

The proposed system emphasizes the integration of the software tools and the resources involved in the design process to collaborate the geographically dispersed design teams and vendors.

這裡所提出的系統, 特別強調軟體工具與設計流程相關資源的整合, 以利分散在不同地理位置之設計團隊及供應商進行協同.

The advancement in information technology is the driving force for the development of this environment. Also, the early participation of vendors in the design process is considered critical in order to improve the product quality and reduce the development cycle time.

資訊科技的進展除了驅動此一環境的發展. 且讓設計流程中的供應商得以及早參與 (協同工作), 並在改善產品品質與縮短開發時間的過程中, 成為關鍵點.

Advances in IT have enabled designers to more effectively communicate, collaborate, obtain, and exchange a wide range of design resources during development.

資訊科技的進展, 也讓設計者得以在開發過程中, 更有效率地進行設計資源的溝通, 協同, 取用與交流

Many manufacturing companies are publishing their product information on the Internet.

許多製造公司 (選擇) 將其產品資訊, 發布在網際網路上.

The  network oriented  design  environment  is  a  new  design  paradigm  for  product development.

以網路作為基礎的設計環境, 則被視為產品開發的全新設計規範.

An integrative framework that enables designers to rapidly construct performance models of complex problems can provide both design insight and a tool to evaluate, optimize, and select better alternatives.

一個能促成設計者快速建構複雜問題的性能模式之整合框架, 可同時提供設計上的深刻體察與工具, 來進行評估, 最佳化並選用更好的替代方案.

Furthermore, a design problem constructed from modeling components made available over Internet might facilitate
the collaborative development of analytical system models in addition to the exchange of  design  information. 

此外, 由模擬元件著手建構的設計問題, 一旦可透過網際網路進行, 就能在設計資訊交換之餘, 有助於分析系統模型的協同開發.

A  well-defined  integrated  model  will  predict  the  required product  properties  and  evaluate  alternative  solutions  in  order  to  meet  the  defined design objectives and performances.

一個定義完善的整合模型, 除了可預測所需的產品性能外,  還能評估替代方案, 以達成預定的設計目標及特性.


Key to the analysis of any problem is the identification of what functions are performed and  the  relationships  between  them.

任何問題的分析關鍵, 取決於各功能的確認與之間的關聯.

A  collaborative  engineering  development process includes a set of activities and functions arranged in a specific order with clearly defined inputs and outputs.

一個協同工程開發流程, 包含一組能夠清楚定義輸出入, 且依照特定次序進行的活動與 (其所能呈現的) 功能.

Each activity in the process will take a set of inputs and transforms it into an output of some value.

該流程中的每一項活動, 接受一組輸入後, 可轉換成特定有價值的輸出.

The process is considered efficient, when the output of the process satisfies the general customer and product requirements and meets management objectives and cost.

流程中若其輸出符合一般客戶與產品需求, 並達成管理目標及成本上的要求, 就可視為有效執行.

New technologies and tools along with advancement in IT are helping these organizations in several ways. However, there is no established generic implementation model for wide range of industries.

資訊科技進展中所帶來的新技術與工具, 即便能在許多層面上協助組織 (進行協同), 但是各行業涵蓋面之廣, (至今) 仍然沒有能夠一體適用的基本實務模型.
   
Software vendors may provide "custom" software packages for individual firms.

軟體供應商則可提供客制化的軟體套件給個別公司.

Different industries have different product development strategies, which demand a generic framework that will help them collaborate efficiently irrespective of their product, organizational structure, and/or geographical location.

(儘管) 不同產業有不同的產品開發策略, (但是) 不論其產品, 組織架構與/或地理位置 (的差異), 仍需要一套通用框架來有效協助進行協同.

Two of the more important elements in this changing environment are increased product sophistication and variation.

在此一變動的環境中, 兩項較為重要的元素就是增加產品的細緻度與多元性.

Minimizing the total costs and being quick to develop and market new products is the key for survival.
   
以最少成本快速進行新產品開發與行銷是生存的關鍵.

Product development is a complex process requiring  expertise  from  several  fields. 

產品開發是一種需要多種領域專業知識的複雜流程.

This  will  demand  integrating  the  diverse functional areas of an organization on a common platform.

這就需要在一個共用平台上置入組織中多元領域功能的整合.

In  this  chapter,  an  integrative  framework  that  would  enable  the  design  teams rapidly  construct  performance  models  of  complex  design  problems  is  presented.

在本章節, 將介紹一種可促使設計團隊快速建構複雜設計問題之性能模式的整合框架.

This framework can provide both design insight and a tool to evaluate, optimize, and  select  better  alternatives.

此一框架可同時提供設計上的深刻體察與工具來執行評估, 最佳化並選擇更好的替代方案.

Interaction  between  the  elements  at  every  level  of design is a critical issue.

在每一設計層面上, 各元件之間的互動, 都是重要議題.

The framework should not be limited only to internal function integration but it should also consider the external functions such as vendors.

而此一框架並不侷限於內部功能的整合, 還包括外部功能, 諸如供應商  (的整合).

The vendors have precise and detailed knowledge for their items.

這些供應商對於所提供的元件擁有精確且細緻的知識.

This expertise should be incorporated in the main development system to ensure and optimize the product as  a  complete  system.

這種專精 (知識) 應該納入主開發系統之中, 並促使產品能最佳化成一完整的系統.

The  templates  for  different  processes  and/or  procedures should be designed systematically to assist in evaluating and optimizing the design alternatives through proper integration and analysis. 

不同流程與/或步驟所依循的固定模式應該進行系統化設計, 以及適當的整合及分析, 協助進行設計替代方案的評估與最佳化. 

#####################################################

Integrated product development is recognized as a critical part of the development of competitive products in today’s global economy.

今日全球化經濟 (環境中), 整合產品開發 (流程) 是開發具競爭產品的重要關鍵.

As a company grows larger  and  products  become  more  complex,  hierarchical  organizations  are  established to master the increasingly large organization size, the technical complexity, and  the  specialization  that  evolves  to  master  this  complexity. 

當公司不斷擴大, 產品日益複雜, 階層式的組織被用來主導日益擴大的範圍與複雜的技術, 且必須越來越專業化才能掌握其複雜度.

This  growth  also results in the geographic dispersion of people and functional departments.

此一成長同時帶來分散在不同地理位置的人員與具備不同職能的部門.

These factors inhibit many of the informal relationships that previously provided effective communication  and  coordination  between  functions.

這些因素讓 (過去) 許多部門間非正式的關係 (結合), 有效的溝通與協調變成較難開展.

A  hierarchical  organization structure with enterprise activities directed by functional managers becomes incapable of coordinating the many cross functional activities required to support product  development  as  the  enterprise  moves  toward  parallel  design  of  product  and process and a focus on time-to-market.

以企業活動作為主導的階層式組織架構中的部門管理者, 已經無法在許多跨部門的活動間進行溝通, 不僅無法以同步產品設計的方式達成企業目標, 更無法顧及 (產品) 上市時間.

Product development teams are a way to address this complexity by organizing the necessary skills and resources on a team basis to support product and process development in a highly interactive, parallel collaborative manner.

產品開發團隊以合作的方式, 除了能應付產品與製造開發過程中的高度互動與同步協同外, 更可集結 (組織中) 必要的技能與資源, 來解決這種 (與產品相關的) 複雜性.

Some of the basic principles and guidelines for an integrated product development are as follows:

整合產品開發的基本原理及準則如下:

1.      Understand  Customer  Needs  and  Manage  Requirements:  Customer  involvement
increases the probability of the product meeting those needs and being successful in the market.

了解客戶需求與管理需求: 客戶參與是提升產品滿足需求與市場成功的最大保證.

Once customer requirements are defined, track and tightly manage those requirements and minimize creeping elegance that will stretch out development.

一旦客戶需求能夠加以定義, 追蹤並密集管理, 就可以減少摸索並快步進行開發.

2.      Plan  and  Manage  Product  Development:  Integrate  product  development  with the business strategy and business plans. Determine the impact of time-to-market on product development and consider time and quality as a source of competitive advantage.

規劃並管理產品開發: 依照商務策略與規劃進行整合產品開發. 擬定產品開發對上市時間的衝擊, 並將時間與品質當作競爭優勢的源頭.

3.      Use Product Development Teams:  Early involvement of all the related departmental personnel in product development provides a multifunctional perspective and facilitates the integrated design of product and process.

運用產品開發團隊: 產品開發中讓相關部門人員及早參與, 有助於在產品與製程之整合設計 (過程中), 獲得多功能觀點.

4.      Involve Suppliers and Subcontractors Early:  Suppliers know their product technology, product application, and process constraints best.

及早讓供應商與分包商參與 (產品開發): 供應商最了解其產品技術, 產品應用與製程限制.

Utilize this expertise during product development and optimize product designs.

在產品開發過程中, 運用這些專業技術來最佳化產品設計.

5.      Integrate CAD/CAM and CAE tools:  Integrated CAD/CAM/CAE tools working with a common digital product model facilitate capture, analysis, and refinement of product and process design data in a more timely manner. Feature based solids modeling, parametric modeling, and electronic design frameworks facilitate the downstream interpretation, analysis, and use of this product data.

整合 CAD/CAM 與 CAE 工具: 在共用的數位產品模型中, 整合 CAD/CAM/CAE 工具, 有助於及時獲取, 分析與係化產品與製程設計資料. 採特徵為主的實體模型, 參數模擬, 與數位設計框架, 將有助於 (產品鏈) 下游對於產品資料的整合, 分析, 與運用.

6.      Simulate Product Performance And Manufacturing Processes Electronically:  Solids
modeling with variation analysis and interference checking allow for electronic mock-ups.

以數位的方式進行產品性能及製造流程模擬: 可變化的實體模擬與干涉查核, 可作為數位 (產品) 原型.

Analysis and simulation tools such as finite element analysis, thermal  analysis,  network  computer verification,  and  software  simulation can be used to develop and refine both product and process design inexpensively.

諸如有限元素分析, 熱分析, 網路計算機確認與軟體模擬等之分析與模擬工具, 可以低廉花費來開發並細化產品與製程設計.

7.      Improve the Design Process Continuously:  Reengineer the design process and
eliminate non–value-added activities.

持續改進設計流程: 多次重複檢視設計流程可消除無附加價值的活動.

Continued integration of technical tools, design activities, and formal methodologies will improve the design process.

以連貫的方式, 加以整合技術工具, 設計活動, 與制式方案, 將可改進設計流程.

Design refers to the activities involved in creating the product structure, deciding on  the  product’s  mechanical  architecture,  selecting  materials  and  processes,  and engineering  the  various  components  necessary  to  make  the  product  work.

設計所指的活動包括, 建立產品結構, 決定產品機械架構, 選擇材料與製程, 考量各種元件所需的工程方法, 以達到有效的產品機能.

Development refers collectively to the entire process of identifying a market opportunity, functional  requirements,  and  finally  testing,  modifying,  and  refining  the  product until it is ready to manufacture.

而開發則指整個過程中的統合工作, 包括確定市場機會, (產品) 所需功能, 以及最終的測試, 修改, 逐步細化產品至能夠加以製造.

The development of a product is time-consuming, lengthy, and costly.

產品開發不僅耗時, 冗長, 而且還很花錢.

In a typical product development process the design occurs largely before final full-scale manufacturing.

典型的產品開發過程, 設計工作必須在全面投入生產之前完成.

In most of the cases this design is later altered or refined for  the  manufacturing  difficulties,  which  leads  to  increased  cost  and  time. 

多數情況下, 若因製造問題而被迫修改設計或細化設計, 將會導致成本與時間的增加.
   
The manufacturing  department  is  responsible  for  estimating  the  feasibility,  cost  of building  the  prospective  new  product,  and  modifications,  if  necessary.

製造部門負責預估可行性, 建構新產品所需費用, 以及 (執行) 相關修改.
   
If  the decision has been taken to outsource some of the components in the final product, the  vendors  come  into  direct  consideration. 

一旦決定要將最終產品的某些元件交給外包, 就會直接考慮 (採用) 這些供應商.

The  vendors  become  a  part  of  the design team, as they will be contributing toward the development of the final product.

供應商就成為設計團隊的一部分, 負責 (某些) 最終產品的開發工作.

Hence, it is very important to consider the vendors’ involvement in the design process beginning  from  the  initial  stages  of  the  design  and  development  of  the  product.

因此, 在產品設計開發的初始階段, 就讓這些供應商參與就顯得非常重要.

Thus,  in  any  product  design  and  development  scenario  the  interaction  among marketing,  engineering,  manufacturing,  and,  in  most  cases,  the  vendors  is  very important.

多數情況下, 在任何產品設計開發流程中, 供應商在行銷, 工程與製造的互動也很重要.

This  requirement  is  met  by  the  application  of  collaborative  product development.

這些需求都是以協同產品開發的方式達成.

In the collaborative  product development process, the feasibility for product life cycle is analyzed during the early stages of the design process.

在協同產品開發流程, 產品生命週期的 (各種) 可行性, 在設計流程的初期就 (必須) 開始進行分析.
   
The expertise from several fields is considered absolutely essential at every stage of the development process.

在開發流程中的各個階段, 來自各領域的專業 (知識) 是絕對必要.

The expertise is grouped in different teams.

這些專業劃分為不同團隊.

Each team is responsible for its contribution throughout the process.

每一個團隊在整個過程中專職負責.
   
In the current market trend such teams are mostly dispersed geographically.

就目前市場趨勢, 此一團隊大多分散在不同地理區域.

The need for integration continues when the design enters the preliminary and detail design phases.

整合需求將在初步到細部設計階段過程中持續進行.

In an integrated, collaborative design environment, designers interact by sharing information.

在一個整合協同設計環境中, 設計者以互動的方式來共享資訊.

By considering proper integration and interaction from  the  beginning,  the  problems  with  the  final  integration  of  activities  can  be significantly reduced.

若能一開始就適當整合與互動, 將可有效減少在最終整合活動中所產生的問題.

In this context, an integrated system is desired to reduce the overall  design  cycle  time  by  eliminating  the  repetitive calculations  to  obtain optimum  results.

在此情況下, 就需要在一個整合系統中, 無需重複計算就能取得最佳結果的方式, 以縮短整體設計週期時間,

The  important  stage  of  collaboration  is  breaking  the  barriers among departments and individuals.

協同 (過程中) 的重要階段 (任務), 就是破除部門與個人之間的壁壘.

This open environment increase groups productivity.

此一開放環境可增加群組的生產力.

Collaborative  product development practices are recognized as critical to the development of competitive products in today’s dynamic market.

協同產品開發的落實, 在今日動態市場中, 已被公認為產生競爭性產品的重要關鍵.

A hierarchical distribution of work is essential for large organizations and complex products.

而在大組織與複雜產品 (的產品開發), 也需要階層式的工作分工 (模式).

This structure also results in the geographic dispersion of people and functional areas.

此一架構導致員工分散在不同地理區域與 (不同) 專業領域.

The typical integrated environment is shown in Figure  1.2 . Product development teams are formed with personnel from various functional departments to support different stages of the development process including the production and services.

典型的整合環境如圖 1.2 所示. 產品開發團隊的組成, 包含不同專業部門的員工, 來負責生產與服務開發流程中的不同階段工作.

This early involvement will result in a complete understanding of all the requirements  and  a  consensus  approach  to  the  design  of  both  the  product  and  its manufacturing and support processes.

這種早期參與能獲致對所有 (產品) 需求的充分了解, 並對產品設計製造所需配合的流程產生共識.

Product development teams promote open discussion and innovative thinking resulting in superior products, more efficient processes, and, ultimately, a more satisfied customer.

產品開發團隊促使開放討論與創新思維, 其結果為更優越的產品, 更有效率的流程, 以及最終得到一個更滿意的客戶.

The focus of the team will be to satisfy the external customer’s  product  and  support  requirements  as  well  as  the  internal  customer (functional department) requirements related to factors such as producibility, cost, supportability, and testability.

團隊的著眼在於滿足外部客戶對於產品與支持的要求, 同時也達到內部客戶 (專業部門) 有關可製性, 成本, 支援與可試性的要求.

For an effective distribution of activities among the design teams, the structured approach is very important.

為在設計團隊間有效進行工作的分配, 按部就班的方法就顯得非常重要.

The distribution process should start with the product definition and end with manufacturing of the product.

流程 (工作) 的分配以產品定義開始, 而以產品的製造作為結束.

The first step toward effective integrated product development is the understanding and management of customer requirements.

有效率整合產品開發工作的第一步, 就是了解客戶需求, 並加以管理.

The product definition  and  the  structure  should  be  based  on  the  well-understood  customer requirements.

產品定義與架構, 應該要依據對於客戶需求的充分理解.

These requirements should be evaluated and refined considering the expected time-to-market and quality of the product.

這些需求應該要加以評估並且細化, 並且考量所需上市的時間以及產品的品質.

The early involvement of all the related departmental personnel in the development process provides a multifunctional perspective.

讓所有相關開發流程中各部門人員及早參與, 可提供多功能專業的觀點.

This  helps  reducing  and/or  eliminating  the  redundancies  of  data  and manufacturing  issues.

有助於降低, 甚或消除重複資料與製造問題.

Today's  dynamic  market  demands  more  outsourcing  from vendors.

今日的動態市場需要更多來自供應商的外包業務.

The utilization of this expertise could help in improving product quality, optimize the product at the system level, and reduce the cycle time.

這些專業的運用有助於改進產品品質, 最佳化產品系統層級, 並且縮短循環時間.

Along with the expertise from different fields and the vendors, the distribution and integration of the resources is also critical.

來自供應商不同領域的專業技術, 將資源進行分工與整合也是非常重要.

The integration of different CAD/CAM/CAE tools could shorten the development process and optimizes the design.

不同 CAD/CAM/CAE 工具的整合, 也能縮短開發流程, 產生最佳化的設計.

The use of common electronic product model reduces the chances of redundancy and errors.

共用數位產品模型的使用可減少重複與錯誤的機會.

The feature-based solids modeling,  parametric modeling , and electronic design  frameworks  facilitate  the  analysis  and  use  of  product  data  among participating  teams.

以特徵為主的實體模型, 參數模擬, 與數位設計框架, 有助於進行分析, 並可在參與的團隊間使用產品資料.

With  the  advancements  in  information  technology  IT,  it  is possible  to  electronically  simulate  product  performance,  interface  checking,  and manufacturing  feasibility.

資訊科技的進展, 讓電子化的產品性能模擬, 介面查核與製造可行性等 (評估) 成為可行.

This  helps  in  refining  the  product  and  the  processes from manufacturing perspective.

並能在產品與製程的細化過程中, 考量到製造的相關問題.

This overall development process should not be set as standard and needs to be improved as it progresses.

全面開發流程不應設成標準 (模式), 而必須在進行過程中不斷加以改進.

Figure  1.3  illustrates an example of how design is done using a heterogeneous environment.

圖 1.3 標示如何在多元差異的環境中完成設計.

Central to the design of this system is the interlinking mechanism of the data from different data resources.

系統設計的核心 (工作) 即為來自不同來源的資料, 如何進行互相連結的機制.

This link allows for transmitting results from one module to another.

此一連結允許由某一模組的結果轉換到另一模組.

The second important part of this design is the parametric databases.

設計的第二項重要工作就是參數化的資料庫.

Creating the databases is one of the crucial parts in the design of this integrated environment.

建立資料庫也是在此一整合環境設計 (流程中), 重要的事項之一,

The databases are built using information (parametric data, models, etc.) supplied by different vendors, design rules, manufacturing, and other pertinent data.

資料庫的建立, 來自不同供應商, 設計原則, 製造, 以及其他相關資料所產出的資訊 (包括參數資料, 模型等).

Using input module(s)  designers  participate  in  the  design  and  analysis  process.

採用輸入模組, 設計者 (得以) 參與設計與分析的流程.

Designers  can input variables and perform necessary calculations and integrated analysis.

設計者可以輸入變數, 進行必要的運算與整合分析.

Figures  1.4  and  1.5  illustrate the scope of integration for the I/O modules and databases. 

圖 1.4 與 1.5 說明這些輸出入摩組與資料庫整合的 (應用) 範圍.

Many researchers are working on developing the technologies or infrastructure to support the distributed design environment.

許多研究者致力於開發可以支援分散設計環境使用的技術或基礎建設 (架構).

Some are working on providing a platform for sharing or coordinating the product information via the World Wide Web.

有些則在全球資訊網路上, 提供分享或協調產品資訊用的平台.

Others are developing the framework that enables the designers to build integrated models and to collaborate by exchanging services.

有些則開發能夠讓設計者建立整合模型並互換服務的框架. 
.. @+node:amd_yen.20130316100629.1527: *4* sgsML 語言
基本概念:
    
   Simple Groupware 中的相關模組基本上都是利用 sgsml 所編寫, 並且位於 bin/modules/schema, 並且所有的模組都登錄在 bin/modules/schema/modules.txt 中, 而且模組所對應的 .xml 位於 bin/modules/schema 目錄中.
    
資產的權限管理:

    Simple Groupware 除了文件夾可以設定權限外，也可以設定個別模組下相對資產(asset)的權限。共有下列三種不同類型的資產權限設定：
    
    “Full”是指賦予該資產讀取與編寫的權限，默認設置對象為匿名者。換言之，若將模組的資產擷取權限設為 Full, 表示所有的用戶對於該模組項下的所有內容都具備讀取與編寫的權限。
    
    “Owner write”是指賦予該資產的所有人具有編寫的權限，默認設置對象為資產所有人。換言之，若將模組的資產擷取權限設為 Owner write, 表示所有的用戶對於該模組項下的所有內容只具備讀取的權限，而資料的擁有人則具備修改的權限。
    
    “Owner read”是指賦予該資產的所有人具有讀取的權限，默認設置對象為資產所有人。換言之，若將模組的資產擷取權限設為 Owner read, 表示只有該資料的擁有人則具備修改與讀取的權限。
    
使用資產權限模塊的案例：
    
    Files 與 CMS 就是採用 Full 資產權限設定，Forum 則採用 Owner write，Timesheets 與 Expenses 則使用 Owner read 權限設定。
    
    使用者可以在各模組對應的資料編輯區中的 permissions 檢視各模組的資產權限設定。
    
    以下則為 My Addresses 模組的資產設定 (為 owner_read):
    
    <table modulename="My Addresses" default_view="display" orderby="lastname" order="asc" limit="20" enable_new="true" enable_edit="true" enable_delete="true" enable_empty="true" enable_asset_rights="owner_read">
    
    其中的 enable_asset_rights="owner_read" 表示將此模組設為: 只有資料的擁有者 (以及管理者) 可以看到自己新增的資料, 當然資料擁有者 (以及管理者) 也可以修改自己的資料, 其他用戶則看不到其他人所建立的相關資料.
    
資產的刪除權限設定:
    
    假設模組的權限設定使用 enable_empty="true", 表示具有編輯權限的用戶, 可以透過 empty 指令 (垃圾桶) 將整個模組中的 assets 全部刪除 (其中包括他人所建立的 assets).

    假如拿掉 enable_empty="true", 而讓使用者對該模組有編輯權限, 則使用者只能刪除自己新增的相關資料.

    此外, 某一檔案夾中的特定模組需要讓使用者擁有寫入編輯的權限, 該檔案夾應該只需要能夠讓使用者讀取即可, 而無需給 write access 的權限(因為 write access 同時擁有刪除的權限), 但是必須在 view 中設定 write 的權限.
    
    亦即, 可以將某一檔案夾設為成員可以讀取, 但無法寫入, 然後在 view 的部分設定

    ``|new,edit:write:anonymous|``
    
    也就是任何人都可以擁有 new 與 edit 的寫入權限, 就可以有效保護該檔案夾, 不被成員刪除或改名, 但是成員可以新增與編輯, 然而卻無 delete 的功能, 若也要讓成員對於 assets 有刪除權限, 則必須要修改 write 的權限, 將內定的檔案夾權限刪除與改名權限由 write 提升到 admin, 然後授與該檔案夾的 write 權限給相關成員, 就可以讓成員對檔案夾內的 assets 有 delete 權限.
    
Simple Groupware 模組欄位的修改:
    
    從 0.720 版開始, 各模組的欄位可以直接在線上進行修改, 修改步驟:

        1. 登入管理者帳號.
        
        2. 進入 Workspace/System/Customize/Fields.
        
        3. 直接輸入要應用到對應欄位的規則, 每一筆規則會對應到某一欄位.
        
        自動系統欄位:

            在表單中不會顯示.

        id: 每一筆資料的唯一代號 (primary key). 包含資料 ID 與伺服器 ID (兩位數), 例如: 若資料代號為 201, 表示資料編號 為 2, 且伺服器編號為 01.
        
        folder: 代表檔案夾編號.
        
        created: 資料建立時間戳記.
        
        lastmodified: 最後更新時間戳記.
        
        createdby: 資料建立者的使用者名稱.
        
        lastmodifiedby: 最後資料修改者名稱.
        
        dsize: 與資料附加檔案的容量大小.
        
        history: 用來追蹤用戶更新資料與欄位的文字資料.
.. @+node:amd_yen.20130320201815.1569: *4* Virtualbox Ubuntu 虛擬主機
利用 VirtualBox 啟動能夠作為虛擬雲端主機的 Ubuntu, 基本的概念為:

1. 讓 VirtualBox 中的虛擬 Ubuntu 利用兩片網路卡, 採 NAT 與 橋接網路卡的模式, 讓 VirtualBox 所在的實體網路卡可以與 虛擬 Ubuntu 網路卡進行橋接, 進而透過橋接設定取得可以為廣域網路連線的設定.

2. Ubuntu 中可以透過 sudo cat  /proc/net/dev  列出系統已經驅動的網路卡, 透過特定代號, 可以在 /etc/network/interfaces 中進行 TCPIP 的設定.

3. TCPIP 設定後, 可以利用 sudo /etc/init.d/networking restart 重新啟動網路設定, 之後利用 sudo ifconfig 查核橋接網路卡對外的 IP 設定值.

4. 設法利用 psftp 將 CMSimple.tar 送進 Ubuntu, 以 tar xvf CMSimple.tar 解開成 CMSimple 之後, 利用 sudo mv CMSimple /var/www/ 將目錄搬遷到 /var/www Apache 的根目錄下, 再進入 /var/www 目錄, 以 sudo chown -R www-data:www-data CMSimple, 表示要將 CMSimple 目錄的所有項下子目錄 ( -R 的作用) 其 owner 與 group 所有人設為 www-data (也就是啟動 Apache 的擁有者與群組), 以便讓網際端的用戶可以寫入 CMSimple.

5. 確定 Ubuntu 的聯外 IP 後, 就可以在廣域網路上擷取 虛擬 Ubuntu 中的 CMSimple, 並且進一步將協同相關的二次開發程式放入此一系統中. 
.. @+node:amd_yen.20130330144838.2032: *3* CD 第五週
建立 sgwa.edx.tw 與 sgwb.edx.tw 作為協同設計主機, 採用 IMAP 登入驗證, 使用注意事項:

::

    1. 使用者的 gmail 帳號是否開啟 IMAP 驗證功能
    
    2. 將 Simple Groupware 登入錯誤過多後, 必須停等 15 分鐘的設定取消
    
    3. 在 Ubuntu 平台安裝 graphivz 模組, 用於專案流程圖繪製

建立 test@mde.tw 電子郵件, 用於 SMTP 寄信使用

建立 exam.edx.tw (即 cae.mde.tw, MySQL 使用 IBM server) 作為線上考試用主機, MySQL 資料庫管理採用 http://www.adminer.org/
.. @+node:amd_yen.20130330144838.2033: *3* CD 第七週
開始執行齒輪減速機設計專案.

正齒輪參數繪圖:

http://www.bvmengineering.ac.in/docs/published%20papers/mechprod/mechprod/601019.pdf

http://dspace.uta.edu/bitstream/handle/10106/5401/Patel_uta_2502M_10935.pdf

下載由 PTC 所提供的 Creo 免費學生軟體:

http://www.ptc.com/appserver/wcms/forms/index.jsp?&im_dbkey=86840

零件繪圖參考資料:

http://ebookbrowse.com/creo-parametric-lesson-18-pdf-d346381732

http://ebookbrowse.com/creo-parametric-lesson-14-pdf-d359801379

http://www.eng.cam.ac.uk/DesignOffice/cad/3rdyear/creo1styear.pdf
.. @+node:amd_yen.20130408141041.2454: *4* Simple Groupware custom 延伸程式
編寫 Simple Groupware 模組程式:

基本步驟:

1. 在 sgw\bin\modules\schema 目錄下, 編寫 custom.xml sgsML 程式.

2. 在 sgw\bin\modules\schema\modules.xml 中登錄 custom.xml 模組, 亦即在檔案中加入 custom|Custom.

3. 編寫 custom.xml 中所宣告的 ../custom/core/classes/custom.php 程式碼, 模組對應目錄以 sgw/bin 為根目錄, 若其中需要 jscript, 則需放到 sgw/bin/jscript 目錄中.

4. 模組架構異動後, 必須清除先前留下的 cache 資料, 然後再進行 custom.xml 模組的功能測試.

以下流程設法將 brython console 改寫為 Simple Groupware 的 plugin: custom.xml

.. code-block:: xml

    <table modulename="Custom PHP include" default_view="display" default_sql="no_select" \
    schema_mode="static" load_library="../custom/core/classes/custom.php">
      <view name="display" displayname="Display" function="get_my_data">
      </view>
      <field name="id" simple_type="id" displayname="{t}Id{/t}">
      </field>
    </table>
    
而 custom/core/classes/custom.php

.. code-block:: php

    <?php
    
    class custom {
      public static function get_my_data($folder, $view, $params) {
        $output = "<b>Hello World</b><br/>";
        $output .= "...<br/>";
        $output .= <<<EOF
    <div class="entry-content">
                <p>換成新的內容 Content</p>
    <p>以 Brython 編寫的線上 Python3 執行環境 (僅支援少數展示用功能):</p>
    <p><script src="jscript/brython/brython.js"></script>
    <script>
    window.onload = function(){
        brython(1);
    }
    </script>
    <script type="text/python">
    import sys
    import time
    import dis
    
    if sys.has_local_storage:
        import local_storage
    else:
        storage = False
    
    def reset_src():
        if local_storage.storage:
            doc['src'].value = local_storage.storage["py_src"]
    
    def to_str(xx):
        return str(xx)
    
    doc['version'].text = '.'.join(map(to_str,sys.version_info))
    
    class cons_out:
    
        def __init__(self,target):
            self.target = doc[target]
        def write(self,data):
            self.target.value += str(data)
    
    sys.stdout = cons_out("console2")
    sys.stderr = cons_out("console2")
    
    output = ''
    
    def show_console2():
        doc["console2"].value = output
        doc["console2"].cols = 60
    
    def clear_text():
        log(" event clear")
        doc['console2'].value=''
        doc['src'].value=''
    
    def run():
        global output
        doc["console2"].value=''
        doc["console2"].cols = 60
        src = doc["src"].value
        if local_storage.storage:
            local_storage.storage["py_src"]=src
        t0 = time.time()
        exec(src)
        output = doc["console2"].value
        print('<done in %s ms>' %(time.time()-t0))
    
    def show_js():
        src = doc["src"].value
        doc["console2"].cols = 90
        doc["console2"].value = dis.dis(src)
    </script>
    <table width=80%>
    <tr><td style="text-align:center"><b>Python</b>
    </td>
    <td>&nbsp;</td>
    <th><button onClick="show_console2()">console2</button></th>
    <th><button onClick="show_js()">Javascript</button></th>
    </tr>
    <tr><td colspan><textarea id="src" cols="60" rows="20">def 執行函式(次數, 字串):
        for 索引 in range(次數):
            print(字串)
    
    執行函式(5, "Brython 可以執行")</textarea></td><td><button onClick="run()">run</button></td>
    <td><button onClick="clear_text()">clear</button></td>
    <td colspan=2><textarea id="console2" cols="60" rows="20"></textarea></td>
    </tr>
    <tr><td colspan=2>
    <p>Brython version <span id="version"></td>
    </tr>
    </table>
    </p>					</div><!-- .entry-content -->
    
    EOF;
    
        /* Smarty can be also used here (templates are in templates/*):
         *
         * $output .= sys::$smarty->fetch("custom.tpl");
         */
    
        // use echo $output to avoid output filtering for bad HTML and Javascript
        return $output;
      }
    }
.. @+node:amd_yen.20130413002743.2095: *3* CD 第十週
有關 CAD 系統:

與其他機械設計團隊進行協同之前, 必須對於全球目前的 CAD 生態有所了解, 因為其他團隊可能使用不同核心技術套件或不同版次的軟體, 通常協同過程經常需要轉檔.

Kernel 技術:

德國 Siemens - Parasolid (原為美國 UGS 公司所有, 後來被 Siemens 收購)

    http://en.wikipedia.org/wiki/Parasolid

    http://www.plm.automation.siemens.com/en_us/products/open/parasolid/index.shtml
    
法國 Dassault - ACIS (2000 年併入)

    http://en.wikipedia.org/wiki/ACIS
    
    http://www.spatial.com/products/3d-acis-modeling
    
法國 Open CASCADE - 開放源幾何模擬核心

    http://www.opencascade.org/

俄國 ledas

    http://www.ledas.com/

CAD 套件;

美國 PTC - Creo, 採用 Granite One kernel.

    http://www.ptc.com/product/creo/

法國 Dassault - Catia (採用 Catia Geometric Engine), SolidWorks(原為美國公司開發, 被法國達梭公司收購), 原 SolidWorks 採用 parasolid 核心, 目前正在改用 Catia 核心.

    http://www.3ds.com/

德國 Siemens - NX, Solid Edge (NX 與 Solid Edge 原為美國 UGS 公司開發, 被西門子收購), 均採用 parasolid 核心.

    http://www.plm.automation.siemens.com/en_us/
    
美國 AutoDesk - Inventor (採用由 ACIS 核心衍生出來的 ShapeManager kernel)

    http://www.autodesk.com/products/autodesk-inventor-family/

俄國 T-Flex (採用 parasolid 核心)

    http://www.tflex.com/

中國 - CAXA (與美國 IronCAD (混用 ACIS 與 parasolid 核心) 進行技術策略合作)

    http://www.caxa.com/
    
    http://www.ironcad.com/
    
開放原始碼 MCAD - FreeCAD - http://www.freecadweb.org/
    
幾何核心教學:

http://www.mpi-inf.mpg.de/departments/d1/teaching/ws09_10/CGGC/Notes/LinearKernel.pdf
.. @+node:amd_yen.20130426235501.5061: *4* 協同產品設計現況
過去有能力打造 SolidWorks 的團隊, 二十年後正在做甚麼? 答案是:

https://lagoa.com/

也就是網際上的協同設計平台, 另一個較小型的平台則是:

https://sunglass.io/

以及提供全球機械設計工程師共享零組件的:

http://grabcad.com/

這些網站具有以下特點:

1. 直接在瀏覽器上提供協同設計所需功能

2. 具備設計 3D 資料的版次管理

3. 未來全球標準設計零件共享的開放機制
.. @+node:amd_yen.20130418193628.2822: *4* 建立各小組遠端主機
提醒: 

1. 網路上的免費虛擬主機通常並不支援 SSL 與 SFTP, 因此只能作為測試之用, 儘量不要用於 production.

2. 免費虛擬主機為了"導引"用戶使用付費服務, 因此可能會禁止使用某些特定的網路協定或降低網站的"可用性", 這些可用性包括只能上傳至多 8 MB 的檔案, 無法透過 socket 傳輸資料 (因而無法使用寄信與 IMAP/SMTP 認證).

3. 免費虛擬主機所建立的網站在特定時間可能會突然斷線, 而且一旦公司策略達成, 將會無預警斷線而無法使用.

為了讓各小組可以擁有一台廣域網路上的網際內容管理與協同產品設計主機, 擬透過免費虛擬主機進行:

選擇提供 10GB 空間的免費虛擬主機商: http://www.1freehosting.com/

特別注意: 採用網路上類似的免費虛擬主機時, 必須了解這些公司提供免費主機的目的, 通常在策略性增加公司網路對外連線與用戶數量, 因為網路連線與用戶使用紀錄可以提升這些公司在許多創投或貸款抵押之談判籌碼, 一旦達到階段性任務目的或用戶未能配合遵守使用規範, 都可能因為突然斷線或免費帳戶被刪除而無法使用, 因此免費虛擬主機僅可提供短期測試用, 比較不建議長期作為運轉主機.

免費虛擬主機與付費虛擬主機的差別:

1. 就一般使用操作流程, 兩者幾乎沒有差別, 都提供一流的瀏覽器介面服務, 且大多提供 PHP 程式伺服, 少數提供 Python、Java 或 Ruby 等伺服程式技術.

2. 部分免費虛擬主機也提供 https:// 與 SFTP 等安全連線, 但是大多數都不提供安全連線, 因此僅能作為測試使用.

3. 免費虛擬主機的斷線比例與帳號正常使用率, 通常比付費帳號低, 但是在短期使用時通常可達 99 %.

問題: 為何這裡將 Web Hosting (網際主機) 稱為 Virtual Hosting (虛擬主機)? 答案就在全球資訊網伺服器的設定, 允許將一台硬體透過 Virtual Host 的設定, 讓多個網域名稱共用同一硬體, 且可以透過同一埠號 (80) 進行伺服.

執行步驟:

1. 利用電子郵箱到 http://www.1freehosting.com/ 登記一個帳號.

2. 收信點擊確認帳號連結後即可完成登錄, 開始建立虛擬主機帳號.

3. 下載 Filezilla (可攜或安裝版都可以), 設定 ftp 檔案傳輸連線設定. (免費帳號僅可使用 ftp, port 21 傳輸資料沒有編碼, 而非較安全的 sftp, port 22, 編碼後傳輸).

4. 先確認網址已經可以連線, 將 default.php 改為 index.php 測試是否可以連線.

5. 先將 CMSimple 程式碼以 ftp 連線送到 public_html 目錄下.

6. 確定 CMSimple 網站可以正常運作, 例如: http://2012c1.hostingsiteforfree.com/ (免費帳號並不提供 SSL 連線, 僅能以 http:// 連線)

7. 設定 MySQL 帳號, 並且再建立一個給 Wordpress 或 Simple Groupware 架站使用的虛擬主機 subdomain.

8. 將 Wordpress 或 Simple Groupware 程式送到主機對應的 public_html 目錄 subdomain 下, 例如 Simple Groupware subdomain 為 sgw, 則程式位於 public_html/sgw, 而 Wordpress 之 subdomain 為 wordpress, 程式目錄為 public_html/wordpress (對應的網址則為 http://sgw.2012c1.hostingsiteforfree.com 與 http://wordpress.2012c1.hostingsiteforfree.com.

9. 根據所設定的 MySQL 帳號, 開始安裝 Simple Groupware, 而 Wordpress 可以使用 Website->Auto Installer 將 Wordpress 3.3.1 安裝到 public_html/wordpress, 並且與上一步驟的 subdomain 設定對應, 使用者可以透過 http://wordpress.2012c1.hostingsiteforfree.com 或  http://2012c1.hostingsiteforfree.com/wordpress 連線到所安裝的 Wordpress, 使用 Auto Installer 功能並不建議使用線上版次升級, 因為會讓 Auto Installer 工具無法控管, 因此 Wordpress 就停留在 3.3.1 版.

9.1. (for 協同產品設計實習) 在實際安裝 Simple Groupware 過程, 發現遠端主機由 src 目錄複製 bin 目錄過程較為緩慢, 建議使用者可以在單機先選擇 English 安裝, 並在近端先完成 bin 目錄的複製後, 再將程式碼以 FTP 送到遠端主機後執行第二階段的資料庫設定安裝.

9.1. (for 網際內容管理) 採用 Auto Installer 的 Wordpress 網站無法正確顯示中文內容, 因此最後建議採用自行安裝 3.5.1 版.

10. 測試是否安裝完成.

11. (for 協同產品設計實習) 將 Simple Groupware 設為 IMAP 驗證, 各小組成員在廣域主機登錄帳號.

12. (for 協同產品設計實習) 設定主機之寄信功能, 完成後開始進行各小組的協同產品設計實習, 並著手建立正齒輪減速機模組程式與 Python Console 程式環境.

11. (for 網際內容管理) 在 Wordpress 主機上為各小組成員建立帳號, 並且由各成員利用 Python 程式將網誌內容送到遠端主機.

12. (for 網際內容管理) 在 Wordpress 主機上建立 Python Console 以及 View Part plugins 程式.
.. @+node:amd_yen.20130413002743.2098: *4* 免付費 MCAD 巡禮
在 MCAD (Mechanical Computer Aided Design) 領域的各種軟體套件, 從最早的線架構、面架構、實體架構、參數設計、變數設計
、歷程設計, 到較近的直接建模, 其實都在反映出基本的設計本質與需求.

設計的本質在追求意念的表達, 表達除了直覺外更要真實, 但是直覺建模之於人與電腦之間現階段的互動模式而言, 仍然生硬, 而且
真實的 3D 互動實體模擬則需要高速的電腦硬體支援.

因此在電腦輔助設計的流程中, 從最早的人必須完全配合電腦運作模式作為起點, 儘管已經有了長足的進步, 距離直覺與真實的建模目標, 
其實還是非常陽春.

在此除了 PTC 的 Creo parametric MCAD 工具外, 我們舉了兩個範例工具, 讓使用者在協同模式下進行實習:

也就是開放原始碼的 FreeCAD 與來自 PTC 的免費直接建模套件 (Creo Elements/Direct Modeling Express 4.0).

FreeCAD 是以 Open CASCADE 作為核心打造的開放 MCAD, 選擇以 Python 程式語言作為主體核心建模工具, 使用者與 FreeCAD 互動的操作過程都在執行
對應的 Python 程式, 因此使用者可以利用程式流程來建構各種產品實體模型.

而 Creo Elements/Direct Modeling Express 4.0 與商用的版本 (Creo Elements/Direct Modeling 18.0)比較:

Express 版本不支援鈑金模組, 組立最多支援 60 個零件, 沒有 direct drafting, 工程圖無法轉為 iges 與 AutoCAD dwg/dwf 格式, 不支援高階材質的彩現, 無法轉為 step、sat、edrawings, 也無法與 Creo parametric 交換模型.

但是 Express 版本可以將模型轉為 stl, 因此可以將模型轉出後, 利用 WebGL 進行後續的網際協同模擬.
.. @+node:amd_yen.20130413002743.2096: *4* FreeCAD 導引
FreeCAD 0.13 版導引

FreeCAD 是利用法國馬特拉公司所釋出的開放源實體模型核心(Solid Modeling Kernel)建構的一套自由開源的 CAD 軟體, 
此套件最大的特色就是以 Python 作為 Scripting 延伸語言, 使用者在套件中所操作的每一個步驟都有對應的 Python 程式指令, 
目前雖然以支援 Python 2.X 為主, 但是已經著手升級為 Python 3.X, 動機之一就是另外一套以荷蘭公司為主體所發展出來的自由開源動畫模擬套件 - Blender, 
目前已經支援最新版的 Python 3.3.0, 由於 FreeCAD 與 Blender 均支援 Python API 程式介面, 
因此若 FreeCAD 與 Blender 同為 Python 3.X based, 兩套將可直接互相呼叫執行, 以完成更加多元的機械與動態模擬(動畫)應用.

參考資料:

http://www.freecadweb.org/

http://freecad-tutorial.blogspot.tw/
.. @+node:amd_yen.20130413002743.2097: *4* FreeCAD 基本操作
參考資料: 請到 youtube 以 freecad 為關鍵字查詢, 大約有 3000 筆資料.

請下載 0.13 視窗免安裝版:

http://sourceforge.net/projects/free-cad/files/FreeCAD%20Windows/FreeCAD%200.13/FreeCAD_0.13.1828_x86_bin.7z/download

解開後即可進入 bin 執行 FreeCAD.exe, 目前 0.13 版仍然採用 Python 2.6 解譯系統, 但是因為自帶 Python 2.6 與 PyQt 程式庫, 因此可以免安裝模式開啟.

預計下一版本將可直接支援 Python 3.X, 若可以自行採用 Visual C/C++ Express 與 CMake 自行編譯, 將可進行更多客製化修改, 或可以建立延伸 workbendch 的方式擴增其他應用.

基本操作:

1. 開啟後, 進入 View->Workbench 可以檢視 0.13 版所提供的應用.

進入 Sketcher 可以執行草圖繪製, 可以利用 constraint-based 製圖

草圖繪製:

隨意繪製四條直線, 利用滑鼠選擇任兩線的端點, 功能表就會出現"紅色"的約束條件設置功能, 可以選擇"coincident constraint", 就會將兩個端點植入"共點"約束.

另外可以再將其他線段的點以相同的"共點"約束完成繪圖.

若以滑鼠選擇線段, 則可以選擇"horizontal distance constraint", "vertical distance constraint" 或 "length of a line constraint" 等約束來置入尺寸約束.

放入尺寸約束後, 若以滑鼠點選尺寸約束位置, 則可以修改尺寸大小.

完成草圖繪製後, 確定草圖已經 fully constrainted, 就可以切換到 part workbench, 以該草圖長出實體.

長出實體後, 目前僅能利用 Python 指令查詢相關的實體物理性質, 以下為相關指令:

建立一個 Cone

App.ActiveDocument.addObject("Part::Cone","Cone")
FreeCAD.getDocument("Unnamed").getObject("Cone").Height = 40.00
FreeCAD.getDocument("Unnamed").getObject("Cone").Radius1 = 0.00
FreeCAD.getDocument("Unnamed").getObject("Cone").Radius2 = 30.00

查詢 Cone 的體積

FreeCAD.getDocument("Unnamed").getObject("Cone").Shape.Volume

若 Unnamed 文件中, 以草圖長出一個實體名稱為 Extrude, 則可以下列指令查詢其體積

FreeCAD.getDocument("Unnamed").getObject("Extrude").Shape.Volume

FreeCAD.getDocument("Unnamed").getObject("Extrude").Shape.Volume

App.ActiveDocument.getObject("Extrude").Shape.Volume

FreeCAD.getDocument("Unnamed").getObject("Extrude").Shape.Volume
.. @+node:amd_yen.20130413002743.2099: *4* Creo Elements/Direct Modeling Express 導引
下載:

http://www.ptc.com/products/creo-elements-direct/modeling-express/

基本教學:

http://www.ptc.com/products/creo-elements-direct/modeling-express/

http://www.youtube.com/watch?v=hCPPFtoq2tU

http://download.ptc.com/products/creo-elements-direct/18-0/english/modeling-express/video/Block1_Part1/Block1_Part1.html

http://download.ptc.com/products/creo-elements-direct/18-0/english/modeling-express/video/Block1_Part2/Block1_Part2.html

http://download.ptc.com/products/creo-elements-direct/18-0/english/modeling-express/video/Block2_Part1/Block2_Part1.html

http://download.ptc.com/products/creo-elements-direct/18-0/english/modeling-express/video/Block2_Part2/Block2_Part2.html

http://download.ptc.com/products/creo-elements-direct/18-0/english/modeling-express/video/Block2_Part3/Block2_Part3.html

http://download.ptc.com/products/creo-elements-direct/18-0/english/modeling-express/video/Block2_Part4/Block2_Part4.html

http://download.ptc.com/products/creo-elements-direct/18-0/english/modeling-express/video/Create_Profile/Create_Profile.html

http://download.ptc.com/products/creo-elements-direct/18-0/english/modeling-express/video/Profile_Pull/Profile_Pull.html

http://download.ptc.com/products/creo-elements-direct/18-0/english/modeling-express/video/Mate_Align/Mate_Align.html

http://download.ptc.com/products/creo-elements-direct/18-0/english/modeling-express/video/Reorganize_Parts_Assy/Reorganize_Parts_Assy.html

http://download.ptc.com/products/creo-elements-direct/18-0/english/modeling-express/video/Repurpose_Printer/Repurpose_Printer.html

http://download.ptc.com/products/creo-elements-direct/18-0/english/modeling-express/video/Repurpose_Printer_Move/Repurpose_Printer_Move.html

http://download.ptc.com/products/creo-elements-direct/18-0/english/modeling-express/video/Create_Drawing/Create_Drawing.html

http://download.ptc.com/products/creo-elements-direct/18-0/english/modeling-express/video/Create_Dimension/Create_Dimension.html
.. @+node:amd_yen.20130421114440.2135: *3* CD 第十一週
.. @+node:amd_yen.20130421114440.2136: *4* Creo 齒輪參數繪圖
漸開線正齒輪齒形原理

PTC Creo 正齒輪繪圖步驟

正齒輪零件參數控制

on Creo

on Pro/Web.Link

從參數化零件轉 STL -> CMSimple 網際 View Part (Wordpress 網誌 View Part) -> SGW 協同設計 View Part (需要 View Part 模組)
.. @+node:amd_yen.20130421114440.2138: *5* 齒輪術語簡介
齒輪是一種傳遞動力的裝置, 可透過不同齒數搭配傳動而達到不同的轉動速度比, 以動力傳遞方向分類, 可分為平行軸傳動, 相交軸傳動與交錯軸傳動等三種.

    平行軸傳動: 直齒正齒輪(straight spur gears)、直齒齒條(排齒)(straight racks)與小齒輪(pinion)、斜齒齒條(helical racks)與小齒輪(pinion)、斜齒正齒輪(helical spur gears)、人字齒輪(herringbone gears)與針齒輪(pin gears)等.

    相交軸傳動: 直齒傘齒輪(straight bevel gears)、斜齒傘齒輪(helical bevel gears)、螺旋傘齒輪(spiral bevel gears)與冠狀齒輪(crown gears)等.

    交錯軸傳動: 交叉螺旋齒輪(screw gears)、戟齒輪(內擺線齒輪或雙曲線斜齒輪)(hypoid gears)、蝸桿蝸輪(worm gears)與歪斜齒輪(skew tooth gears)等.

其他相關齒輪術語:

Spur Gear: A type of gear that has straight, flat-topped teeth set parallel to the shaft. Spur gears are the most common type of gears used in industry.

Bevel Gear: A type of gear with cone-shaped teeth cut at an angle. Bevel gears are often used in angular gear trains.

Helical Gear: A type of gear with slanted teeth. Helical gears are quieter than spur gears, but they are more expensive and produce side loads.

Straight Bevel Gear: The basic bevel gear, which has tapered teeth that are widest at their outer part. Straight bevel gears are cost-effective when transmitting power between shafts at right angles.

Spiral Bevel Gear: A type of bevel gear with conical and curved teeth, designed for smooth operation. The teeth of spiral bevel gears have a spiral angle.

Double Helical Gear: A type of helical gear with two sets of teeth cut at opposing angles, separated by a groove that runs around the center of the gear. Double helical gears are used to provide smoother operation and avoid side loads.

Herringbone Gear: A type of gear that has angled teeth in the shape of a letter "V." Herringbone gears resist side loading but are expensive to produce.

Internal Gear: A circular gear with teeth that face inward, used to mesh with planet gears in a planetary gear train. Also known as a ring gear.

Involute Curve: The path determined by tracing a point on a line that is unwound from a circle.

Miter Gear: A type of bevel gear used in pairs with intersecting shafts at 90° angles. Both the driving gear and driven gear in a miter gear pair have the same diameter, same number of teeth, and a mechanical advantage of 1.

Pinion: A circular gear used in a rack and pinion system to produce linear motion. As the pinion turns, the flat rack slides in a linear direction.

Planet Gear: An outer gear in a planetary gear train that rotates around the sun gear. A planet gear can be mounted on a moveable planet arm that also rotates around the sun gear.

Right-Hand Helical Gear: A helical gear with teeth that lean to the right when the gear is placed on a flat, horizontal surface.

Ring Gear: A circular gear with teeth that face inward, used to mesh with planet gears in a planetary gear train. Also known as an internal gear.

Skew Tooth Gear(歪斜齒輪): A type of bevel gear with teeth that are straight and cut at an angle to the axis of the gear shaft. Skew tooth gears can carry more load than straight bevel gears and are generally made in large sizes.

Sun Gear: The central gear in a planetary gear train around which the planet gears rotate.

Worm Gear: A gear with teeth that mesh with the screw-like threads of a worm to transmit motion.

Zerol Bevel Gear: A type of bevel gear with curved teeth and a 0° spiral angle. Zerol bevel gears provide smooth and quiet operation, but they produce side loads.

參考資料: http://www.khkgears.co.jp/tw/gear_technology/

齒輪手冊: http://www.khkgears.co.jp/tw/gear_technology/pdf/gear_guide_060817.pdf

齒輪技術資料: http://www.khkgears.co.jp/tw/gear_technology/pdf/3010gearguide_tw.pdf

標準齒輪 CAD 檔案下載: http://www.khkgears.co.jp/tw/khk_products/stock_gears_cad_download.html

訂製齒輪自動繪圖系統: http://www.khkgears.co.jp/tw/khk_products/stock_gears_cad_download.html
.. @+node:amd_yen.20130421114440.2847: *5* 網際 2D 正齒輪繪圖
採用 Javascript 與 Cango 程式庫, 可以改寫為 Brython.

http://arc.id.au/GearDrawing.html

Gear utility: http://www.arc.id.au/gearUtils-03.js

jsBezier: http://www.arc.id.au/jsBezier-0.5.js

參考資料:

Approximation of involute curves for CAD-system processing

http://link.springer.com/article/10.1007%2Fs00366-007-0060-3
.. @+node:mde_leo.20130510215619.7577: *4* SGW 程式運作流程
index.html 或 index.htm 啟動 Javascript 將執行導向 /bin/index.php

導入 simple_store 目錄下的 config.php, 假如還未安裝, 則執行 core/setup.php

導入 core/functions.php 與 lib/smarty/Smarty.class.php

執行 sys::init(), 啟動程式畫面, 等待使用者輸入.

sys::init() 表示要執行 functions.pp 中 sys 類別中的 init() 方法.

init() 方法如下:

.. code-block:: php

    static function init() {
        self::$time_start = sys_get_microtime();
    
        // clean request vars
        if (ini_get("magic_quotes_gpc")!==false and get_magic_quotes_gpc()) modify::stripslashes($_REQUEST);
        foreach ($_REQUEST as $key=>$val) {
          if (is_array($val) and count($val)>0) {
            $_REQUEST[$key] = array();
            foreach ($val as $val2) {
              if (!is_array($val2)) $_REQUEST[$key][$val2] = $val2;
        } } }
    
        // refresh smarty cache?
        if (DEBUG) debug_check_tpl();
        
        // set up smarty
        self::$smarty = new Smarty;
        self::$smarty->register_prefilter(array("modify","urladdon_quote"));
        if (isset($_REQUEST["print"])) self::$smarty->register_outputfilter(array("modify","striplinksforms"));
        if (isset($_REQUEST["print"])) self::$smarty->assign("print",$_REQUEST["print"]);
        self::$smarty->compile_dir = SIMPLE_CACHE."/smarty";
        self::$smarty->template_dir = "templates";
        self::$smarty->config_dir = "templates";
        self::$smarty->compile_check = false;
    
        // set up database
        if (!sql_connect(SETUP_DB_HOST, SETUP_DB_USER, sys_decrypt(SETUP_DB_PW,sha1(SETUP_ADMIN_USER)), SETUP_DB_NAME)) {
          $err = sprintf("Cannot connect to database %s on %s.\n",SETUP_DB_NAME,SETUP_DB_HOST).sql_error();
          trigger_error($err,E_USER_ERROR);
          sys_die($err);
        }
    
        // verify credentials
        login_handle_login();
      }
.. @+node:amd_yen.20130421114440.2137: *4* SGW 模組程式編寫
利用 sgsML 編寫一個網際 Python 程式環境:

.. code-block:: none

    <table modulename="Custom" default_view="display" orderby="id" order="desc" limit="20" \
    enable_new="true" enable_edit="true" enable_delete="true" enable_empty="true">
      <view name="display" template="free" displayname="Display" image_width="250" \
       image_height="145" cols="3" row_height="215px">
      </view>
      <view name="details" template_mode="small" showinsingleview="true" \
      displayname="Details" show_preview="true">
      </view>
      <field name="title" displayname="Title" simple_type="text" required="true">
      </field>
      <field name="program" displayname="Program" simple_type="bconsole" required="true">
      </field>
      <field name="description" displayname="Description" simple_type="textarea">
      </field>
      <field name="attachment" displayname="Attachment" simple_type="files" \
      simple_file_size="10M" simple_size="10">
      </field>
      <field name="category" displayname="Category" simple_type="select" simple_size="1" height="16px">
        <data title="Default" sort="asc" values="Introduction|Variables|Statement|Expression|Math \
        |Strings|Conversion|Lists|Tuple|Dictionary|Loops|Conditions|Functions|Classes|File IO|PIL|C API \
        |CherryPy|Pybean|Deap|tkinter|PyQt|Sympy" />
        <data title="Lookup" function="dbselect|simple_categories|categoryname,categoryname| \
        cattype='notes'|categoryname asc|10"/>
      </field>
      <field name="syncid" simple_type="id" hidden="true">
      </field>
    </table>

配合建立一個 bconsole type: bconsole.php 位於舊版 bin/core/types 目錄下, 執行時需要  bin/jascript/brython 目錄.

.. code-block:: python

    <?php
    
    class type_bconsole extends type_default {
    
    static function build_history($old, $new) {
      return asset::build_diff(modify::htmlmessage($old), modify::htmlmessage($new));
    }
    
    static function form_render_value($name, $value, $smarty) {
      static $init = false;
      if ($init == false) $init = <<<EOT
    <div class="entry-content">
    <p><script src="jscript/brython/brython.js"></script>
    <script>
    window.onload = function(){
        brython(1);
    }
    </script>
    EOT;
    
        $output = $init.<<<EOT
    <script type="text/python">
    import sys
    import time
    import dis
    
    if sys.has_local_storage:
        import local_storage
    else:
        storage = False
    
    def reset_src():
        if local_storage.storage:
            doc['src'].value = local_storage.storage["py_src"]
    
    def to_str(xx):
        return str(xx)
    
    doc['version'].text = '.'.join(map(to_str,sys.version_info))
    
    class cons_out:
    
        def __init__(self,target):
            self.target = doc[target]
        def write(self,data):
            self.target.value += str(data)
    
    sys.stdout = cons_out("console2")
    sys.stderr = cons_out("console2")
    
    output = ''
    
    def show_console2():
        doc["console2"].value = output
        doc["console2"].cols = 60
    
    def clear_text():
        log(" event clear")
        doc['console2'].value=''
        #doc['src'].value=''
    
    def run():
        global output
        doc["console2"].value=''
        doc["console2"].cols = 60
        src = doc["src"].value
        if local_storage.storage:
            local_storage.storage["py_src"]=src
        t0 = time.time()
        exec(src)
        output = doc["console2"].value
        print('<done in %s ms>' %(time.time()-t0))
    
    def show_js():
        src = doc["src"].value
        doc["console2"].cols = 90
        doc["console2"].value = dis.dis(src)
    </script>
    <table width=80%>
    <tr><td style="text-align:center"><b>Python</b>
    </td>
    <td>&nbsp;</td>
    <th><input type="button" value="Console" onClick="show_console2()"></th>
    <th><input type="button" value="Javascript" onClick="show_js()"></th>
    </tr>
    <tr><td colspan><textarea id="src" name={$name} cols="60" rows="20">{$value} \
    </textarea></td><td><input type="button" value="Run" onClick="run()"></td>
    <td><input type="button" value="Clear" onClick="clear_text()"></td>
    <td colspan=2><textarea id="console2" cols="60" rows="20"></textarea></td>
    </tr>
    <tr><td colspan=2>
    <p>Brython version <span id="version"></td>
    </tr>
    </table>
    </p>					</div><!-- .entry-content -->
    EOT;
      $init = "";
      return $output;
    }
    
    static function render_value($value) {
      return "<div style='text-align:left;'>".modify::nl2br($value)."</div>";
    }
    
    static function export_as_text() {
      return true;
    }
    
    }

利用 Python 模組直接在網頁繪圖:

.. code-block:: python

    import random
    import time
    
    canvas = doc["plotarea"]
    ctx = canvas.getContext("2d")
    
    ## After doing this I saw that this could be achieved using
    ## translate(0,canvas.height); scale(1,-1); 
    ## https://developer.mozilla.org/en-US/docs/HTML/Canvas/Tutorial/Transformations
    def change_ref_system(x, y):
        return (20 + x * 8, 420 - y * 20)
    
    def draw_line(x1, y1, x2, y2, linethick = 3, color = "black"):
        ctx.beginPath()
        ctx.lineWidth = linethick
        ctx.moveTo(x1, y1)
        ctx.lineTo(x2, y2)
        ctx.strokeStyle = color
        ctx.stroke()
    
    def axis(color = "black", linethick = 3):
        #Draw of x axis
        draw_line(20, 420, 820, 420, linethick = linethick, color = color)
        #Draw of y axis
        draw_line(20, 20, 20, 420, linethick = linethick, color = color)
    
    # 需要 axis_color id 的 document 內容配合
    def axis_color():
        axis(color = doc["axis_color"].value)
    
    # 需要 titletext id 的 document 內容配合
    def figure_title():
        ctx.clearRect(410, 0, 400, 30)
        ctx.fillStyle = "gray"
        ctx.font = "bold 16px Arial"
        ctx.fillText(doc["titletext"].value, 410, 20)
        
    dataset = []
    def graph():
        data = random.random() * 20
        doc["dataarea"] <= '%s, ' % str(data)[0:5]
        dataset.append(data)
        if len(dataset) == 1:
            x, y = change_ref_system(len(dataset), data)
            draw_line(x, y, x, y, linethick=3, color="blue")
        else:
            x1, y1 = change_ref_system(len(dataset)-1, dataset[-2])
            x2, y2 = change_ref_system(len(dataset), data)
            draw_line(x1, y1, x2, y2, linethick=3, color="blue")
        if len(dataset) >= 100:
            print(len(dataset))
            time.clear_interval(work)
    
    axis(color = "black", linethick = 5)
    work = time.set_interval(graph, 100)
    draw_line(0, 0, 20, 420, linethick = 5, color = "red")
    
bconsole.xml 內容則需要跟著配合修改:

.. code-block:: php

    <?php
    
    class type_bconsole extends type_default {
    
    static function build_history($old, $new) {
      return asset::build_diff(modify::htmlmessage($old), modify::htmlmessage($new));
    }
    
    static function form_render_value($name, $value, $smarty) {
      static $init = false;
      if ($init == false) $init = <<<EOT
    <div class="entry-content">
    <p><script src="jscript/brython/brython.js"></script>
    <script>
    window.onload = function(){
        brython(1);
    }
    </script>
    EOT;
    
        $output = $init.<<<EOT
    <script type="text/python">
    import sys
    import time
    import dis
    
    if sys.has_local_storage:
        import local_storage
    else:
        storage = False
    
    def reset_src():
        if local_storage.storage:
            doc['src'].value = local_storage.storage["py_src"]
    
    def to_str(xx):
        return str(xx)
    
    doc['version'].text = '.'.join(map(to_str,sys.version_info))
    
    class cons_out:
    
        def __init__(self,target):
            self.target = doc[target]
        def write(self,data):
            self.target.value += str(data)
    
    sys.stdout = cons_out("console2")
    sys.stderr = cons_out("console2")
    
    output = ''
    
    def show_console2():
        doc["console2"].value = output
        doc["console2"].cols = 60
    
    def clear_text():
        log(" event clear")
        doc['console2'].value=''
        #doc['src'].value=''
    
    def run():
        global output
        doc["console2"].value=''
        doc["console2"].cols = 60
        src = doc["src"].value
        if local_storage.storage:
            local_storage.storage["py_src"]=src
        t0 = time.time()
        exec(src)
        output = doc["console2"].value
        print('<done in %s ms>' %(time.time()-t0))
    
    def show_js():
        src = doc["src"].value
        doc["console2"].cols = 90
        doc["console2"].value = dis.dis(src)
    </script>
    <table width=80%>
    <tr><td style="text-align:center"><b>Python</b>
    </td>
    <td>&nbsp;</td>
    <th><input type="button" value="Console" onClick="show_console2()"></th>
    <th><input type="button" value="Javascript" onClick="show_js()"></th>
    </tr>
    <tr><td colspan><textarea id="src" name={$name} cols="60" rows="20">{$value}</textarea> \
    </td><td><input type="button" value="Run" onClick="run()"></td>
    <td><input type="button" value="Clear" onClick="clear_text()"></td>
    <td colspan=2><textarea id="console2" cols="60" rows="20"></textarea></td>
    </tr>
    <tr><td colspan=2>
    <p>Brython version <span id="version"></td>
    </tr>
    <tr><td colspan="4">
    <textarea id="dataarea" cols=30 rows=5></textarea>
    </td>
    </tr>
    <tr><td colspan="4">
    <canvas id="plotarea" width="640" height="480"></canvas>
    </td>
    </tr>
    </table>
    </p>					</div><!-- .entry-content -->
    EOT;
      $init = "";
      return $output;
    }
    
    static function render_value($name, $value,  $smarty) {
        $output = <<< EOT
        <div class="entry-content">
        <p><script src="jscript/brython/brython.js"></script>
        <script>
        window.onload = function(){
            brython(1);
        }
        </script>
        <script type="text/python">
        import sys
        import time
        import dis
    
        if sys.has_local_storage:
            import local_storage
        else:
            storage = False
    
        def reset_src():
            if local_storage.storage:
                doc['src'].value = local_storage.storage["py_src"]
    
        def to_str(xx):
            return str(xx)
    
        doc['version'].text = '.'.join(map(to_str,sys.version_info))
    
        class cons_out:
    
            def __init__(self,target):
                self.target = doc[target]
            def write(self,data):
                self.target.value += str(data)
    
        sys.stdout = cons_out("console2")
        sys.stderr = cons_out("console2")
    
        output = ''
    
        def show_console2():
            doc["console2"].value = output
            doc["console2"].cols = 60
    
        def clear_text():
            log(" event clear")
            doc['console2'].value=''
            #doc['src'].value=''
    
        def run():
            global output
            doc["console2"].value=''
            doc["console2"].cols = 60
            src = doc["src"].value
            if local_storage.storage:
                local_storage.storage["py_src"]=src
            t0 = time.time()
            exec(src)
            output = doc["console2"].value
            print('<done in %s ms>' %(time.time()-t0))
    
        def show_js():
            src = doc["src"].value
            doc["console2"].cols = 90
            doc["console2"].value = dis.dis(src)
        </script>
        <table width=80% border="1">
        <tr><td style="text-align:center"><b>Python</b>
        </td>
        <td>&nbsp;</td>
        <th><input type="button" value="Console" onClick="show_console2()"></th>
        <th><input type="button" value="Javascript" onClick="show_js()"></th>
        </tr>
        <tr><td colspan><textarea id="src" name={$name} cols="60" rows="20">{$value}</textarea> \
        </td><td><input type="button" value="Run" onClick="run()"></td>
        <td><input type="button" value="Clear" onClick="clear_text()"></td>
        <td colspan=2><textarea id="console2" cols="60" rows="20"></textarea></td>
        </tr>
        <tr><td colspan="2">
        <p>Brython version <span id="version"></td>
        </tr>
        <tr><td colspan="4">
        <textarea id="dataarea" cols=30 rows=5></textarea>
        </td>
        </tr>
        <tr><td colspan="4">
        <canvas id="plotarea" width="640" height="480"></canvas>
        </td>
        </tr>
        </table>
        </p>					</div><!-- .entry-content -->
    EOT;
    
        return $output;
        //return "<div style='text-align:left;'>".modify::nl2br($value)."</div>";
    }
    
    static function export_as_text() {
      return true;
    }
    
    }

透過 Cango 2D 繪圖指令, 在 Simple Groupware Brython 模組上的滑鼠互動繪圖:

.. code-block:: python

    import Cango2v03
    # 必須要將繪圖指到內建的 plotarea 區域
    g = Cango2v03.cango("plotarea")
    g.setViewport()
    g.fillViewport("lightyellow")
    g.setWorldCoords(0, 200, 0, 70)
    g.setPenColor("blue")
    x1 = 40
    y1 = 10
    cx1 = 90
    cy1 = 60
    x2 = 120
    y2 = 50
    cx2 = 130
    cy2 = 10
    cx3 = 150
    cy3 = 60
    x3 = 180
    y3 = 30
    grabOfsX = 0
    grabOfsY = 0
    def dragC1(mousePos):
        global cx1,cy1
        wPos = g.toWorldCoords(mousePos.x , mousePos.y)
        cx1 = wPos.x
        cy1 = wPos.y
        drawCurve()
    def dragC2(mousePos):
        global cx2,cy2
        wPos = g.toWorldCoords(mousePos.x , mousePos.y)
        cx2 = wPos.x
        cy2 = wPos.y
        drawCurve()
    def dragC3(mousePos):
        global cx3,cy3
        wPos = g.toWorldCoords(mousePos.x , mousePos.y)
        cx3 = wPos.x
        cy3 = wPos.y
        drawCurve()
    def drawCurve():
        g.clearCanvas()
        g.setPenColor('blue')
        data = ['M', x1, y1, 'Q', cx1, cy1, x2, y2]
        g.drawPath(data)
        g.setPenColor('green')
        data = ['M', x2, y2, 'C', cx2, cy2, cx3, cy3, x3, y3]
        g.drawPath(data)
        g.setPenColor("rgba(0, 0, 0, 0.2)")
        data = ['M', x1, y1, 'L', cx1, cy1, x2, y2]
        g.drawPath(data)
        data = ['M', x2, y2, 'L', cx2, cy2]
        g.drawPath(data)
        data = ['M', x3, y3, 'L', cx3, cy3]
        g.drawPath(data)
        g.render(c1, cx1, cy1)
        g.render(c2, cx2, cy2)
        g.render(c3, cx3, cy3)
    #dragC1 = null
    #dragC2 = null
    #dragC3 = null
    dragObj1 = Cango2v03.drag2d(g, null, dragC1, null)
    c1 = g.compileShape(Cango2v03.shapedefs.circle, 'red', 'red', 'iso', dragObj1)
    c1.scale(4)
    dragObj2 = Cango2v03.drag2d(g, null, dragC2, null)
    c2 = g.compileShape(Cango2v03.shapedefs.circle, 'red', 'red', 'iso', dragObj2)
    c2.scale(4)
    dragObj3 = Cango2v03.drag2d(g, null, dragC3, null)
    c3 = g.compileShape(Cango2v03.shapedefs.circle, 'red', 'red', 'iso', dragObj3)
    c3.scale(4)
    drawCurve()
    
Brython 在執行區與 html 選單的互動, 以下程式表示要將三個選擇項目, 放入 id 名稱為 outputdiv 的 div 標註區中.

.. code-block:: python

    import html
    項目 = ['選項一', '選項二', '選項三']
    選擇表單 = html.SELECT(name="selection")
    for 索引, 選擇 in enumerate(項目):
        選擇表單 <= html.OPTION(選擇, value = 索引)
    doc['outputdiv'] <= 選擇表單
.. @+node:mde_leo.20130510215619.7575: *3* CD 第十二週
Simple Groupware 模組程式主要用於多人協同環境, 以機械設計流程而言, 可以在網際群組環境中編寫協同設計程式, 這些網際程式可以從網際頁面中的表單取得設計輸入, 並且從網際資料庫欄位中建立所需的設計選單, 當使用者完成設計欄位輸入後, Simple Groupware 模組程式中的設計運算, 可以設法在遠端伺服器中完成, 也可以在使用者端完成.

在遠端伺服器中完成機械協同設計運算的考量在於可隱匿實際的運算細節, 具有較高的保全性, 但是所有運算集中在伺服器端, 因此 Server 將承受較高的負載.

若選擇在使用者端完成設計運算, 則必須在網頁中呈現運算細節, 若非採用編譯式設計運算(例如: Java applet) 技術, 而是使用解譯式的 JavaScript(含 Brython) 技術, 則較難隱匿實際的運算細節, 但是大多數設計運算可分散在使用者端, 可減輕 Server 端的運算負載.

Server 端設計運算模組:

採 sgsML 語法編寫, 可以加上 Brython 或 Javascript 程式, 利用 WebGL 程式設計流程中的 2D/3D 零組件模擬.

客戶端設計運算模組:

由 sgsML 架構帶出客製化的 simple_type, 並在 form_render_value 及 render_value 方法中置入 Brython 程式環境.
.. @+node:mde_leo.20130510215619.7576: *4* sgsML 程式範例
  欄位變數從選項中選擇(選擇項目直接在下方):
  
.. code-block:: none
  
    <field name="category" displayname="Category" simple_type="select" simple_size="1" required="true">
    <data reverse="true" values="holiday_##_Public holiday|vacation_##_Vacation|overtime_##_Overtime|illness_##_Illness|school_##_School|special_##_Special leave|loa_##_Leave of absence|absence_##_Absence|other_##_Other"/>
    </field>
      
欄位變數從資料庫中透過特定函式取值後, 從選項中選擇(內定值為 anonymous):

.. code-block:: none

    <field name="username" displayname="Username" simple_type="select" simple_size="1" simple_default="anonymous" simple_default_function="getusername" required="true">
    <data function="dbselect|simple_sys_users|username,concat(lastname;' ';firstname)||lastname asc|10"/>
    <link value="index.php?find=asset|simple_sys_users||username=@username@&amp;view=details"/>
    </field>

欄位變數從資料庫中透過特定函式取值後, 從選項中選擇, 無內定值, 且設定連結文字:

.. code-block:: none

    <field name="username" displayname="Username" simple_type="select" simple_size="1" required="true" allow_custom="true">
    <data function="dbselect|simple_sys_users|username,concat(lastname;' ';firstname)||lastname asc|10"/>
    <link value="index.php?find=asset|simple_sys_users||username=@username@&amp;view=details"/>
    <linktext views="display|offer|inactive" value="#index.php?folder=@folder@&amp;view=details&amp;iframe=1&amp;item[]=@id@"/>
    </field>

欄位選項由其他欄位資料庫中取出:

.. code-block:: none

    <field name="resourcecol" displayname="Resource" simple_type="select" simple_size="1">
    <data function="dbselect|simple_resources|resourcename,resourcename||resourcename asc|10"/>
    <link value="index.php?find=asset|simple_resources||resourcename=@resourcecol@&amp;view=display"/>
    </field>
    
欄位變數為浮點數:

.. code-block:: none

    <field name="amount" displayname="Amount (USD)" simple_type="float" required="true" sum="true">
    </field>
    
欄位變數由資料庫中取出後排序作為選單(選擇項目在右方):

.. code-block:: none

    <field name="category" displayname="Category" simple_type="select" simple_size="1" required="true">
    <data sort="asc" values="Transportation costs|Costs of accommodation|Subsistence costs|Other"/>
    <data function="dbselect|simple_categories|categoryname,categoryname|cattype='expenses'|categoryname asc|10"/>
    </field>
    
欄位變數為浮點數, 且有內建值:

.. code-block:: none

    <field name="hours_per_week" displayname="Hours per week" simple_type="float" simple_default="0">
    </field>
    
欄位變數指定為圖檔上傳(以 fileupload 函式查驗輸入檔案是否為 jpg, jpeg, gif 與 png 格式):

.. code-block:: none

    <field name="outlineimage" displayname="Outline image" simple_type="files" simple_file_size="5M" simple_size="10">
    <notin views="display|display2|calendar"/>
    <validate function="fileupload|jpg,jpeg,gif,png"/>
    </field>
    
欄位變數為浮點, 且會自動加總(sum):

.. code-block:: none

    <field name="ordersize" displayname="Order size" simple_type="text" simple_tab="parameters" sum="true">
    <validate function="float" />
    </field>
    
欄位變數輸入必須符合特定格式要求(一定要填, 必須是小寫的數字或字母組成的字串, 最少三個字元, 最多 128 字元):

.. code-block:: none

    <field name="projectname" displayname="Name" simple_type="text" required="true" is_unique="true">
    <validate function="regexp|/^[a-z0-9-_@\.]{3,128}$/|Name must be not null, lowercase, min 3 characters, max 128 containing [a-z0-9_-@.]." />
    <readonlyin views="edit"/>
    <linktext views="display|display2|calendar" value="#index.php?view=details&amp;iframe=1&amp;item[]=@id@"/>
    </field>
.. @+node:mde_leo.20130510215619.7578: *4* sgsML 兩數相加範例
以下的 sgsML 程式名稱為 myadd, 程式檔案位於 V:\extensions\sgw\bin\modules\schema, 名稱為 myadd.xml, 必須在 modules.txt 中登錄 myadd 模組程式.

myadd.xml 程式中使用 test.php filter 類別, test.php 檔案位於 V:\extensions\sgw\bin\core\classes, 名稱為 test.php

myadd.xml 內容

.. code-block:: none

    <table modulename="Myadd" default_view="display" orderby="var1" order="asc" limit="20" enable_new="true" enable_edit="true" enable_delete="true" enable_asset_rights="owner_read">
    <view name="display" displayname="Display" />
    <view name="details" displayname="Details" showinsingleview="true" tfield_1="var1" tfield_2="var2" />
    <!--
    <field name="id" simple_type="id" displayname="Id">
    <notin views="display" />
    </field>
    -->
    <field name="var1" id="var1" displayname="var1" simple_type="int" required="true" />
    <field name="var2" id="var2" displayname="var2" simple_type="int" required="true" />
    <field name="var3" displayname="var3" simple_type="int" notinall="true">
    <filter views="all" function="test::myadd"/>
    <onlyin views="display|details"/>
    </field>
    <field name="description" displayname="程式說明" simple_type="textarea" simple_size="4">
    <notin views="display" />
    </field>
    </table>
    
test.php 欄位資料處理類別檔案內容:

.. code-block:: php

    <?php
    
    class test {
    
        static function myadd($val,$args,$data) {
        // how to get other field value??
        // $_SESSION["username"] 為目前的用戶名稱
        // $data["var1"]["data"][0] 為 var1 欄位值
        // $data["var2"]["data"][0] 為 var2 欄位值
            return $data["var1"]["data"][0]+$data["var2"]["data"][0];
        }
    }
    ?>
.. @-all
.. @-leo
