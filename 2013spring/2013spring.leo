<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="amd_yen.20130306001037.1797"><vh>@settings</vh>
<v t="amd_yen.20130306001037.1798"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="amd_yen.20130306001037.1799"><vh>@string initial_split_orientation = vertical</vh></v>
</v>
<v t="amd_yen.20130307204656.1443"><vh>課程規劃與進行</vh>
<v t="amd_yen.20130307204656.9867"><vh>@url Leo 手冊</vh></v>
</v>
<v t="amd_yen.20130308103121.2379"><vh>整體架構規劃</vh></v>
<v t="amd_yen.20130308210411.2383" a="E"><vh>自編教材 (點選下列節點, 按下 Ctrl+b 可以建立教材)</vh>
<v t="amd_yen.20130314194325.1514"><vh>@button generate-current</vh>
<v t="amd_yen.20130308210411.2404"><vh>&lt;&lt; html manual &gt;&gt;</vh></v>
<v t="amd_yen.20130308210411.2405"><vh>&lt;&lt; pdf manual &gt;&gt;</vh></v>
</v>
<v t="amd_yen.20130308210411.2403"><vh>@button generate-full-userguide</vh>
<v t="amd_yen.20130308210411.2404"></v>
<v t="amd_yen.20130308210411.2405"></v>
</v>
<v t="amd_yen.20130308210411.2397"><vh>@edit document\conf.py</vh></v>
<v t="amd_yen.20130308210411.2398"><vh>@edit document\kmol_toc.html.txt</vh></v>
<v t="amd_yen.20130318140025.2832"><vh>位於 exts 目錄的中文分詞程式</vh>
<v t="amd_yen.20130318140025.2829"><vh>@edit exts\zh.py</vh></v>
<v t="amd_yen.20130318140025.2830"><vh>@edit exts\chinese_search.py</vh></v>
<v t="amd_yen.20130318140025.2831"><vh>@edit exts\sphinx.search.py</vh></v>
</v>
</v>
<v t="amd_yen.20130312013510.1824"><vh>@button self_and_subtree</vh></v>
<v t="amd_yen.20130506144326.2650"><vh>@button start eric5</vh></v>
<v t="amd_yen.20130308210411.2406" a="E"><vh>KMOL Guide</vh>
<v t="amd_yen.20130308221230.3827" a="E"><vh>前言</vh>
<v t="amd_yen.20130312013510.1498"><vh>以下為電子書內容</vh></v>
<v t="amd_yen.20130308221230.3828"
expanded="amd_yen.20130308221230.3829,"><vh>@file frontMatter.txt</vh></v>
</v>
<v t="amd.20130514093510.2692" a="E"><vh>程式語言(一)</vh>
<v t="amd_yen.20130312013510.1498"></v>
<v t="amd.20130514093510.2694" a="E"
expanded="amd.20130514093510.2695,amd.20130514093510.2696,amd.20130515005753.3890,"><vh>@file c1.txt</vh></v>
</v>
<v t="amd.20130514093510.2702" a="E"><vh>電腦輔助設計實習</vh>
<v t="amd_yen.20130312013510.1498"></v>
<v t="amd.20130514093510.2704" a="E"
expanded="amd.20130514093510.2705,"><vh>@file cadp.txt</vh></v>
</v>
<v t="amd.20130514093510.2683" a="E"><vh>網際網路應用</vh>
<v t="amd_yen.20130312013510.1498"></v>
<v t="amd.20130514093510.2684"
expanded="amd.20130514093510.2685,"><vh>@file ia.txt</vh></v>
</v>
<v t="amd_yen.20130308210411.2384" a="E"><vh>程式語言(二)</vh>
<v t="amd_yen.20130429141318.2219"><vh>為何要學習程式?</vh></v>
<v t="amd_yen.20130318140025.2833"><vh>有關程式語言</vh></v>
<v t="amd_yen.20130308221230.2437" a="E"><vh>C2 第一週程式</vh>
<v t="amd_yen.20130408141041.1765"><vh>有關 pybean 版次差異</vh></v>
<v t="amd_yen.20130308221230.2438" a="E"><vh>@shadow c2/grouping.py</vh></v>
<v t="amd_yen.20130308221230.2441" a="E"><vh>@shadow c2/generate_stud.py</vh></v>
</v>
<v t="amd_yen.20130308221230.2457" a="E"><vh>C2 第二週程式</vh>
<v t="amd_yen.20130308221230.2458"><vh>@shadow c2/docutils_ex1.py</vh></v>
<v t="amd_yen.20130308221230.2462"><vh>課程規劃</vh></v>
<v t="amd_yen.20130308221230.2463"><vh>課程進行</vh>
<v t="amd_yen.20130308221230.2464"><vh>portableKMOL 配置</vh></v>
</v>
<v t="amd_yen.20130308221230.2465" a="E"><vh>@shadow c2/docutils_ex2.py</vh></v>
</v>
<v t="amd_yen.20130317160119.1726" a="E"><vh>C2 第四週程式</vh>
<v t="amd_yen.20130317160119.1727"><vh>@shadow c2/pyqt_geardesign.py</vh></v>
</v>
<v t="amd_yen.20130426235501.5059" a="E"><vh>C2 第九週程式</vh>
<v t="amd_yen.20130501090735.2391"><vh>@shadow c2/get_score.py</vh></v>
<v t="amd_yen.20130501090735.3343"><vh>@shadow c2/list_score.py</vh></v>
<v t="amd_yen.20130429141318.2172"><vh>@shadow c2/pyqt_1.py</vh></v>
<v t="amd_yen.20130429141318.2173"><vh>@shadow c2/pyqt_2.py</vh></v>
<v t="amd_yen.20130429141318.2174"><vh>@shadow c2/pyqt_3.py</vh></v>
<v t="amd_yen.20130429141318.2175"><vh>@shadow c2/pyqt_4.py</vh></v>
<v t="amd_yen.20130429141318.2176"><vh>@shadow c2/pyqt_notepad1.py</vh></v>
<v t="amd_yen.20130426235501.5060"><vh>@shadow c2/pyqt_notepad.py</vh></v>
<v t="amd_yen.20130429141318.2177" a="E"><vh>@auto c2/pyqt_tetris.py</vh></v>
<v t="amd_yen.20130429141318.2220"><vh>@auto c2/pyqt_browser1.py</vh></v>
<v t="amd_yen.20130429141318.2221"><vh>@auto c2/pyqt_browser2.py</vh></v>
<v t="amd_yen.20130429141318.2218"><vh>@shadow c2/pyqt_browser3.py</vh></v>
<v t="amd_yen.20130429141318.2217"><vh>@shadow c2/pyqt_browser.py</vh></v>
<v t="amd_yen.20130429214002.3978"><vh>@path c2/pyqt_browser</vh>
<v t="amd_yen.20130429214002.4048" a="E"
expanded="amd_yen.20130429214002.4056,"><vh>@file webbrowser.py</vh></v>
<v t="amd_yen.20130429214002.3979"><vh>@file bookmark.py</vh></v>
<v t="amd_yen.20130429214002.3987"><vh>@file flickcharm.py</vh></v>
<v t="amd_yen.20130429214002.4029" a="E"><vh>@file mainwindow_rc.py</vh></v>
<v t="amd_yen.20130429214002.4033"><vh>@file ui_bookmark.py</vh></v>
<v t="amd_yen.20130429214002.4039"><vh>@file ui_mainwindow.py</vh></v>
</v>
</v>
<v t="amd_yen.20130429221223.2317"><vh>C2 第十一週程式</vh>
<v t="amd_yen.20130429221223.2318"><vh>@shadow c2/pyqt_add1.py</vh></v>
<v t="amd_yen.20130429221223.2321"><vh>@shadow c2/pyqt_button1.py</vh></v>
<v t="amd_yen.20130429221223.2322"><vh>@shadow c2/pyqt_calculate1.py</vh></v>
<v t="amd_yen.20130429221223.2323"><vh>@shadow c2/pyqt_painter1.py</vh></v>
<v t="mde_leo.20130509205544.8975"><vh>@shadow c2/pyqt_opengl1.py</vh></v>
<v t="mde_leo.20130509205544.8976"><vh>@shadow c2/pyqt_opengl2.py</vh></v>
<v t="amd_yen.20130501090735.3346"><vh>@shadow c2/pyside/hello1.py</vh></v>
<v t="amd_yen.20130501090735.3347"><vh>@shadow c2/pyside/hello_qml1.py</vh></v>
<v t="amd_yen.20130501090735.3348"><vh>@edit c2/pyside/view.qml</vh></v>
<v t="amd_yen.20130501090735.3349"><vh>@shadow c2/pyside/tetris.py</vh></v>
<v t="amd_yen.20130501090735.3350"><vh>@shadow c2/pyside/browser1.py</vh></v>
<v t="amd_yen.20130501090735.3351"><vh>@shadow c2/pyside/notepad1.py</vh></v>
<v t="amd_yen.20130429221223.10895" a="E"><vh>@path c2/Gmail</vh>
<v t="amd_yen.20130429221223.10896" a="E"><vh>@file main.py</vh></v>
<v t="amd_yen.20130429221223.10899"><vh>@file About.py</vh></v>
<v t="amd_yen.20130429221223.10903"><vh>@file AboutDialog.py</vh></v>
<v t="amd_yen.20130429221223.10908"><vh>@file bmain.py</vh></v>
<v t="amd_yen.20130429221223.10917"><vh>@file GMail.py</vh></v>
<v t="amd_yen.20130429221223.10925"><vh>@file MainWindow.py</vh></v>
<v t="amd_yen.20130429221223.10930"><vh>@file Missing.py</vh></v>
<v t="amd_yen.20130429221223.10934"><vh>@@file MissingDialog.py</vh>
<v t="amd_yen.20130429221223.10935"><vh>&lt;&lt;declarations&gt;&gt; (MissingDialog)</vh></v>
<v t="amd_yen.20130429221223.10936" a="E"><vh>class Ui_MissingDialog</vh>
<v t="amd_yen.20130429221223.10937"><vh>setupUi</vh></v>
<v t="amd_yen.20130429221223.10938"><vh>retranslateUi</vh></v>
</v>
</v>
</v>
</v>
<v t="amd.20130513215328.2669"><vh>C2 第十二週程式</vh>
<v t="amd.20130513215328.2671"><vh>@shadow c2/command_w12_1.py</vh></v>
<v t="amd.20130513215328.2670"><vh>@shadow c2/cherrypy_w12_1.py</vh></v>
<v t="amd.20130513215328.2818"><vh>@shadow c2/cherrypy_changer1.py</vh></v>
<v t="amd.20130514093510.2680"><vh>@edit c2/pyqt/avg1/main.py</vh></v>
<v t="amd.20130514093510.2682"><vh>@edit c2/pyqt/avg1/mainwindow.ui</vh></v>
<v t="amd.20130514093510.2681"><vh>@edit c2/pyqt/avg1/Ui_mainwindow.py</vh></v>
<v t="amd.20130515005753.3849"><vh>@path c2/pyqt/steroidHunt</vh>
<v t="amd.20130515005753.3850" a="E"><vh>@file main.py</vh></v>
<v t="amd.20130515005753.3852" a="E"><vh>@file mainwindow.py</vh></v>
<v t="amd.20130515005753.3856"><vh>@file scene.py</vh></v>
<v t="amd.20130515005753.3866"><vh>@file settings.py</vh></v>
<v t="amd.20130515005753.3868"><vh>@file test.py</vh></v>
<v t="amd.20130515005753.3872"><vh>@file tiles.py</vh></v>
</v>
</v>
<v t="amd_yen.20130312013510.1501"><vh>網誌內容</vh></v>
<v t="amd_yen.20130312013510.1498"></v>
<v t="amd_yen.20130308210411.2387" a="E"
expanded="amd_yen.20130308214521.2438,amd_yen.20130308214521.2440,amd_yen.20130309155804.1712,amd_yen.20130317094520.1538,amd_yen.20130406103207.2443,amd_yen.20130414200359.2119,amd_yen.20130414200359.2130,amd_yen.20130421114440.2838,amd_yen.20130421114440.2840,amd_yen.20130421114440.2842,amd_yen.20130423211907.2156,amd_yen.20130429221223.2314,amd_yen.20130501090735.3344,amd_yen.20130429221223.2316,amd_yen.20130506144326.2648,amd.20130517200829.4939,amd.20130517200829.2763,"><vh>@file c2.txt</vh></v>
</v>
<v t="amd_yen.20130308210411.2385" a="E"><vh>協同產品設計實習</vh>
<v t="amd_yen.20130309155804.1706"><vh>CD 第三週程式</vh>
<v t="amd_yen.20130309155804.1707" a="E"><vh>@shadow cd/spreadsheet.py</vh></v>
</v>
<v t="amd_yen.20130314194325.1746"><vh>CD 第四週程式</vh>
<v t="amd_yen.20130314194325.1747" a="E"><vh>@shadow cd/gearcontour.py</vh></v>
</v>
<v t="amd_yen.20130418193628.2122"><vh>CD 第八週程式</vh>
<v t="amd_yen.20130418193628.2123" a="E"><vh>@shadow cd/partview/objstl.js</vh></v>
<v t="amd_yen.20130418193628.2126"><vh>@edit cd/partview/RequestAnimationFrame.js</vh></v>
<v t="amd_yen.20130418193628.2127"><vh>@edit cd/partview/index.php</vh></v>
</v>
<v t="amd_yen.20130312013510.1498"></v>
<v t="amd_yen.20130308210411.2392" a="E"
expanded="amd_yen.20130308210411.2393,amd_yen.20130314194325.1511,amd_yen.20130318140025.2834,amd_yen.20130309155804.1711,amd_yen.20130320201815.1570,amd_yen.20130421114440.2135,amd_yen.20130421114440.2136,amd.20130517200829.2761,"><vh>@file cd.txt</vh></v>
</v>
<v t="amd_yen.20130308210411.2386"><vh>網際內容管理</vh>
<v t="amd_yen.20130406103207.2438"><vh>django 程式開發</vh>
<v t="amd_yen.20130406103207.2442"><vh>@url Tutorial 1</vh></v>
<v t="amd_yen.20130406103207.2285"><vh>@edit wcm/django1.py</vh></v>
<v t="amd_yen.20130406103207.2286"><vh>@@button django project</vh></v>
<v t="amd_yen.20130406103207.2435"><vh>@edit wcm/mysite/mysite/settings.py</vh></v>
<v t="amd_yen.20130406103207.2434"><vh>@@button sync db</vh></v>
<v t="amd_yen.20130406103207.2287"><vh>@@button startapp polls</vh></v>
<v t="amd_yen.20130406103207.2436"><vh>@edit wcm/mysite/polls/models.py</vh></v>
<v t="amd_yen.20130406103207.2437"><vh>@@button sql polls</vh></v>
<v t="amd_yen.20130406103207.2434"></v>
<v t="amd_yen.20130406103207.2439"><vh>@url Tutorial 2</vh></v>
<v t="amd_yen.20130406103207.2440"><vh>@edit wcm/mysite/mysite/urls.py</vh></v>
<v t="amd_yen.20130406103207.2441"><vh>啟動伺服器</vh></v>
</v>
<v t="amd_yen.20130503085936.2410"><vh>WCM 第三週程式</vh>
<v t="amd_yen.20130503085936.2411"><vh>@shadow wcm/wordpress1.py</vh></v>
</v>
<v t="amd_yen.20130429221223.2319" a="E"><vh>WCM 第十週程式</vh>
<v t="amd_yen.20130429221223.2320"><vh>@shadow wcm/exchange1.py</vh></v>
<v t="amd_yen.20130503085936.2409"><vh>@shadow wcm/pyside_exchange1.py</vh></v>
</v>
<v t="amd_yen.20130312013510.1498"></v>
<v t="amd_yen.20130308210411.2407" a="E"
expanded="amd_yen.20130308210411.2408,amd_yen.20130418193628.2823,amd_yen.20130503085936.2412,"><vh>@file wcm.txt</vh></v>
</v>
<v t="amd_yen.20130308221230.2492"><vh>綜合資料</vh>
<v t="amd_yen.20130312013510.1498"></v>
<v t="amd_yen.20130308221230.2493" a="E"
expanded="amd_yen.20130308221230.2494,amd_yen.20130308221230.2481,amd_yen.20130312013510.2093,amd_yen.20130503185304.5151,amd_yen.20130308221230.2485,amd_yen.20130311141127.1492,amd_yen.20130309155804.1713,amd_yen.20130322213429.1578,amd_yen.20130321213622.1575,amd_yen.20130409235757.1779,amd_yen.20130409235757.1782,"><vh>@file misc.txt</vh></v>
</v>
</v>
<v t="mde_leo.20130510215619.7519"><vh>可攜 Leo Editor</vh>
<v t="mde_leo.20130510215619.7520"><vh>從 LeoDocs.leo 學習</vh></v>
<v t="mde_leo.20130510215619.7521"><vh>leo editor tutorial 1</vh></v>
<v t="mde_leo.20130510215619.7522"><vh>leo editor tutorial 2</vh></v>
<v t="mde_leo.20130510215619.7523"><vh>leo editor tutorial 3</vh></v>
<v t="mde_leo.20130510215619.7524"><vh>leo editor tutorial 4</vh></v>
<v t="mde_leo.20130510215619.7525"><vh>leo editor tutorial 5</vh></v>
<v t="mde_leo.20130510215619.7526"><vh>leo editor tutorial 6</vh></v>
</v>
<v t="mde_leo.20130510215619.7355"><vh>機械設計的本質</vh>
<v t="mde_leo.20130510215619.7356" a="E"><vh>電腦輔助機械設計</vh>
<v t="mde_leo.20130510215619.7357"><vh>電腦</vh>
<v t="mde_leo.20130510215619.7358" a="E"><vh>程式</vh>
<v t="mde_leo.20130510215619.7359" a="E"><vh>依自由度分類</vh>
<v t="mde_leo.20130510215619.7360"><vh>套件</vh></v>
<v t="mde_leo.20130510215619.7361"><vh>二次開發</vh></v>
<v t="mde_leo.20130510215619.7362"><vh>自行編寫</vh></v>
</v>
<v t="mde_leo.20130510215619.7363" a="E"><vh>依操作系統分類</vh>
<v t="mde_leo.20130510215619.7364"><vh>Windows</vh></v>
<v t="mde_leo.20130510215619.7365"><vh>Linux</vh></v>
<v t="mde_leo.20130510215619.7366"><vh>iOS</vh></v>
</v>
<v t="mde_leo.20130510215619.7367" a="E"><vh>依功能分類</vh>
<v t="mde_leo.20130510215619.7368"><vh>文書處理</vh></v>
<v t="mde_leo.20130510215619.7369" a="E"><vh>資料處理</vh>
<v t="mde_leo.20130510215619.7370"><vh>格式轉檔</vh></v>
</v>
<v t="mde_leo.20130510215619.7371"><vh>功能模擬</vh></v>
<v t="mde_leo.20130510215619.7372"><vh>自動控制</vh></v>
<v t="mde_leo.20130510215619.7373"><vh>內容管理</vh></v>
</v>
<v t="mde_leo.20130510215619.7374"><vh>依語言分類</vh>
<v t="mde_leo.20130510215619.7375"><vh>Python</vh></v>
<v t="mde_leo.20130510215619.7376"><vh>C</vh></v>
<v t="mde_leo.20130510215619.7377"><vh>C++</vh></v>
<v t="mde_leo.20130510215619.7378"><vh>PHP</vh></v>
<v t="mde_leo.20130510215619.7379"><vh>JavaScript</vh></v>
<v t="mde_leo.20130510215619.7380"><vh>Java</vh></v>
<v t="mde_leo.20130510215619.7381"><vh>Lua</vh></v>
<v t="mde_leo.20130510215619.7382"><vh>Lisp</vh></v>
<v t="mde_leo.20130510215619.7383"><vh>Forth</vh></v>
</v>
<v t="mde_leo.20130510215619.7384" a="E"><vh>依操作模式分類</vh>
<v t="mde_leo.20130510215619.7385"><vh>圖形化人機介面</vh></v>
<v t="mde_leo.20130510215619.7386"><vh>文字介面</vh></v>
<v t="mde_leo.20130510215619.7387"><vh>指令介面</vh></v>
</v>
</v>
<v t="mde_leo.20130510215619.7388"><vh>網路</vh>
<v t="mde_leo.20130510215619.7389"><vh>功能</vh>
<v t="mde_leo.20130510215619.7390"><vh>搜尋資料</vh></v>
<v t="mde_leo.20130510215619.7391"><vh>整合並提供資料</vh></v>
<v t="mde_leo.20130510215619.7392"><vh>自動傳輸資料</vh></v>
</v>
<v t="mde_leo.20130510215619.7393"><vh>使用注意要項</vh>
<v t="mde_leo.20130510215619.7394"><vh>連線查詢</vh></v>
<v t="mde_leo.20130510215619.7395"><vh>代理主機</vh></v>
<v t="mde_leo.20130510215619.7396"><vh>DNS</vh></v>
<v t="mde_leo.20130510215619.7397"><vh>防火牆</vh></v>
<v t="mde_leo.20130510215619.7398"><vh>SSL</vh></v>
<v t="mde_leo.20130510215619.7399"><vh>PGP</vh></v>
</v>
</v>
<v t="mde_leo.20130510215619.7400"><vh>主機</vh>
<v t="mde_leo.20130510215619.7401"><vh>個人電腦</vh></v>
<v t="mde_leo.20130510215619.7402"><vh>伺服電腦</vh>
<v t="mde_leo.20130510215619.7403"><vh>叢集電腦</vh></v>
<v t="mde_leo.20130510215619.7404"><vh>分散式電腦</vh></v>
<v t="mde_leo.20130510215619.7405"><vh>GPU電腦</vh></v>
<v t="mde_leo.20130510215619.7406"><vh>雲端主機</vh></v>
</v>
<v t="mde_leo.20130510215619.7407"><vh>筆記型電腦</vh></v>
<v t="mde_leo.20130510215619.7408"><vh>平板</vh></v>
<v t="mde_leo.20130510215619.7409"><vh>手機</vh></v>
<v t="mde_leo.20130510215619.7410"><vh>嵌入式裝置</vh>
<v t="mde_leo.20130510215619.7411" a="E"><vh>功能分類</vh>
<v t="mde_leo.20130510215619.7412"><vh>感測</vh></v>
<v t="mde_leo.20130510215619.7413"><vh>傳輸</vh></v>
<v t="mde_leo.20130510215619.7414"><vh>遙控</vh></v>
<v t="mde_leo.20130510215619.7415"><vh>運算</vh></v>
</v>
</v>
</v>
</v>
<v t="mde_leo.20130510215619.7416"><vh>輔助</vh>
<v t="mde_leo.20130510215619.7417" a="E"><vh>分類</vh>
<v t="mde_leo.20130510215619.7418" a="E"><vh>依自動化程度</vh>
<v t="mde_leo.20130510215619.7419"><vh>自動完成設計</vh></v>
<v t="mde_leo.20130510215619.7420"><vh>半自動完成設計</vh></v>
<v t="mde_leo.20130510215619.7421"><vh>增進設計效率</vh></v>
</v>
<v t="mde_leo.20130510215619.7422" a="E"><vh>依所採原理</vh>
<v t="mde_leo.20130510215619.7423" a="E"><vh>造型</vh>
<v t="mde_leo.20130510215619.7424" a="E"><vh>平面</vh>
<v t="mde_leo.20130510215619.7425"><vh>2D圖學</vh></v>
</v>
<v t="mde_leo.20130510215619.7426" a="E"><vh>空間</vh>
<v t="mde_leo.20130510215619.7427"><vh>3D圖學</vh></v>
</v>
</v>
<v t="mde_leo.20130510215619.7428"><vh>力學</vh>
<v t="mde_leo.20130510215619.7429"><vh>靜力</vh></v>
<v t="mde_leo.20130510215619.7430"><vh>動力</vh></v>
<v t="mde_leo.20130510215619.7431"><vh>材料</vh></v>
<v t="mde_leo.20130510215619.7432"><vh>熱</vh></v>
<v t="mde_leo.20130510215619.7433"><vh>流體</vh></v>
</v>
</v>
<v t="mde_leo.20130510215619.7434" a="E"><vh>依設計者數量</vh>
<v t="mde_leo.20130510215619.7435"><vh>個人</vh></v>
<v t="mde_leo.20130510215619.7436"><vh>多人協同</vh></v>
</v>
<v t="mde_leo.20130510215619.7437" a="E"><vh>依取得費用</vh>
<v t="mde_leo.20130510215619.7438"><vh>商用付費</vh></v>
<v t="mde_leo.20130510215619.7439"><vh>自由免費</vh></v>
</v>
<v t="mde_leo.20130510215619.7440" a="E"><vh>依程式開放程度</vh>
<v t="mde_leo.20130510215619.7441"><vh>原始碼封閉</vh></v>
<v t="mde_leo.20130510215619.7442"><vh>原始碼公開</vh></v>
<v t="mde_leo.20130510215619.7443"><vh>核心封閉方案開放</vh></v>
</v>
</v>
</v>
<v t="mde_leo.20130510215619.7444"><vh>機械設計</vh>
<v t="mde_leo.20130510215619.7445"><vh>有關設計</vh></v>
<v t="mde_leo.20130510215619.7446" a="E"><vh>分類</vh>
<v t="mde_leo.20130510215619.7447"><vh>依所採原理</vh>
<v t="mde_leo.20130510215619.7448"><vh>造型</vh></v>
<v t="mde_leo.20130510215619.7449"><vh>力學</vh></v>
</v>
<v t="mde_leo.20130510215619.7450"><vh>依元件現存與否</vh>
<v t="mde_leo.20130510215619.7451"><vh>標準元件選用</vh></v>
<v t="mde_leo.20130510215619.7452"><vh>客製化元件設計</vh></v>
</v>
<v t="mde_leo.20130510215619.7453"><vh>依原創設計與否</vh>
<v t="mde_leo.20130510215619.7454"><vh>原創設計</vh>
<v t="mde_leo.20130510215619.7455"><vh>ODM</vh></v>
<v t="mde_leo.20130510215619.7456"><vh>OBM</vh></v>
</v>
<v t="mde_leo.20130510215619.7457"><vh>非原創設計</vh>
<v t="mde_leo.20130510215619.7458"><vh>OEM</vh></v>
</v>
</v>
<v t="mde_leo.20130510215619.7459" a="E"><vh>依工業分類</vh>
<v t="mde_leo.20130510215619.7460"><vh>工具機</vh>
<v t="mde_leo.20130510215619.7461"><vh>傳統加工機</vh>
<v t="mde_leo.20130510215619.7462"><vh>車床</vh></v>
<v t="mde_leo.20130510215619.7463"><vh>銑床</vh></v>
<v t="mde_leo.20130510215619.7464"><vh>鑽床</vh></v>
<v t="mde_leo.20130510215619.7465"><vh>磨床</vh></v>
<v t="mde_leo.20130510215619.7466"><vh>锯床</vh></v>
<v t="mde_leo.20130510215619.7467"><vh>沖壓床</vh></v>
<v t="mde_leo.20130510215619.7468"><vh>剪床</vh></v>
<v t="mde_leo.20130510215619.7469"><vh>NC 工具機</vh></v>
</v>
<v t="mde_leo.20130510215619.7470"><vh>非傳統加工機</vh>
<v t="mde_leo.20130510215619.7471"><vh>放電加工機</vh></v>
<v t="mde_leo.20130510215619.7472"><vh>超音波加工機</vh></v>
<v t="mde_leo.20130510215619.7473"><vh>雷射加工機</vh></v>
</v>
</v>
<v t="mde_leo.20130510215619.7474"><vh>產業機械</vh>
<v t="mde_leo.20130510215619.7475"><vh>紡織與成衣機械</vh></v>
<v t="mde_leo.20130510215619.7476"><vh>包裝機械</vh></v>
<v t="mde_leo.20130510215619.7477"><vh>木工機械</vh></v>
<v t="mde_leo.20130510215619.7478"><vh>化工機械</vh></v>
<v t="mde_leo.20130510215619.7479"><vh>塑橡膠機械</vh></v>
<v t="mde_leo.20130510215619.7480"><vh>造紙印刷機械</vh></v>
<v t="mde_leo.20130510215619.7481"><vh>食品飲料機械</vh></v>
<v t="mde_leo.20130510215619.7482"><vh>農業機械</vh></v>
</v>
<v t="mde_leo.20130510215619.7483"><vh>通用機械</vh>
<v t="mde_leo.20130510215619.7484"><vh>模具</vh></v>
<v t="mde_leo.20130510215619.7485"><vh>壓縮機、鼓風機、風扇</vh></v>
<v t="mde_leo.20130510215619.7486"><vh>機械手臂</vh></v>
<v t="mde_leo.20130510215619.7487"><vh>輸送設備</vh></v>
<v t="mde_leo.20130510215619.7488"><vh>事務機械</vh></v>
<v t="mde_leo.20130510215619.7489"><vh>污染防治設備</vh></v>
</v>
<v t="mde_leo.20130510215619.7490" a="E"><vh>動力機械</vh>
<v t="mde_leo.20130510215619.7491"><vh>內燃機</vh></v>
<v t="mde_leo.20130510215619.7492"><vh>渦輪機</vh></v>
<v t="mde_leo.20130510215619.7493"><vh>鍋爐</vh></v>
<v t="mde_leo.20130510215619.7494"><vh>電動機</vh></v>
</v>
<v t="mde_leo.20130510215619.7495" a="E"><vh>機械元件</vh>
<v t="mde_leo.20130510215619.7496"><vh>軸</vh></v>
<v t="mde_leo.20130510215619.7497"><vh>軸承</vh></v>
<v t="mde_leo.20130510215619.7498"><vh>齒輪</vh></v>
<v t="mde_leo.20130510215619.7499"><vh>連結</vh></v>
<v t="mde_leo.20130510215619.7500"><vh>焊接</vh></v>
<v t="mde_leo.20130510215619.7501"><vh>凸輪</vh></v>
<v t="mde_leo.20130510215619.7502"><vh>液氣壓元件</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="mde_leo.20130510215619.7503" a="E"><vh>何謂設計?</vh>
<v t="mde_leo.20130510215619.7504"><vh>設計衡量</vh></v>
<v t="mde_leo.20130510215619.7505"><vh>設計類型</vh></v>
</v>
<v t="mde_leo.20130510215619.7506" a="E"><vh>何謂機械?</vh>
<v t="mde_leo.20130510215619.7507"><vh>機械內容</vh></v>
</v>
<v t="mde_leo.20130510215619.7508"><vh>電腦輔助設計</vh></v>
<v t="mde_leo.20130510215619.7509"><vh>協同設計</vh></v>
<v t="mde_leo.20130510215619.7510"><vh>GPU 相關</vh></v>
</v>
<v t="amd_yen.20130423211907.2155"><vh>電腦輔助機械繪圖</vh>
<v t="amd_yen.20130423211907.2156" a="E"><vh>2D PythonCAD</vh>
<v t="amd_yen.20130423211907.2158"><vh>pickle 與 unpickle</vh></v>
</v>
<v t="amd_yen.20130423211907.2157"><vh>3D FreeCAD</vh></v>
</v>
<v t="amd_yen.20130406103207.2760"><vh>C Pointer and Array</vh>
<v t="amd_yen.20130503185304.5137" a="E"><vh>C 程式</vh>
<v t="amd_yen.20130503185304.5138"><vh>@auto c/ch1_1.c</vh></v>
<v t="amd_yen.20130503185304.5139"><vh>@auto c/ch1.1.c</vh></v>
<v t="amd_yen.20130503185304.5140"><vh>@auto c/ch2.1.c</vh></v>
<v t="amd_yen.20130503185304.5141"><vh>@auto c/ch3.1.c</vh></v>
<v t="amd_yen.20130503185304.5142"><vh>@auto c/ch4.1.c</vh></v>
<v t="amd_yen.20130503185304.5143"><vh>@auto c/ch5.1.c</vh></v>
<v t="amd_yen.20130503185304.5144"><vh>@auto c/ch5.2.c</vh></v>
<v t="amd_yen.20130503185304.5146"><vh>@auto c/ch6.1.c</vh></v>
</v>
<v t="amd_yen.20130406103207.2761"><vh>PREFACE</vh></v>
<v t="amd_yen.20130406103207.2762"><vh>INTRODUCTION</vh></v>
<v t="amd_yen.20130406103207.2763"><vh>Chapter 1: What is a Pointer?</vh></v>
<v t="amd_yen.20130406103207.2764"><vh>Chapter 2: Pointer Types and Arrays.</vh></v>
<v t="amd_yen.20130406103207.2765"><vh>Chapter 3: Pointers and Strings</vh></v>
<v t="amd_yen.20130406103207.2766"><vh>Chapter 4: More on Strings</vh></v>
<v t="amd_yen.20130406103207.2767"><vh>Chapter 5: Pointers and Structures</vh></v>
<v t="amd_yen.20130503185304.5145"><vh>Chapter 6: More on Strings and Arrays of Strings</vh></v>
<v t="amd_yen.20130503185304.5147"><vh>Chapter 7: More on Multi-Dimensional Arrays</vh></v>
<v t="amd_yen.20130503185304.5148"><vh>Chapter 8: Pointers to Arrays</vh></v>
<v t="amd_yen.20130503185304.5149"><vh>Chapter 9: Pointers and Dynamic Allocation of Memory</vh></v>
<v t="amd_yen.20130503185304.5150"><vh>Chapter 10: Pointers to Functions</vh></v>
</v>
<v t="amd_yen.20130413002743.2100"><vh>Berkeley CS61a 課程演變</vh>
<v t="amd_yen.20130413002743.2101" a="E"><vh>如何學習程式語言</vh>
<v t="amd_yen.20130413002743.2104"><vh>Python 3 安裝</vh></v>
</v>
</v>
<v t="amd_yen.20130413002743.2102" a="E"><vh>機械設計工程系程式課程演變</vh>
<v t="amd_yen.20130413002743.2103"><vh>符號式機構分析</vh></v>
<v t="amd_yen.20130426235501.4331" a="E"><vh>Python 與動態系統分析</vh>
<v t="amd_yen.20130426235501.4332"><vh>Modelica 簡介</vh></v>
<v t="amd_yen.20130426235501.4333"><vh>Sympy 機構模擬</vh></v>
</v>
<v t="amd_yen.20130418193628.2121"><vh>PHP 與 Javascript</vh></v>
</v>
<v t="mde_leo.20130508162404.2651"><vh>KMOLab 套件開發</vh></v>
<v t="amd_yen.20130503185304.2957"><vh>C2WP</vh>
<v t="amd_yen.20130503185304.2958"><vh>Leo 編輯器文書處理</vh></v>
<v t="amd_yen.20130503185304.2959"><vh>文書處理討論</vh></v>
<v t="amd_yen.20130503185304.2960" a="E"><vh>直接採 LaTeX 編輯</vh>
<v t="amd_yen.20130503185304.2961" a="E"><vh>LaTeX</vh>
<v t="amd_yen.20130503185304.2962"><vh>@button latex ex1.tex</vh></v>
<v t="amd_yen.20130503185304.2963" a="EO"><vh>@file c2wp/latex/ex1.tex</vh>
<v t="amd_yen.20130503185304.2976" a="E"><vh>相關設定</vh>
<v t="amd_yen.20130503185304.2977"><vh>&lt;&lt; end document &gt;&gt;</vh></v>
<v t="amd_yen.20130503185304.2978"><vh>&lt;&lt; make title &gt;&gt;</vh></v>
<v t="amd_yen.20130503185304.2979"><vh>&lt;&lt; begin document &gt;&gt;</vh></v>
<v t="amd_yen.20130503185304.2980"><vh>&lt;&lt; verbatim &gt;&gt;</vh></v>
<v t="amd_yen.20130503185304.2981"><vh>&lt;&lt; author title &gt;&gt;</vh></v>
<v t="amd_yen.20130503185304.2982"><vh>&lt;&lt; CJK &gt;&gt;</vh></v>
<v t="amd_yen.20130503185304.2983"><vh>&lt;&lt; document class &gt;&gt;</vh></v>
</v>
<v t="amd_yen.20130503185304.2972"><vh>內文</vh></v>
<v t="amd_yen.20130503185304.2973"><vh>測試</vh></v>
<v t="amd_yen.20130503185304.2974"><vh>以下為來自外部的檔案</vh></v>
<v t="amd_yen.20130503185304.2975"><vh>@auto latex/outside.tex</vh></v>
<v t="amd_yen.20130503185304.2976" a="E"></v>
</v>
</v>
<v t="amd_yen.20130503185304.2984" a="E"><vh>參考資料</vh>
<v t="amd_yen.20130503185304.2985"><vh>向量繪圖</vh></v>
<v t="amd_yen.20130503185304.2986" a="E"><vh>About Leo</vh>
<v t="amd_yen.20130503185304.2987"><vh>reread node</vh></v>
<v t="amd_yen.20130503185304.2988"><vh>有關編寫 php 程式碼</vh></v>
<v t="amd_yen.20130503185304.2989"><vh>有關註解符號</vh></v>
<v t="amd_yen.20130503185304.2990"><vh>以 plugin 增加選單</vh></v>
<v t="amd_yen.20130503185304.2991"><vh>利用 Leo 開發 Leo</vh></v>
</v>
<v t="amd_yen.20130503185304.2992" a="E"><vh>LaTeX 參考</vh>
<v t="mde_leo.20130510215619.6870"><vh>LaTeX 與 Word 比較</vh></v>
<v t="amd_yen.20130503185304.2993"><vh>簡介 LaTeX</vh></v>
<v t="amd_yen.20130503185304.2994"><vh>標題中文化</vh></v>
<v t="amd_yen.20130503185304.2995"><vh>特殊處理</vh></v>
</v>
<v t="amd_yen.20130503185304.2996"><vh>rst3 討論</vh></v>
</v>
</v>
<v t="amd_yen.20130503185304.2997" a="E"><vh>按鈕</vh>
<v t="amd_yen.20130503185304.2998" a="E"><vh>@button c2wp</vh>
<v t="amd_yen.20130503185304.2999"><vh>&lt;&lt; html manual &gt;&gt;</vh></v>
<v t="amd_yen.20130503185304.3000"><vh>&lt;&lt; pdf manual &gt;&gt;</vh></v>
</v>
</v>
<v t="amd_yen.20130503185304.3001" a="E"><vh>設定檔案</vh>
<v t="amd_yen.20130503185304.3002" a="E"><vh>@path c2wp</vh>
<v t="amd_yen.20130503185304.3003"><vh>@edit conf.py</vh></v>
<v t="amd_yen.20130503185304.3004"><vh>@edit index.html.txt</vh></v>
<v t="amd_yen.20130503185304.3005"><vh>@edit make.bat</vh></v>
</v>
<v t="amd_yen.20130503185304.3006"><vh>位於 exts 目錄的中文分詞程式</vh>
<v t="amd_yen.20130503185304.3007"><vh>@edit exts\zh.py</vh></v>
<v t="amd_yen.20130503185304.3008"><vh>@edit exts\chinese_search.py</vh></v>
<v t="amd_yen.20130503185304.3009"><vh>@edit exts\sphinx.search.py</vh></v>
</v>
</v>
<v t="amd_yen.20130503185304.3010" a="E"><vh>Latex 後續處理(選項)</vh>
<v t="amd_yen.20130503185304.3011" a="O"><vh>@edit c2wp/_build/latex/index.tex</vh></v>
<v t="amd_yen.20130503185304.3012"><vh>@edit c2wp/_build/latex/index_twocolumn.tex</vh></v>
<v t="amd_yen.20130503185304.3013"><vh>以下為雙欄位 pdf 產生按鈕</vh></v>
<v t="amd_yen.20130503185304.3014"><vh>@button two_column</vh></v>
</v>
<v t="amd_yen.20130503185304.3015"><vh>c2wp report</vh>
<v t="amd_yen.20130503185304.3016" a="E"><vh>選項設定</vh>
<v t="amd_yen.20130503185304.3017" a="E"><vh>@rst c2wp/frontmatter.html</vh>
<v t="amd_yen.20130503185304.3018"><vh>前言</vh></v>
<v t="amd_yen.20130503185304.3019"><vh>數學方程式(LaTeX)</vh></v>
<v t="amd_yen.20130503185304.3020"><vh>圖形</vh></v>
<v t="amd_yen.20130503185304.3021"><vh>數學(rest)</vh></v>
<v t="amd_yen.20130503185304.3022"><vh>參考資料</vh></v>
</v>
</v>
</v>
<v t="amd_yen.20130503185304.3023"><vh>@auto c2wp/fromoutside.html.txt</vh></v>
<v t="amd_yen.20130503185304.3024"><vh>@auto c2wp/collaboration3.html.txt</vh></v>
</v>
<v t="amd_yen.20130504232827.6216" a="E"><vh>履歷表</vh>
<v t="amd_yen.20130504232827.6219"><vh>@button gen resume</vh></v>
<v t="amd_yen.20130504232827.6217"><vh>@edit c2wp/resume/resume.cls</vh></v>
<v t="amd_yen.20130504232827.6218"><vh>@edit c2wp/resume/myresume.tex</vh></v>
</v>
<v t="amd_yen.20130504232827.8947"><vh>lshort</vh>
<v t="amd_yen.20130504232827.8948"><vh>@button lshort pdf</vh></v>
<v t="amd_yen.20130504232827.8949"><vh>@edit lshort/lshort.tex</vh></v>
<v t="amd_yen.20130504232827.8950"><vh>@edit lshort/lshort-base.tex</vh></v>
<v t="amd_yen.20130504232827.8951"><vh>@edit lshort/overview.tex</vh></v>
<v t="amd_yen.20130504232827.8952"><vh>@edit lshort/title.tex</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="amd.20130513215328.2669"></t>
<t tx="amd.20130514093510.2683"></t>
<t tx="amd.20130514093510.2692"></t>
<t tx="amd.20130514093510.2702"></t>
<t tx="amd.20130515005753.3849">source: http://code.google.com/p/steroidhunt/</t>
<t tx="amd_yen.20130306001037.1797"></t>
<t tx="amd_yen.20130306001037.1798">QSplitter::handle {
    background-color: #CAE1FF; /* lightSteelBlue1 */
}

QStackedWidget {
    /* background-color:lightpink; */
    border-color: red;
    padding: 0px;
    /* border-width: 0px; */
    /* background-color: yellow; */
}

QSplitter {
    border-color: white;
    background-color: white;
    border-style: solid;
}

QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 18px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 17px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 17px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 18px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 17px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 17px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="amd_yen.20130306001037.1799">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="amd_yen.20130307204656.1443">希望能夠比照 Leo Doc 的方式建構, 將每一週的上課內容進行註記, 然後使用者可以利用 Sphinx 與 LaTeX 將內容轉換成 html 與 pdf  檔案格式.

編寫方式採用 @file 與 @rst

希望參考

V:\misc\leo-editor-snapshot-20130223\leo\leoeditor_doc\LeoDocs.leo#Startup

註: 左手按住 Ctrl, 然後右手點選下一個子書籤就會帶出 Leo 的手冊 (假如是在 misc 目錄下工作時), 並且逐步將該內容中產生 html 與 pdf 的架構, 複製到課程相關的資料編輯模式中.

基本資料更新的流程如下:

1. 由網路上下載 portablKMOL, 並且啟動, 系統會自動開啟 Leo Editor 以及其他網際相關伺服器.

(需要有 portableGit, 至於其他相關工具與模組則可最佳化到最小容量, 額外的模組則依照需求再由網路中下載, 以附加的模式增加可攜系統的功能)

2. 以 git clone https://github.com/chiamingyen/mdeCourse.git

在電腦中的某一目錄中, 複製 gihub 有關 mdeCourse 的最新版本.

3. 利用 portablKMOL 中的 Leo Editor 開啟 mdeCourse 中的課程相關 .leo 檔案.

4. 配合課程進行, 修改課程筆記.

5. 下課之前, 以 portableGit 執行

git add .

git commit -m "commit message"

git push

但是此階段需要 .ssh 對應的 private key 資料

或許也可以利用 portableGithub 以登入的模式下, 將上述 clone 目錄中的資料, 執行 commit 與 publish 或 sync 的動作.</t>
<t tx="amd_yen.20130307204656.9867">V:\misc\leo-editor-snapshot-20130223\leo\leoeditor_doc\LeoDocs.leo#Startup</t>
<t tx="amd_yen.20130308103121.2379">2013.02

由於實際上課時, 必須配合各週次進行, 但是每幾週又會組成某一特定架構的介紹或實習, 因此 clone node 在這裡或許就可以派上用途, 例如花三週來說明 sgw 用於協同產品設計實習的群組套件搭建, 因此可以將 sgw 套件搭建流程一分為三, 並且在各週逐一完成某一特定內容的設定與實習, 而在手冊建立時, 則取三週的教學內容, 以 clone node 的方式組成 sgw 套件搭建與應用的主題.

當三週的設定與實習完成後, sgw 的設定與實習教材也能夠同步完成.

其次在上課的當下, 設法利用課程內容, 以程式建立 TCExam 相容的考題, 應該也是一項 Leo 可以發揮的地方, 由各週的上課內容中, 以特定知識或認知為考題的主軸, 然後納入 Leo 的延伸程式, 就能夠同步轉為考試題庫.

2013.03.13

重新架構 mdeCourse, 將先前的課程 github 刪除後重新在 .gitignore 中加入 _build 目錄, 讓每次所建立的 html 與 latex 檔案目錄不會送到 github.

假如配合目前上課內容的規劃, blog.kmol.info 是否仍有存在的必要? 應該可以設法配合 html 目錄, 由 Leo Editor 中的按鍵功能, 啟動將最新的 html 目錄送到某一主機對應內容, 讓學員都能擷取最新的課程相關資料, 也能夠從 github clone 最新的課程內容架構.

由於整體系統採用 Python3, 部分 Sphinx extension 功能還無法使用, html 中的中文搜尋也尚未啟動 (卡在繁體中文分詞的使用, 目前並沒有很好的方案).

PortableKMOL 能否再精簡?以配合導入 Leo Editor 之後的上課模式?

基本的架構:

Local - portableKMOL + local github clone

Remote - github repositories + OpenShift 上的 CMSimple XH

WordPress - 群組網誌

Simple Groupware - 專案管理系統

2013.03.18

以目前的想法, 將 Leo Editor 中的節點內容透過程式直接發布到 Wordpress 與 CMSimple 應該是最佳的做法, 雖然 Sphinx 可以將 rst 轉為 html, 但是中文內容搜尋問題較麻煩, 且採用 Javascript 擷取關鍵字庫的方式搜尋, 並沒有全文搜尋好, 因此現在傾向設法將節點內容轉為 CMSimple 的 content.htm 格式, 然後讓網際內容管理系統與 Leo Editor 中的節點同步.

另外一個考量則是將節點內容送到 Wordpress (透過 xmlrpc.php), 假如能夠在新增網誌內容同時取得遠端網誌存入資料庫的 id, 後續才能透過此對應 id 進行更新或刪除的動作.

為了讓 sphinx-build -b singlehtml 所產生的單一 html 檔案, 能夠轉為 CMSimple 的 content.htm, 必須要動用到 beautiful soup: http://www.crummy.com/software/BeautifulSoup/

產生單一 singlehtml 只要將 make.bat 中, "html" 程序中的 html 換成 singlehtml 就可以完成.

if "%1" == "html" (
    REM 若將 html 改為 singlehtml 則會建立一個單一 html 檔案
    REM %SPHINXBUILD% -b singlehtml %ALLSPHINXOPTS% _build/html
	%SPHINXBUILD% -b html %ALLSPHINXOPTS% _build/html</t>
<t tx="amd_yen.20130308210411.2383">尚未完成的內容為中文的索引與搜尋.

有關 Sphinx 中文搜尋:

由於 Sphinx 的搜尋採 Javascript 進行, 實作時必須要對中文內容進行分詞, 然後再與對應頁面進行連結, 如此就會造成許多問題, 假如在進行關鍵字分詞時, 系統未能納入特定的關鍵字, 則使用者便無法進行搜尋.

最好的方式當然是全文搜尋, 但是必須耗費較多時間, 有關這點必須再加以深入考量.

假如能夠將 Sphinx 所產生的 html 導入 CMSimple XH 的 content.htm 中, 應該就可以解決許多問題, 至於對應的 images, downloads, jscripts 與 plugins 也都必須要加以整合.</t>
<t tx="amd_yen.20130308210411.2384">為何選擇 Python 3

這項主題應該在程式語言(一) 的第一堂課程就已經說明, 但是對於程式語言的初學者, 假如只學過 Python, 可能對於程式語言之間的比較與印象並不會十分深刻, 若以曾經使用過 FORTRAN, Pascal, Basic, Perl, Visual Basic, C/C++, PHP, Java, Forth, Lisp 等程式語言的經驗來說, Python 語言對於機械設計工程專業人員來說, 具有下列優點:

縮排造就程式容易解讀 

Python 程式容易閱讀, Python 程式語言採用內縮 (每一個內縮單位通常為 4 個空白鍵)來界定區域執行的範圍, 因此能夠正確執行的 Python 程式必須排列整齊, 區段明確, 因此容易閱讀(C/C++, PHP, Java 等程式語言都採用 {} 來界定執行區段, 且允許各種程式碼行段的排列方式, 因此可能造成程式碼不易閱讀).

高階資料結構有利運算

Python 程式語言內建高階資料結構, list, tuple, dictionary, set, string, bytes, int, float 等格式的交互應用下, 可以在不使用資料庫的情況下, 完成許多方便的數據與資料處理工作.

解譯流程允許嘗試設計

Python 程式語言採解譯(interpretation)執行, 動態性的資料型別方便程式的架構與編寫, 程式開發流程通常比採用編譯式(compiled)程式語言快上幾倍 (但是必須在程式執行速度上付出代價).

模組眾多有利延伸應用

Python 程式語言內建許多常用的程式庫模組(modules), 即使在未安裝其他附屬模組情況下, 就能夠解決許多機械設計相關流程問題.

自由開源且免付費

Python 程式語言自由開放(採接近 BSD 使用授權, 並且開放程式語言解譯系統的 C 原始碼, 除了 CPython, 還有以 Python 寫的 Pypy, 以 Java 寫的 Jython,  以 .Net 技術編寫的 IronPython, 以 Javascript 寫的 Skulpt 解譯系統)且跨操作系統平台 (可以在 Windows, Linux, Mac 系統上使用).

參考資料: https://github.com/bnmnetp/skulpt

黏結力強有利整合

Python 程式語言支援許多原本採 C/C++ 編寫程式庫的 CAD 核心碼介面擷取模組 (Open CASCADE), 2D 繪圖套件有 PythonCAD (PyQt), 3D CAD 則有 FreeCAD (PyQt), PLM 則有 OpenPLM (PyQt), 以及支援 mechanics, multibody dynamics 分析用的模擬套件.

參考資料: 

http://www.libremechanics.com/

Mechanics

http://sourceforge.net/projects/libremechanics/files/

Multibody dynamics

http://sourceforge.net/projects/pymbs/files/

Python 程式語言支援許多科學(Scipy)、數值(Numpy)與符號式(Sympy)運算模組, 可以解決許多類似 Matlab 套件的工程運算問題.

總而言之

從機械設計工程師應用的角度來看, Python 可以:

取代 Matlab 的地位, 以更宏觀的角度來發展各項應用模組

利用 Open CASCADE 核心, 透過 tkinter, PyQt, PySide 等 GUI 介面, 開發各種電腦輔助設計程式

結合 Sympy, IPython, Scipy 與 Numpy, 以網際介面開發協同產品設計應用程式

結合 C/C++ 進行機構系統的機電整合硬體自動控制

結合 Rhino3D, AutoDesk Maya 與 Blender, 進行產品的工業設計
</t>
<t tx="amd_yen.20130308210411.2385"></t>
<t tx="amd_yen.20130308210411.2386"></t>
<t tx="amd_yen.20130308210411.2403">@language python
import os
pos = c.find_h("KMOL Guide")[0]
c.selectPosition(pos)
c.k.simulateCommand('rst3')
&lt;&lt; html manual &gt;&gt;
&lt;&lt; pdf manual &gt;&gt;
</t>
<t tx="amd_yen.20130308210411.2404">'''
c is the commander of the outline containing the script.
g is Leo's leo.core.leoGlobals module.
p is the presently selected position, the same as c.p.
'''
d = c.scanAllDirectives(p)
# d 為 commander 由目前所在目錄進行指令設定掃描
# d 資料格式為 dictionary
''' 
實際操作下, d 為 
{'tabwidth': -4, 'lineending': None, 'language': 'python', 'encoding': None, 'pluginsList': [], 'pagewidth': 70, 'wrap': True, 'path': 'D:\\github\\mdeCourse\\2013spring', 'delims': ('#', '', '')}
'''
mandir = d.get('path') + "/document"
# 取出 d dictionary 中的 path 對應值 (也就是目前所在絕對目錄), 再加上 html, 因此 mandir 即為目前所在目錄下的 html 子目錄路徑
g.es(mandir) # 列出 html 子目錄路徑
os.chdir(mandir)  # 更換目錄到 html 子目錄
os.system('make html')  # 執行 make html
</t>
<t tx="amd_yen.20130308210411.2405"># you probably need to install several packages 
# to create pdf (e.g. jadetex)
mandir = d.get('path') + "/document"
g.es(mandir)
os.chdir(mandir)
os.system('make latex')
os.chdir('_build/latex')
# 接下來要設法將 .tex 轉為 .pdf
target_name = "KMOLdocumentation"
filename = target_name+".tex"
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
filename = target_name+".xdv"
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xdvipdfmx.exe -vv -E "+filename)

#
#os.system(target_name.replace(".xdv", ".pdf"))
filename = target_name+".pdf"
os.system(filename)
#os.system('../../fixup.pl &lt; Leodocumentation.tex &gt; LeoDoc.tex')
#os.system('make LeoDoc.pdf')</t>
<t tx="amd_yen.20130308210411.2406"></t>
<t tx="amd_yen.20130308221230.2437">程式語言(二) 承接程式語言(一) 課程內容除繼續強化學員對於 Python 基本程式語言的認識外, 將逐步導入最基本的程式化文書處理、網際程式、資料庫程式與輔助繪圖程式套件等單元教學.

程式化文書處理 - Leo editor 與 docutil 、Sphinx 等工具結合 restructuredText 格式資料的處理.

網際程式 - 以 CherryPy 網際框架為主的程式開發流程與基本雛形.

資料庫程式 - 以 SQLite 與 Pybean 為主的資料庫程式用法.

輔助繪圖程式套件 - 以 PythonCAD PyQt 程式套件為基礎的輔助繪圖程式開發.</t>
<t tx="amd_yen.20130308221230.2457">程式語言(二)

Python docutils 相關功能的應用, 可以透過網路擷取特定文件檔案 (mark down) 與影像檔, 然後以程式方法將資料轉成 html 文件.

之後這些 mark down 格式文件還可以利用 Python 的 Sphinx 套件轉為 .tex 格式, 並且進一步再轉為 pdf 檔案.

重點:

1. 純文件檔案內容, 以 mark down 方式整理, 可以讓各組員分散建置.

2. 若需要將各組員的資料內容, 整理成為報告或論文格式, 應該要善用網路與程式方法, 比較容易整合.

3. 程式模式下的文書處理, 可以用於網際協同, 相同的資料與內容處理, 也可套用到協同機械設計流程.</t>
<t tx="amd_yen.20130308221230.2462">讓學員自行建構可攜 portableKMOL 的目的在練習網際程式框架的基本組成 (程式開發環境、內容管理系統、全球資訊網伺服器、以及各類相關工具), 學員熟悉此流程後, 可以自行修改框架並且配合需要進行各模組的改版.

1. 利用程式進行文書處理

2. 利用程式進行分析運算與設計檔案轉換

以安裝 Python33 所使用的各模組, 各舉出應用範例, 並以機械設計相關應用為考量

    Python 3.3 版與相關模組安裝:
    
    Python 3.3 本體
    
    http://www.python.org/download/
    
    安裝後 C:\Python33 約佔 33 MB
    
    distribute (Python 的 module  installer, 可利用 easy_install 安裝所需模組)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#distribute
    
    安裝後 C:\Python33 約佔 37 MB
    
    pip (Python 的 module installer, 安裝後可利用 "pip install 模組名稱" 完成模組安裝
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#pip
    
    安裝後 C:\Python33 約佔 38 MB
    
    win32com (Python 與 Windows COM 物件的連結模組, 可以利用 win32com 來連結 SolidWorks, Inventor, Word, Excel 等 Windows 應用程式物件)
    
    http://sourceforge.net/projects/pywin32/files/pywin32/Build%20218/
    
    安裝後 C:\Python33 約佔 64 MB
    
    PIL (Python 的 Image library, 可以處理 2D 影像檔案)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#pil
    
    安裝後 C:\Python33 約佔 67 MB
    
    matplotlib (Python 類似 matlab 的 plot library)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#matplotlib
    
    安裝後 C:\Python33 約佔 91 MB
    
    numpy (Python 的 numerical library, 用於數值分析運算)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy
    
    安裝後 C:\Python33 約佔 138 MB
    
    sympy (Python 的 Symbolic manipulation 模組, 用於符號式運算 (相對於數值分析))
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#sympy
    
    安裝後 C:\Python33 約佔 175 MB
    
    scipy (Python 的 Scientific library)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy
    
    安裝後 C:\Python33 約佔 292 MB
    
    PyQt (Python 連結 Qt (nokia 的開源 GUI 程式庫, 更自由的對應類似版本為 Pyside) 的程式庫, 可用來開發圖形介面單機程式, 例如: Leo editor 就是採用 PyQt 開發)
    
    http://www.riverbankcomputing.com/software/pyqt/download
    
    安裝後 C:\Python33 約佔 374 MB
    
    docutils (Python 的 document utility, 可將 rst 格式檔案轉為 html)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#docutils
    
    安裝後 C:\Python33 約佔 383 MB
    
    Leo editor (以 Python 編寫的 outliner 與 IDE)
    
    http://www.greygreen.org/leo/
    
    安裝後 C:\Python33 約佔 401 MB
    
    以C:\Python33\Scripts\pip install sphinx
    
    安裝後 C:\Python33 約佔 413 MB

單機模式
網際模式

3. 利用程式進行協同設計

網際機械設計流程 - 以 Pyforum + brython 為範例, 可以開發 html5 網際程式
網際內容管理 - django based CMS
網際專案管理 - OpenPLM - http://wiki.openplm.org/trac/wiki/Credits
OpenERP/PLM - http://www.openerpplm.eu/</t>
<t tx="amd_yen.20130308221230.2463">自 C2 開始逐步讓學員涉入 portableKMOL 各模組的建構流程, 以便有能力自行修改內容並且依照需求改版.</t>
<t tx="amd_yen.20130308221230.2464">利用(Python)程式進行文書處理

1. 需要安裝 docutils 模組

2. 也可以利用 Sphinx 模組將 rst 檔案轉為 html 與 tex, 然後再以 MikeTeX 將 tex 轉為 pdf 檔案</t>
<t tx="amd_yen.20130308221230.2492"></t>
<t tx="amd_yen.20130308221230.3827"></t>
<t tx="amd_yen.20130309155804.1706"></t>
<t tx="amd_yen.20130312013510.1498">所謂的電子書內容, 就是 Leo 中據以產生 html 與 pdf 檔案的主要內容, 其中包含程式內容的引用.

在此一內容排版過程, Leo 提供大綱與內文的階層式架構, 可以納入 restructuredText 的標註語法, 透過 V:\IDE\Python33\Lib\site-packages\leo\plugins\rst3.py 延伸程式處理, 將資料轉換為 html 與 tex 格式檔案.

接著再利用 button 指令, 執行排版程式 portableLaTeX 的指令, 將 tex 資料轉為 pdf.

為了要能夠維繫各內容始終只有一個版本的精神, 必須要將電子書的內容加以分割, 除了以發布的週次作為區隔外, 各週的主要文字說明與程式也是分離, 程式內容位於各課程的分週程式區, 以 literalinclude 指令導入主文.

而這些主要的文字說明, 因為內置許多 rst 的指令, 若要再同時拿來作為網誌的發布內容, 有以下考量:
    
- 是採取 rst 內容經過 button 程式處理, 以分割主文加上程式的內容進行傳遞, 抑或在 rst 轉為 html 後, 同時設法產生網誌版本, 並且以自動讀取特定 local 電腦區域的帳號/密碼後才進行傳遞?
    
- 採 rst 轉換的方式, 工程較為浩大, 而 rst 轉 html 後, 則必須同時介入 Sphinx 轉換 html 的流程, 可以採 extension 的導入方式處理, 模式較為正統.
    
- Leo editor 一個內容, 多種用途 (view) 的特性, 在這個範例處理流程中, 將可充分展現.

所見即所的的文書處理系統(Word) 與程式化排版系統最大的差異並非只在最終的排版結果, 而是在排版的內容切割與不同格式導入的時機.

就 Word 的文書處理流程, 作者在準備內文時直接置入各片段內容的格式化處理, 並且馬上看到排版結果, 過程中內容的處理不僅即時而且統一, 比較適合作者數較少的文書處理流程.

程式化排版的流程則利用純文字的內容準備作為基礎, 雖然作者在過程中也可以對各排版內容進行格式的註記, 但是排版程式通常並未即時呈現結果, 而是將各片段的內容先準備好, 無論是圖片的置入或特定片段格式的安排, 都以純文字的內容+註記指令加以繕打.

此外, 利用 Leo 與 LaTeX 處理文書排版過程, 甚至連數學符號、方程式、說明流程圖也都可以純文字的"註記指令"表示, 一旦到了排版格式訂定的階段, 再決定最後文書處理所要納入的片段內容與出版格式安排, 此一流程比較適合多人以同步方式進行內容編輯的需求.
    
- 假如能夠使用 make.bat 中的 make wordpress, 過程中除了將 rst 轉換成 wordpress 的特定格式內容外, 並且會讀取相關發布的帳號密碼, 並且自動完成內容的發布, 應該是最佳處理方案.</t>
<t tx="amd_yen.20130312013510.1501">網誌內容為 clone 特定電子書的部分內容後, 針對網誌的 html 標註加以組合, 然後透過按鈕的程式執行, 將網誌內容直接送到 blog.kmol.info.

這裡有幾個重要必須突破:

電子書的內容必須配合進行分割, 例如: 區分為主文與程式, 然後主文的分段以 &lt;img src="/n/1.png"&gt;&lt;/img&gt; 為開頭, 並且依序進行增量.

&lt;!-- more --&gt; 的置入

&lt;pre&gt;&lt;/pre&gt; 程式碼的置入

[password-protect] [/password-protect] 的置入

若以 button 的指令送出網誌內容, 則連結網誌的管理者密碼該如何進行保全: 不放入 leo 但是卻能讓 button 程式讀取. (或可採用 minibuffer 區域的密碼讀取)</t>
<t tx="amd_yen.20130312013510.1824">#coding: utf-8

# 導入 os 模組
import os
'''
以下經由 urllib 向網路 URL 取得文件內容
'''
# 導入 urllib.request
import urllib.request
# 導入用來處理 rst2html 的 publish_string
from docutils.core import publish_string

# 可以取得目前所在節點與其下屬節點的內容
# 從目前所在節點位置找出節點所屬的課程名稱
mylist = []
for parent in p.self_and_parents_iter():
    mylist.append(parent.h)
# 倒數第 2 個就是課程名稱
課程名稱 = mylist[-2]
g.es("將要上傳的課程名稱:"+課程名稱)
g.es()
網誌內容 = ""
for p in p.self_and_subtree():
    # p.b 為目前所在節點的內文 (body text)
    網誌內容 += p.b
    #g.es(p.b)
'''
g.es("課程內容如下:")
g.es()
g.es(網誌內容)
'''
''' 因為 Leo 中的 rst 節點都是採用 Sphinx 語法與延伸程式, 因此無法僅透過 docutils 將 rst 節點內容轉為 html, 而必須設法利用 Sphinx 處理
'''
# 利用 docutils.core 模組中的 publish_string() 方法, 將 rst 內容轉為 html
超文件內容 = publish_string(
        source=網誌內容,
        writer_name='html',
        settings = None,
        settings_overrides={'output_encoding': 'unicode'}
    )
g.es(超文件內容)</t>
<t tx="amd_yen.20130314194325.1514">@language python
# 此一按鈕的用法為選擇節點然後按下上方的 generate-current button
# 希望能將此 button 改寫為局部產生 html 與 pdf
import os
# 位置為目前所選的節點
pos = c.p
# 將 commander 指定在目前所選的節點位置
c.selectPosition(pos)
# 針對節點位置執行 rst3 指令, 將內容轉為 rst 格式
c.k.simulateCommand('rst3')
# 接著將 rst 格式檔案轉為 html
&lt;&lt; html manual &gt;&gt;
# 將 rst 格式檔案轉為 pdf
&lt;&lt; pdf manual &gt;&gt;</t>
<t tx="amd_yen.20130314194325.1746"></t>
<t tx="amd_yen.20130317160119.1726"></t>
<t tx="amd_yen.20130318140025.2832"></t>
<t tx="amd_yen.20130318140025.2833">機械設計工程師所需要的程式語言

機械設計是一個資訊密集的遞廻流程:

    資訊密集 - 機械設計所做的每一個決策都會產生資料, 這些資料包括用來定義產品的規格, 以及訂定此規格的環境與緣由.
    
        產品規格 (specifications) - 包括產品性能、零組件尺寸、零組件材料、零組件加工流程、替代零組件等.
        
        訂定規格的環境 (environment) - 包括假設條件 (conditions and models)、如何 (how) 完成性能評估、如何取得優勢 (專利)、如何進行協同、如何管理等 (where, who, when, what).
        
        訂定規格的緣由 (reasons) - 包括產生各項資訊的前因與後果 (why).
    
    遞廻流程 - 重複因應問題、變更設計、期在產品生命週期流程中求取產品價值最大化.
    
因此程式語言就機械設計工程師運用電腦執行上述工作項目時, 期採最具效率的方式進行:
    
    以電腦管理資訊 - 文書處理、建立網站、登錄日誌
    
    以電腦評估規格 - 數值運算 (numerical)、科學運算 (science)、建立模型、執行工程設計分析
    
    以電腦建構環境 - 單機程式、網際程式、協同專案環境
    
    以電腦因應問題 - on demand 處理問題、以工作流程 (審批流程) 留下決策的細節資料
    
程式語言工作項目:
    
    程式語言基本概念
    
        會否採用程式方法進行數值運算、科學運算、資料處理 (程式語言(一)) - C1_intro
        
        會否採用程式方法建立單機程式  (程式語言(二)) - C2_app (採用 tkinter 與 PyQt GUI 介面)
        
        會否採用程式方法建立網際程式  (程式語言(一)) - C1_web (採用 CherryPy, bottle 與 django 網際框架)
        
    會否採用程式方法進行文書處理 (程式語言(二)) - C2_leo
    
    會否採用程式方法建立網站、登錄日誌  (程式語言(一)) - C1_cms
    
    會否採用程式方法搭建協同專案環境 (程式語言(二)) - C2_web, C2_cd

程式語言課程規劃內容

C1_intro - 基本程式語法, 程式數值運算與資料處理

C1_cms - 網際內容管理, CMSimple XH

C1_web - 網際程式框架, CherryPy

C2_leo - 文書處理, docutils, Sphinx, Leo Editor, MikTeX

C2_app - 應用程式, tkinter 與 PyQt

C2_web - 網際程式框架, CherryPy, bottle 與 django

C2_cd - 網際協同, c9.io, 免費虛擬主機 (http://www.1freehosting.com/) , Simple Groupware</t>
<t tx="amd_yen.20130406103207.2286">@language python
import os
d = c.scanAllDirectives(p)
# 將目錄指到 wcm
mandir = d.get('path') + "/wcm"
g.es(mandir)
os.chdir(mandir)
# 建立 mysite 專案
project_name = "mysite"
os.system("python V:/IDE/Python33/Scripts/django-admin.py startproject "+project_name)</t>
<t tx="amd_yen.20130406103207.2287">@language python
import os
d = c.scanAllDirectives(p)
# 將目錄指到 wcm
mandir = d.get('path') + "/wcm"
g.es(mandir)
os.chdir(mandir)
# 建立 mysite 專案
project_name = "mysite"
os.chdir(project_name)
os.system("python manage.py startapp polls")
#os.system("python manage.py runserver")
</t>
<t tx="amd_yen.20130406103207.2434">@language python
# 將管理者密碼設為 admin/admin
import os
d = c.scanAllDirectives(p)
# 將目錄指到 wcm
mandir = d.get('path') + "/wcm"
g.es(mandir)
os.chdir(mandir)
# 建立 mysite 專案
project_name = "mysite"
os.chdir(project_name)
os.system("python manage.py syncdb")</t>
<t tx="amd_yen.20130406103207.2437">@language python
import os
d = c.scanAllDirectives(p)
# 將目錄指到 wcm
mandir = d.get('path') + "/wcm"
g.es(mandir)
os.chdir(mandir)
# 建立 mysite 專案
project_name = "mysite"
os.chdir(project_name)
os.system("python manage.py sql polls")</t>
<t tx="amd_yen.20130406103207.2438"></t>
<t tx="amd_yen.20130406103207.2439">https://docs.djangoproject.com/en/1.5/intro/tutorial02/</t>
<t tx="amd_yen.20130406103207.2441">python manage.py runserver 127.0.0.1:8090

在 Leo 中啟動 django 與 關閉 django 的流程, 可以套用類似 pyforum exiting 的方式:

'''
# 退出函式
def exiting(self):
    print("系統即將退出!")
    print("所要終止的 PID 為:"+ str(os.getpid()))
    # 必須要使用 /F forced mode 與 /T tree mode 才能真正 kill pyforum.py 對應的 process
    os.system("taskkill /F /T /PID "+str(os.getpid()))
exiting.exposed = True
'''</t>
<t tx="amd_yen.20130406103207.2442">https://docs.djangoproject.com/en/1.5/intro/tutorial01/</t>
<t tx="amd_yen.20130406103207.2760">C Pointer and Array

註: 以下相關內容僅提供參考, 這裡不保證所提供的中英文內容, 絕對正確或完整, 使用者必須自行擔負各種可能衍生之風險與結果.

C 的介紹 -

http://en.wikiversity.org/wiki/Topic:C

http://www.eskimo.com/~scs/cclass/cclass.html

Learning GNU C

A TUTORIAL ON POINTERS AND ARRAYS IN C

C 程式語言的指標與陣列教學

pointers.pdf

作者: Ted Jensen

Version 0.1

This material is hereby placed in the public domain.
本教材謹置於公共領域

TABLE OF CONTENTS
目錄

Preface
前言

Introduction
簡介

Chapter 1: What is a Pointer?
第一章: 何謂指標?

Chapter 2: Pointer Types and Arrays.
第二章: 指標類別與陣列

Chapter 3:  Pointers and Strings
第三章: 指標與字串

Chapter 4:  More on Strings
第四章: 更多關於字串

Chapter 5:  Pointers and Structures
第五章: 指標與結構

Chapter 6:  More on Strings and Arrays of Strings
第六章: 更多關於字串與字串陣列

Chapter 7:  More on Multi-Dimensional Arrays
第七章: 更多關於多維陣列

Chapter 8:  Pointers to Arrays
第八章: 指向陣列的指標

Chapter 9:  Pointers and Dynamic Allocation of Memory
第九章: 指標與動態記憶配置

Chapter 10: Pointers to Functions
第十章: 指向函式的指標

Epilog
結語</t>
<t tx="amd_yen.20130406103207.2761">PREFACE

前言

本文件旨在向 C 程式語言的初學者介紹指標. 過去幾年, 無論是在 FidoNet 與 UseNet 有關 C 的會議場合, 特別注意到有許多 C 程式語言的初學者, 似乎對於指標的基本用法, 感到有些困難. 因此特別利用較多的範例, 希望以淺顯的說明來解釋指標的用法.

這份文件的第一版本, 如同此一版本, 是被放在公共領域. 當時是由 Bob Stout 將資料放在 PTR-HELP.TXT 的文件檔中, 並納入 SNIPPETS 的收集中加以發行. 之後, 又在原始資料中增添了許多內容並且修正了一些錯誤.

致謝

要感謝許多不為人知的使用者, 將許多問題公佈在 FidoNet 的 C Echo 論壇中,  或是 UseNet comp.lang.c 新聞群組中, 或是在其他網路上的幾個會議區, 這些要感謝的人士可能無法一一列出. 其中特別要感謝 Bob Stout 肯將這份資料的第一版本放入他所收集的 SNIPPETS 檔案中.

關於作者:

Teb Jensen 是一位退休的電子工程師, 主要專注於電磁錄音領域中的硬體設計與管理職務. 程式則是自 1968 年以來閒暇時的興趣, 當時正學著如何以打卡的方式讓程式送給電腦主機執行. (那時的主機擁有 64 K 的磁心記憶體)

使用本資料:

這份資料以公共領域授權釋出. 任何人可以採用任何形式, 複製或散佈這份資料. 唯一的要求, 則是若這份資料被用於課程教學, 希望能夠完整呈現, 亦即, 包含所有章節, 包括前言與簡介. 

並且任課教師能夠利用下方的電子郵箱通知我一聲. 之所以如此要求, 主要是希望這份資料能夠對其他人有用, 況且我並不要求金錢回報. 只是希望能夠透過使用這份資料的用戶回饋, 多少確認一下這個目標能夠達成.

此外, 並非一定要是課程教學者可以寫信給我. 感謝任何覺得此份資料有用或提供建設性批評的任何人, 都能告訴我一聲, 我將會透過電子郵件回答相關問題.

Ted Jensen     tjensen@netcom.com
P.O. Box 324     1-415-365-8452
Redwood City, CA 94064
Dec. 1995</t>
<t tx="amd_yen.20130406103207.2762">INTRODUCTION

簡介

若您想要專精於利用 C 程式語言編寫程式碼, 就必須徹底了解如何使用指標. 然而, C 指標對初學者而言, 經常是一項障礙, 尤其對於從 Fortran, Pascal 或 Basic 程式語言轉進的學習者.

這份資料旨在幫助初學者了解指標. 為了能讓這份資料發揮最大功能, 使用者最好能夠實際執行文章中所列出的各個程式. 因此所有的程式碼都採 ANSI 標準, 以便讓任何符合 ANSI 標準的編譯器都能執行這些程式碼. 內文與程式碼之間, 也特別加以區分開來, 以便使用者可以直接利用複製的方式, 取的各段落的程式碼, 套用到其他系統中進行編譯. 如此才能確實了解這裡所提供的資料.</t>
<t tx="amd_yen.20130406103207.2763">Chapter 1: What is a Pointer?

第一章: 何謂指標?

C 語言初學者必須面對的難題之一, 就是指標的用法.

這份教材的目的, 就是針對初學者簡介指標及其應用.

其實初學者會對指標產生疑惑, 大多源自於在學習 C 語言時, 對於變數的概念經常一知半解.

因此這裡就由 C 變數的一般用法說起.

程式中的變數都必須加以命名, 以便存放數值.

而編譯器與連結器在處理變數時, 就會挪出電腦記憶體中的特定區域, 以存放變數的值

這些特定區域的大小, 取決於變數允許存放值的範圍.

例如, 在 32 位元電腦, 一個整數變數的存放範圍, 需要為 4 位元. 而在舊的 16 位元電腦, 整數存放需要 2 位元.

C 程式中的整數變數存放範圍大小, 在各種機器上不一定相同.

並且 C 程式中的整數變數也不只一種, 在許多 C 程式教科數中,可以發現有整數, 長整數, 短整數等. 這裡則假設使用 32 位元系統, 因此整數需要 4 位元的存放空間.

可以採用下列程式碼,在您所使用的系統中, 查探特定整數型別所需要的記憶體空間:

// ch1_1.c 程式, 用來查詢電腦整數型別所佔的記憶體空間

#include &lt;stdio.h&gt;

int main()
{
    printf("size of a short is %d\n", sizeof(short));
    printf("size of a int is %d\n", sizeof(int));
    printf("size of a long is %d\n", sizeof(long));
}

(在 C 程式中) 當我們宣告一個變數時, 亦即告知編譯器兩件事, 變數名稱與變數型別. 例如, 可以透過

    int k; 

宣告名稱為 k 的整數型別變數. 當編譯器看到 "int" 的敘述值, 就會在電腦的記憶體中, 保留 4 位元的空間, 以便存放整數變數 k 的值.

此外, 電腦也會設置一個符號表, 註明符號 k 與其在記憶體中用來存放 4 位元資料的相對位址.

因此, 若在變數宣告後, 使用

    k = 2; 

2 這個數值, 就會在程式執行時, 被放在保留給 k 變數的記憶體位址中.

在 C 語言中, 整數 k 變數, 可視為一個物件. 其中有兩個值與物件 k 有關, 也就是存放的數值與存放的位址. 有些參考書中將者兩個數值稱為"右值"與"左值". (2 為右值, 而變數位址為左值)

在某些語言中, 左值只能放在指定"等號"的左邊, 而右值則只能放在右邊. 位置放錯, 例如: 2 = k, 就會出錯.

其實, C 語言中有關左值得定義, 根據 K&amp;R II (page 197): [1], 則有些變動.

"物件為儲存區域的名稱, 而左值則為指向該物件的表示式."

這裡先採引用的定義加以說明, 後續將會進一步針對指標加以說明.

接著, 假如程式碼為:

   int j, k; 

    k = 2; 
    j = 7;    &lt;-- line 1 
    k = j;    &lt;-- line 2 

編譯器會將第一行 (line 1) 的 j 解讀為變數 j 的位址 (也就是左值), 並且將值 7 放到該位址. 在第二行 (line 2), 則會將 j 視為右值 (因為在"指定"運算子的右方), 指的則是存放在 j 記憶體中的 7 這個數值. 因此第二行執行過後, 存放在 j 的 7 這個數值, 就會被放到 k 變數所對應的"左值" (記憶體位址) 中.

在這些範例中, 採用的都是將右值從一個儲存位址, 經由複製將 4 位元的資料複製到另外一個儲存位址. 假如使用 2 位元整數, 則會複製 2 位元資料.

這裡, 就會需要一種變數, 用來存放左值 (記憶體位址). 存放此一變數的值, 隨系統而異, 舊的桌上電腦總共只有 64K 的記憶體, 每存放一個整數位址會佔去 2 位元.

更多位元數的電腦 (例如 64 位元電腦), 則需要更多的位元位址來存放一個整數資料.

實際需要的記憶體大小並不重要, 需要的則是一種方法, 通知編譯器在哪一位址存放哪些資料.

這樣的變數稱為"指標變數" (隨後將說明得更清楚). 在 C 語言中定義指標變數時, 必須在變數名稱前方, 加上一個 * 符號. 而這些指標變數的型別, 隨著要存放在指標位址中的資料型別而定, 例如, 假如宣告:

   int *ptr;

ptr 為變數名稱 (與之前的整數變數名稱 k 相同). 而 "*" 符號則告知編譯器, 此一宣告為指標變數, 亦即保留出足夠的記憶體存放位址. 最前方的 int 則表示, 希望此一指標變數用來存放整數. 而此一指標稱為"指向整數". 需要特別注意的是, 當使用 int k; 時並沒有給 k 初始值, 只有在任何符合 ANSI 規範的編譯器中, 會將宣告在函式外的變數通通以 0 初始.

同樣地, ptr 也沒有初始值, 亦即, 還沒有在上述宣告之後, 在保留的位址空間上, 放入任何值. 這裡若宣告是在任何函式之外, 就會被賦予初值, 並且保證不會指向任何 C 物件或函式. 以這種方式初始的指標, 被稱為 "空"指標 (null pointer).

而空指標並不一定會被放入 "0" 值, 因為這取決於特定系統中的設定. 為了在不同系統中的不同編譯器彼此相容, 就會利用巨集 (macro) 來表示空指標. 此巨集以 NULL 命名. 因此, 若以 NULL 設定指標值, 則可以確定在不同機器上, 這些指標變數一定是空指標.

與整數是否為 0 的判斷式 if(k ==0) 相類似, 可以利用 if(ptr == NULL) 判斷是否 ptr 為空指標.

但是, 回到新變數 ptr 的應用, 假設要將整數變數 k 所對應的位址, 存入 ptr, 就必須使用"位址運算子", 寫成:

    ptr = &amp;k; 

"位址運算子"的作用是用來取 k 的左值 (位址), 即使這時 k 位於等號右邊, 上述程式會將 k 的值複製到指標 ptr 的儲存空間中. 這時, ptr 稱為"指向" k.

接著再討論另外一個運算子.

也就是所謂的"取值運算子" (dereferencing operator), 就是一個 * 符號. 使用方法如下:

    *ptr = 7; 

這行程式會將 7 這個數值,複製到 ptr 變數所指向的位址. 也就是說, 假如 ptr 指向 k (ptr 為 k 存放資料的記憶體位址), 這行程式就會將 k 的值設為 7. 換言之, * 運算子可用來改變 ptr 所指向的值, 而不是指標本身的值. (註:指標本身為位址, 也就是所謂的左變數)

因此, 可以利用:

 printf("%d\n",*ptr); 

將目前存放在 ptr 所指向位址的整數值, 給印到螢幕.

要釐清上述說明, 可以執行下列程式, 並仔細探討程式碼與其輸出.

------------ Program 1.1 --------------------------------- 

/* Program 1.1 from PTRTUT10.TXT   6/10/97 */

#include &lt;stdio.h&gt;

int j, k;
int *ptr;

int main(void)
{
    j = 1;
    k = 2;
    ptr = &amp;k;
    printf("\n");
    printf("j has the value %d and is stored at %p\n", j, (void *)&amp;j);
    printf("k has the value %d and is stored at %p\n", k, (void *)&amp;k);
    printf("ptr has the value %p and is stored at %p\n", ptr, (void *)&amp;ptr);
    printf("The value of the integer pointed to by ptr is %d\n", *ptr);

    return 0;
}

請注意: 我們還沒有談到 C 程式中的 (void *) 表示式. 這裡可以先納入您的測試程式碼中,  隨後將會加以說明.

結論:

    1. 變數宣告必須指定名稱與型別. (例如: int k;)
    
    2. 指標變數宣告也是指定名稱與型別. (例如: int *ptr;), 其中的 * 告知編譯器, 該名稱為 ptr 的變數, 為一個指標變數, 而其型別為該指標指向的資料型別 (這裡為整數).
    
    3.  一旦變數已經宣告, 可以透過變數前方的位址運算子, 取得其位址, 例如 &amp;k.
    
    4. 可以由指標中"取值", 亦即, 以 * 指定到指標所參照的值, 例如: *ptr.
    
    5. 變數的左值為被用來存放在記憶體中的位址值, 而變數的右值則式被存放在該位址的數值.

參考資料:

"The C Programming Language" 2nd Edition
B. Kernighan and D. Ritchie
Prentice Hall
ISBN 0-13-110362-8 </t>
<t tx="amd_yen.20130406103207.2764">Chapter 2: Pointer Types and Arrays.

第二章: 指標型別與陣列

接著讓我們來看看, 為何需要指定指標指向變數的型別, 例如:

int *ptr;

原因之一是, 宣告之後, 可以透過指向, 寫成:

*ptr = 2;

編譯器就會知道要配置多少記憶體給 ptr 變數, 假如 ptr 宣告為指向整數, 電腦就會複製 4 位元的資料, 其它的浮點與雙浮點變數也是相同. 定義指向變數型別的另外一個用途就是編譯器可以解譯程式碼. 例如, 記憶區中存放 10 個連續的整數資料時, 需要 40 位元的記憶體.

假如整數指標 ptr 為這些整數中的第一個變數, 若該整數位於記憶體位址 100. 當程式寫為:

ptr + 1;

因為編譯器知道 ptr 為一個指標變數 (亦即, 其值為一組位址)並且指向某一整數 (目前位址為 100, 即是該整數所在位址), 當 ptr 加上 4 而不是 1 之後, 該指標將會指向下一個整數, 也就是記憶體 104. 

相同的概念下, 若 ptr 指向短整數, 則應該加上 2  而不是 1. 對於浮點, 雙浮點或使用者自訂的資料型別 - 結構, 也是類似.

儘管這並非我們常見的"加法", 但是在 C 語言中, 可以透過指標算數進行"加法"運算, 隨後將會再予以說明.

同理, 因為 ++ptr 與 ptr++ 與 ptr + 1 等同 (儘管 ptr 增量的時機點並不一樣).

讓指標以 ++ 增量運算子進行增量, 無論是先加或後加, 由 sizeof(type) 中所得到的位址增量, 其型別均為該物件指向變數的型別 (整數為 4 位元).

由於這 10 個整數位於記憶體中連續區塊上, 指標可以被用於整數資料陣列的處理.

例如:

    int my_array[] = {1, 23, 17, 4, -5, 100}; 

陣列中帶有 6 個整數. 可以透過 my_array 的索引代表這些整數. 亦即利用 my_array[0] 到 my_array[5] 加以表示, 也可以透過指標加以表示成:

    int *ptr;
    
    ptr = &amp;my_array[0];       /* 將指標指向陣列中的第一個整數*/ 

接著就可以使用陣列索引或取值運算, 列出陣列.

下列程式可以用來展示此一應用:

-----------  Program 2.1  -----------------------------------

/* Program 2.1 from PTRTUT10.HTM   6/13/97 */

#include &lt;stdio.h&gt;

int my_array[] = {1, 23, 17, 4, -5, 100};

int *ptr;

int main(void)
{
    int i;
    ptr = &amp;my_array[0];     /* point our pointer to the first
                                      element of the array */
    printf("\n\n");
    for (i = 0; i &lt; 6; i++)
    {
      printf("my_array[%d] = %d   ",i,my_array[i]);   /*&lt;-- A */
      printf("ptr + %d = %d\n",i, *(ptr + i));        /*&lt;-- B */
    }
    return 0;
}

編譯執行上列程式就可以仔細觀察 A 行與 B 行程式分別採用兩種方法列出陣列中的同一內容.

也可以清楚看到 B 行程式如何應用"取值"運算, 亦即, 首先在指標增量後, 在新的指標中取值. 將 B 行程式改為

    printf("ptr + %d = %d\n",i, *ptr++);

之後再執行, 接著改為:

    printf("ptr + %d = %d\n",i, *(++ptr));

再執行, 執行之前先判定結果, 並與實際執行結果進行比較.

在 C 語言, 可以利用 var_name 來替代 &amp;var_name[0], 因此在程式碼中寫成:

    ptr = &amp;my_array[0];

或:

    ptr = my_array;

都會得到相同的結果.

因此許多參考書都寫道: 陣列的變數名稱就是指標. 但是比較好的想法則是: 陣列的變數名稱就是陣列中第一元件的位址. 許多初學者 (包含作者本人), 都會將其視為指標.

但是, 可以寫成:

ptr = my_array;

但是卻不能寫成:

my_array = ptr;

原因就是 ptr 為變數, 但是 my_array 卻是常數, 也就是說, my_array 第一元件的位址, 一旦在 my_array[] 完成宣告後, 就不可以改變.

先前曾討論的左值, 中引用 K&amp;R-2 中所言:

"物件為儲存區域的名稱, 而左值則為指向該物件的表示式."

這就衍生出一個有趣的議題. 因為 my_array 為儲存區域的代表名稱, 為何 my_array 在上面的指定敘述程式中, 卻不能用在左值區域?

為了說明這點, 可以將 my_array 視為"不可改變的左值".

上列範例可以將:

    ptr = &amp;my_array[0];

改為:

    ptr = my_array;

確認兩者會得到相同的結果.

至於 ptr 與 my_array 之間的差異, 有人將陣列變數名稱視為"常數指標".
為了充分了解所謂"常數"的真諦, 重回變數定義時的說明.

當變數宣告時, 用來存值的記憶體就必須加以配置. 這時變數可以透過兩個層面來看.

用在指定運算左邊時, 編譯器會視其為記憶位址, 用來指向右側所設定的值.

若被用在運算右邊時, 變數名稱會被解讀為存在該記憶體中的值.

有了以上的概念, 關注簡單的常數運算:

    int i, k;
    i = 2;

其中 i 為存放 2 常數的變數, 並非直接在資料記憶區塊中指定, 而是直接存入程式記憶區塊. 

當 k = i; 程式碼就會到 &amp;i 位址中抓取要複製到 k 的值, 而 i = 2; 只是將 2 放入程式碼, 而沒有取值的運作. 也就是說, k 與 i 都是物件, 但是 2 則非物件.

同理, 由於 my_array 為常數 (為位址值), 一旦編譯器設好用來存值得區域後, my_array[0] 存值得記憶體位址就已經確定, 因此可以使用:

    ptr = my_array;

將此在程式區段中的常數位址設給 ptr, 其中並沒有牽涉到資料區段的取值操作.

這時就可進一步說明第一章程式 1.1. 中 (void *) 的應用. 由於指標可被用來指向各種資料型別. 除了可以指向整數, 也可以指向字元, 之後還會介紹指向結構與指向指標的指標變數.

由於在不同系統中的指標儲值大小會有差別, 並且指標的記憶體空間會隨著指向物件資料型別差異而有所不同.

因此若將長整數指給短整數資料型別變數時, 就會發生問題, 也可以將某一型別的指標變數指定給其他不同型別指標變數時, 產生問題.

為了克服此一問題, C 語言提供 void 這個空的指標資料型別.

假如將某一指標設定為:

void *vptr;

空指標可以視為通用指標. 由於 C 語言不允許整數型別指標與字元型別指標之間的資料交換或比較. 這時就可以透過空指標作為中介, 在特殊情況下在指標型別間進行資料轉換.

在第一章的 1.1 程式中, 就是使用空指標將整數指標轉成能與 %p 資料相符的格式.

下列各章, 也將透過此一概念進行資料轉換.

這裡列出許多技術資料給初學者, 首次閱讀時或許不很容易理解. 因此需要前後執行幾次程式, 看看結果, 並且仔細查驗這兩個例子中的程式碼與產出結果, 才會有所突破.

接下來, 將討論指標, 字元陣列與字串間的關係.</t>
<t tx="amd_yen.20130406103207.2765">Chapter 3: Pointers and Strings

第三章: 指標與字串

字串的研究不僅對進一步理解指標與陣列的關聯有些幫助,也能用來彰顯某些標準 C 字串函數的使用. 最後也可以理解指標如何將資料傳給函式.

就 C 而言, 字串為字元所組成的陣列, 其他的語言則未必如此.

無論是 BASIC, Pascal 或是 Fortran 與其他幾種程式語言, 字串自有其資料類別.  C 則不然, 字串之於 C 被表為以 0 位元 (寫為'\0').

這裡要以幾行程式碼作為開端, 來加以說明, 如下:

    char my_string[40];

    my_string[0] = 'T';
    my_string[1] = 'e';
    my_string[2] = 'd':
    my_string[3] = '\0';

或許沒有人會用這種方法來建立字串, 以空字元作為結尾. 根據 C 語言的定義, 字串為一組以空字元結尾的字元陣列. 注意這裡的所謂空字元與 "NULL" 不同. 空字元表為以跳脫序 '\0' 表示的"零"字元. 亦即佔了記憶體中的一個位元, 而 NULL 則為用來起始空指標的巨組程式.

NULL 在 C 編譯器中, 以 #define 在標頭檔案中宣告, 而 nul 則完全無法以 #define 宣告.

由於用上述程式來宣告字串非常累人, 因此 C 允許以多種方法來完成一項工作.

首先, 可以寫成

    char my_string[40] = {'T', 'e', 'd', '\0',};    

但是光打字就有些不方便, 因此也可以寫成:

    char my_string[40] = "Ted";

若使用的是雙引號, 而不是先前的單引號, 空字元 ('\0') 會自動被加在字串最後面.

上面的例子, 結果都相同. 編譯器會保留連續的 40 位元區塊來存放 Ted\0 這四個字元.

接著看看下列程式:

------------------program 3.1-------------------------------------

/* Program 3.1 from PTRTUT10.HTM   6/13/97 */

#include &lt;stdio.h&gt;

char strA[80] = "A string to be used for demonstration purposes";
char strB[80];

int main(void)
{

    char *pA;     /* 字元型別的指標變數*/
    char *pB;     /* 另一個字元型別的指標變數 */
    puts(strA);   /* 顯示字串 A */
    pA = strA;    /* 將 pA 指向字串 A*/
    puts(pA);     /* 顯示 pA 指向的內容 */
    pB = strB;    /* 將 pB 指向字串 B */
    putchar('\n');       /* 在螢幕中向下移動一行 */
    while(*pA != '\0')   /* A 行 (詳見內文說明) */
    {
        *pB++ = *pA++;   /* B 行 (詳見內文說明) */
    }
    *pB = '\0';          /* C 行 (詳見內文說明) */
    puts(strB);          /* 將 strB 顯示在螢幕上 */
    return 0;
}

--------- end program 3.1 -------------------------------------

上述程式定義了兩個字元陣列, 各有 80 字元. 由於屬於全域變數, 一開始各字元都填入 '\0'. 然後, strA 前 42 個字元被放入所引用的字串內容.

接著的程式碼, 宣告兩個字元指標並將其字串顯示在螢幕. 將 pA 指標指向 strA, 也就是附註 strA[0] 的位址給變數 pA. 然後利用 puts() 函數顯示 pA 所指向的內容
 puts() 函式的宣告為:

    int puts(const char *s); 

現在先不用管 const, 傳給 puts() 函數的變數為指標. 其實是指標所對應的值. 而指標的值為其所指向的位址. 因此寫成 puts(strA), 表示輸入變數為 strA[0] 的位址.

同理, 當程式寫 puts(pA); 也是以相同的位址當作輸入, 因為已經透過

pA = strA;

將位址傳給 pA

因此程式執行到 while() 指令中的 A 行時, A 行內容為:

當 pA 所指向的字元並非 nul 字元時 (也就是'\0'), 執行其內容:

而 B 行程式則表示: 將 pA 指向的字元複製給 pB 所指向的字元, 接著增量 pA 後可以指向下一字元, 而 pB 則會指向下一個記憶體空間.

完成最後一個字元複製後, pA 會指向空字元, 也會終止迴圈的執行.

其中空字元並沒有複製, 但由於 C 中的字串一定要以空字元結尾, 所以在 C 行程式中再補上空字元.

執行此一程式時, 當使用者透過除錯器看著 strA, strB, pA 與 pB 一步步執行, 將非常具有教育意義.

更有意思的是, 若不將 strB[] 按上述方法定義時, 而是將其起始值設為:

    strB[80] = "12345678901234567890123456789012345678901234567890"

讓其數字個數大於 strA  的長度, 然後一步步看著這些變數設定數值. 大家一定得親自做做看.

接著再回到 puts() 的原型, 運用 "const" 作為某一參數的宣告飾詞時, 主要在告訴使用者, 該函式無法改變其由 s 所指向的字串值, 意即, 程式會將該字串視為常數.

誠然, 上述程式展示了複製字串的一種簡單方式. 一旦確實了解上述程式的用法, 接著將自行編寫可以取代標準 strcpy() 的 C 標準函式, 程式如下:

   char *my_strcpy(char *destination, char *source)
   {
       char *p = destination;
       while (*source != '\0')
       {
           *p++ = *source++;
       }
       *p = '\0';
       return destination;
   }   

在此一程式中, 同樣運用了指標的傳值.

承上述內容, 若將函式寫成可以接受兩個字元指標變數輸入, 也就是位址, 就可以將上述程式改寫為:

    int main(void)
    {
        my_strcpy(strB, strA);
        puts(strB);
    }    

雖然與標準 C 的用法有些不同, 採用了下列原型定義:

    char *my_strcpy(char *destination, const char *source);  

之所以使用 "const" 飾詞, 主要在確定該函式無法變更指向來源指標的數值. 此點可從上述函式的修改得到印證, 其原型變數, 如 "const" 飾詞所示. 接著在函式中, 增加一行試圖更改該變數由來源指標所指向的值, 意即:

    *source = 'X';

試著將該字串的第一個字元, 變更為 X. 前面的 const 飾詞就會讓這一行程式產生錯誤, 執行完後就會更加清楚有關 const 變數的使用.

接著, 繼續探討上述程式的內涵, 第一步, 將 *ptr++ 解讀為由 ptr 指標傳回值後的增量. 主要與運算子的次序有關. 假如寫成 (*ptr)++, 表示增量的部分,  並非指標, 而是該指標所指向值的增量. 也就是說, 在上述程式中, 若對第一個字元 'T' 增量, 其值就會變成 'U'. 使用者可以自行寫程式來印證此一結果.

由於字串只不過就是字元所組合而成的陣列, 並在最後一個字元補上 '\0'.  上面所進行的是用來複製陣列. 這些字元陣列的運算技巧, 也可以應用到整數陣列或浮點數陣列. 但是在這些應用中, 陣列的尾端, 並不會補上 nul 字元, 而可以放進某特定值的內容, 來表示其為終點. 例如, 可以在複製正整數時, 在尾數放入一個負值的整數來標示終點. 或者, 寫一個函式, 可以複製字串以外的陣列及其陣列位址, 就如同下列原型所示:

    void int_copy(int *ptrA, int *ptrB, int nbr);

其中 nbr 為要進行複製的整數值. 試著寫一個可以用來複製整數陣列的 int_copy() 函式, 看看是否能夠正常運作.

如此, 就可以使用函式來處理大陣列. 例如, 有一帶有 5000 個整數的陣列需要處理, 只要將該陣列的位址輸入該函式 (視情形,  可以加上其他相關變數, 如上述程式中的 nbr 變數), 而不需要輸入陣列本身, 意即, 整個陣列值並沒有在堆疊中複製後進行輸入的動作, 而只送出其位址.

此一過程與輸入某一整數給某一函式不同. 輸入整數時, 必須複製該整數, 也就是取得該整數的值, 然後放入某一堆疊當中. 這時, 該函式的處理並不影響原始的整數值, 而若以陣列及指標進行處理, 可以將變數位址輸入, 直接處理原始變數的值.</t>
<t tx="amd_yen.20130406103207.2766">Chapter 4: More on Strings

第四章: 更多關於字串的用法

好的, 在短短的時間裏, 已經介紹了不少東西! 接著再看一次第三章中有關字串複製的部分, 但是採不同的方法. 以下列函式來看:

    char *my_strcpy(char dest[], char source[])
    {
        int i = 0;
        while (source[i] != '\0')
        {
            dest[i] = source[i];
            i++;
        }
        dest[i] = '\0';
        return dest;
    }

之前曾說過, 字串就是字元所組成的陣列. 這裡我們利用陣列表示而非指標表示, 來進行資料的實質複製. 結果會與之前相同, 亦即, 採此一方法的字串複製, 其結果依然正確. 這也衍生出接下來要討論的有趣論點.

由於變數透過值進行傳遞, 可經由前述之字元指標或陣列名稱進行, 其間真正傳遞的則是每一陣列中第一個元素的位址. 亦即, 變數數值的傳遞, 可透過字元指標或陣列名稱來代表此一變數. 也可以說, source[i] 其實與 *(p+i) 的用法一樣.

事實上, 這是正確的, 亦即 a[i] 可以利用 *(a+i) 來替代, 而不會產生任何問題. 換言之, 編譯器針對這兩種情形, 會產生相同的編碼. 因此, 指標算術其實與陣列索引編碼相同. 兩種語法會產生相同結果.

但是這並非說, 指標與陣列是相同的東西, 其實不然. 這裡只是說, 利用陣列來進行特定元素辨識, 可以採用兩種不同的語法, 其一為採用陣列索引, 而另一種方法則是利用指標算術, 會得到相同的結果.

接著, 注意最後的表示式, (a+i) 的部分利用簡單的加號 + 與 C 的語法, 表示式子可以交換, 亦即 (a+i) 與 (i+a) 完全相同. 因此可以將 *(i+a) 簡化為 *(a+i).

但是 *(i+a) 可能來自 i[a]! 綜合上述, 或許會懷疑若:

    char a[20];
    int i;

寫成

    a[3] = 'x';

其實與下列表示式, 其實是一樣的.

    3[a] = 'x';

試試看! 設定一個字元陣列, 內存為整數或長整數等. 對其第三或第四元素, 以傳統方式, 給定特殊值, 接著將值印出加以確認. 然後如前述, 將陣列表示式反轉過來, 一個好編譯器將會毫無疑問的給出相同的結果, 僅只出於好奇, 別無其他用意.

程式範例:

#include &lt;stdio.h&gt;

// 每一個 C 程式都必須要有一個小寫的 main()函式
int main()
{
    // 陣列與指標的應用
    char a[20];
    int i;
    a[3] = 'x';
    printf("%c\n",a[3]);
    printf("%c\n",3[a]);
    printf("%c\n",*(a+3));
    printf("%c\n",*(3+a));
    return 0;
}

接著, 來看前面給的函數, 寫成:

    dest[i] = source[i];

由於已知陣列索引與指標算術會得到相同的結果, 因此也可以寫成:

    *(dest + i) = *(source + i);

但是, 需要對每一個值分別加上 i. 加法, 一般而言, 會比索引增量 (例如採用 ++ 運算符號的 i++) 耗費更多時間. 或許對現在最佳化的編譯器來說, 不一定就是如此, 但是採用指標通常比陣列索引來得快些.

另一個可以加速指標運算的方法, 將:

    while (*source != '\0')

簡化為

    while (*source)

兩種情形都會讓括號中為零 (FALSE).

這裡可實驗看看, 以指標的方法來寫程式. 用來處理字串應該不錯. 可以將下列標準函式改寫成自己的版本:

    strlen();
    strcat();
    strchr();

或者其他在系統中的函式.

接下來的章節, 還會再探討字串及其處理. 接下來先討論一下 structures (結構).</t>
<t tx="amd_yen.20130406103207.2767">Chapter 5: Pointers and Structures

第五章: 指標與結構

也許你已經知道, 可以利用結構的形式來宣告帶有不同資料型別的資料區塊. 例如, 人事檔案可能包含下列結構:

    struct tag {
        char lname[20];        /* 姓 */
        char fname[20];        /* 名 */
        int age;               /* 年齡 */
        float rate;            /* 例如: 每小時 100 元 */
    };
假如在磁片檔案中有許多這樣的資料, 當我們需要一筆筆讀出, 並且分別列出姓名, 以做成資料表格. 其他資料並不需要印出. 具體做法, 可以利用函式呼叫, 透過指向結構的指標作為輸入, 就可以完成處理. 這裡只利用一個結構進行示範, 並且主要在編寫函式, 而非讀檔. 這裡已經假設您知道如何進行讀檔.

複習一下, 我們可以利用點運算子來擷取結構成員, 正如:

--------------- 程式 5.1 ------------------

/* 程式 5.1 from PTRTUT10.HTM     6/13/97 */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
struct tag {
    char lname[20];      /* 姓 */
    char fname[20];      /* 名 */
    int age;             /* 年齡 */
    float rate;          /* 例如: 每小時 100 元 */
};
struct tag my_struct;       /* 宣告 my_struct　結構 */
int main(void)
{
    strcpy(my_struct.lname,"Jensen");
    strcpy(my_struct.fname,"Ted");
    printf("\n%s ",my_struct.fname);
    printf("%s\n",my_struct.lname);
    return 0;
}

-------------- 結束程式 5.1 --------------

或許這裏所使用的結構與一般 C 程式所使用的相比還要小, 為了驗證也可以加入:

    date_of_hire;                  (未顯示資料型別)
    date_of_last_raise;
    last_percent_increase;
    emergency_phone;
    medical_plan;
    Social_S_Nbr;
    等等.....
    
假如員工的數量眾多, 應該會採用函式進行資料處理. 例如, 將結構輸入該函式, 就能利用函式印出員工姓名. 但是在最原始的 C (Kernighan &amp; Ritchie, 第一版), 無法輸入結構, 只能輸入指向結構的指標. 在 ANSI C 中, 已經允許利用結構作為函式輸入. 而這裡為了進行更多有關指標的學習, 並不直接採用結構.

總之, 假如輸入整個結構, 就如同必須在函式呼叫時複製結構內容, 在仍然使用堆疊的系統中, 就等同將整個結構資料送入堆疊中. 針對大型結構時,  可能就會造成問題. 若能只輸入指標, 就可使用最少的堆疊空間.

因此這裡主要在談指標, 因此接著來看如何將指向結構的指標變數輸入函式當中.

以上面的情況為例, 建立一個能夠接受指標變數 (指向結構) 的函式, 其中我們只想要擷取該結構的部分成員. 例如, 只要印出範例結構中的人員姓名.

好, 先前我們已經知道如何宣告指向結構的指標變數 tag. 接著就可以利用 tag 結構, 來宣告指標變數:

    struct tag *st_ptr;
    
並且可以用來指向範例中的結構:

    st_ptr = &amp;my_struct;
    
接下來, 可以利用指標的分割參照, 來指定特定成員. 但是應該如何利用指標的分割參照來指向結構? 假如要利用指標來設定人員的年紀, 可以寫成:

    (*st_ptr).age = 63;
    
仔細看清楚. 此一設定表示, 若將括號中 st_ptr 所指向的內容換成 my_struct, 就會與my_struct.age 相同.

但是, 這樣經常會被用到的表示式, 就被設定為與下列表示式涵義相同:

    st_ptr-&gt;age = 63;
    
了解了之後, 參考下列程式:

------------ 程式 5.2 ---------------------

/* 程式 5.2 from PTRTUT10.HTM   6/13/97 */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
struct tag{                     /* 結構型別 */
    char lname[20];             /* 姓 */
    char fname[20];             /* 名 */
    int age;                    /* 年齡 */
    float rate;                 /* 例如: 每小時 100 元 */
};
struct tag my_struct;           /* 結構定義 */
void show_name(struct tag *p);  /* 函式原型 */
int main(void)
{
    struct tag *st_ptr;         /* 指向結構的指標變數 */
    st_ptr = &amp;my_struct;        /* 將指標指向 my_struct */
    strcpy(my_struct.lname,"Jensen");
    strcpy(my_struct.fname,"Ted");
    printf("\n%s ",my_struct.fname);
    printf("%s\n",my_struct.lname);
    my_struct.age = 63;
    show_name(st_ptr);          /* 輸入該指標 */
    return 0;
}
void show_name(struct tag *p)
{
    printf("\n%s ", p-&gt;fname);  /* p 指向結構 */
    printf("%s ", p-&gt;lname);
    printf("%d\n", p-&gt;age);
}

-------------------- 結束程式 5.2 ----------------

這裡要了解不少東西. 讀者必須實際執行一下上面的程式, 並且利用除錯器一步步觀察  my_struct 與 p 在主函式執行流程中, 才能實際了解函式執行的內容.</t>
<t tx="amd_yen.20130408141041.1765">之前使用的 pybean 為 0.1.2, 採用 uuid 作為 id, 但是到了 0.2.1 作者放棄 uuid, 改用一般的 id, 而且截至 2013.04 pybean 仍以 Python 2 為主, 必須修改 .next() 為 next() 才可以在 Python 3 環境中正確執行.

將 pybean 0.1.2 轉為 pybean 0.2.1 必須針對程式修改, 將 uuid.bytes 改為 id

修改後的 0.2.1 pybean.py 程式碼如下:

#coding: utf-8
import sqlite3
from pkg_resources import parse_version

__version__ = "0.2.1"
__author__ = "Mickael Desfrenes"
__email__ = "desfrenes@gmail.com"

# Yen 2013.04.08, 將 Python2 的 .next() 改為 next(), 以便在 Python 3 中使用

class SQLiteWriter(object):

    """
    In frozen mode (the default), the writer will not alter db schema.
    Just add frozen=False to enable column creation (or just add False
    as second parameter):

    query_writer = SQLiteWriter(":memory:", False)
    """
    def __init__(self, db_path=":memory:", frozen=True):
        self.db = sqlite3.connect(db_path)
        self.db.isolation_level = None
        self.db.row_factory = sqlite3.Row
        self.frozen = frozen
        self.cursor = self.db.cursor()
        self.cursor.execute("PRAGMA foreign_keys=ON;")
        self.cursor.execute('PRAGMA encoding = "UTF-8";')
        self.cursor.execute('BEGIN;')
    def __del__(self):
        self.db.close()

    def replace(self, bean):
        keys = []
        values = []
        write_operation = "replace"
        if "id" not in bean.__dict__:
            write_operation = "insert"
            keys.append("id")
            values.append(None)
        self.__create_table(bean.__class__.__name__)
        columns = self.__get_columns(bean.__class__.__name__)
        for key in bean.__dict__:
            keys.append(key)
            if key not in columns:
                self.__create_column(bean.__class__.__name__, key,
                        type(bean.__dict__[key]))
            values.append(bean.__dict__[key])
        sql  = write_operation + " into " + bean.__class__.__name__ + "("
        sql += ",".join(keys) + ") values (" 
        sql += ",".join(["?" for i in keys])  +  ")"
        self.cursor.execute(sql, values)
        if write_operation == "insert":
            bean.id = self.cursor.lastrowid
        return bean.id

    def __create_column(self, table, column, sqltype):
        if self.frozen:
            return
        if sqltype in [float, int, bool]:
            sqltype = "NUMERIC"
        else:
            sqltype = "TEXT"
        sql = "alter table " + table + " add " + column + " " + sqltype    
        self.cursor.execute(sql)

    def __get_columns(self, table):
        columns = []
        if self.frozen:
            return columns
        self.cursor.execute("PRAGMA table_info(" + table  + ")")
        for row in self.cursor:
            columns.append(row["name"])
        return columns

    def __create_table(self, table):
        if self.frozen:
            return
        sql = "create table if not exists " + table + "(id INTEGER PRIMARY KEY AUTOINCREMENT)"
        self.cursor.execute(sql)

    def get_rows(self, table_name, sql = "1", replace = None):
        if replace is None : replace = []
        self.__create_table(table_name)
        sql = "SELECT * FROM " + table_name + " WHERE " + sql
        try:
            self.cursor.execute(sql, replace)
            for row in self.cursor:
                yield row
        except sqlite3.OperationalError:
            return
   
    def get_count(self, table_name, sql="1", replace = None):
        if replace is None : replace = []
        self.__create_table(table_name)
        sql = "SELECT count(*) AS cnt FROM " + table_name + " WHERE " + sql
        try:
            self.cursor.execute(sql, replace)
        except sqlite3.OperationalError:
            return 0
        for row in self.cursor:
            return row["cnt"]

    def delete(self, bean):
        self.__create_table(bean.__class__.__name__)
        sql = "delete from " + bean.__class__.__name__ + " where id=?"
        self.cursor.execute(sql,[bean.id])
    
    def link(self, bean_a, bean_b):
        self.replace(bean_a)
        self.replace(bean_b)
        table_a = bean_a.__class__.__name__
        table_b = bean_b.__class__.__name__
        assoc_table = self.__create_assoc_table(table_a, table_b)
        sql = "replace into " + assoc_table + "(" + table_a + "_id," + table_b
        sql += "_id) values(?,?)"
        self.cursor.execute(sql,
                [bean_a.id, bean_b.id])
    
    def unlink(self, bean_a, bean_b):
        table_a = bean_a.__class__.__name__
        table_b = bean_b.__class__.__name__
        assoc_table = self.__create_assoc_table(table_a, table_b)
        sql = "delete from " + assoc_table + " where " + table_a
        sql += "_id=? and " + table_b + "_id=?"
        self.cursor.execute(sql,
                [bean_a.id, bean_b.id])
    
    def get_linked_rows(self, bean, table_name):
        bean_table = bean.__class__.__name__
        assoc_table = self.__create_assoc_table(bean_table, table_name)
        sql = "select t.* from " + table_name + " t inner join " + assoc_table 
        sql += " a on a." + table_name + "_id = t.id where a."
        sql += bean_table + "_id=?"
        self.cursor.execute(sql,[bean.id])
        for row in self.cursor:
            yield row

    def __create_assoc_table(self, table_a, table_b):
        assoc_table = "_".join(sorted([table_a, table_b]))
        if not self.frozen:
            sql = "create table if not exists " + assoc_table + "("
            sql+= table_a + "_id NOT NULL REFERENCES " + table_a + "(id) ON DELETE cascade,"
            sql+= table_b + "_id NOT NULL REFERENCES " + table_b + "(id) ON DELETE cascade,"
            sql+= " PRIMARY KEY (" + table_a + "_id," + table_b + "_id));"
            self.cursor.execute(sql)
            # no real support for foreign keys until sqlite3 v3.6.19
            # so here's the hack
            if cmp(parse_version(sqlite3.sqlite_version),parse_version("3.6.19")) &lt; 0:
                sql = "create trigger if not exists fk_" + table_a + "_" + assoc_table
                sql+= " before delete on " + table_a
                sql+= " for each row begin delete from " + assoc_table + " where " + table_a + "_id = OLD.id;end;"
                self.cursor.execute(sql)
                sql = "create trigger if not exists fk_" + table_b + "_" + assoc_table
                sql+= " before delete on " + table_b
                sql+= " for each row begin delete from " + assoc_table + " where " + table_b + "_id = OLD.id;end;"
                self.cursor.execute(sql)
        return assoc_table

    def delete_all(self, table_name, sql = "1", replace = None):
        if replace is None : replace = []
        self.__create_table(table_name)
        sql = "DELETE FROM " + table_name + " WHERE " + sql
        try:
            self.cursor.execute(sql, replace)
            return True
        except sqlite3.OperationalError:
            return False

    def commit(self):
        self.db.commit()



class Store(object):
    """
    A SQL writer should be passed to the constructor:

    beans_save = Store(SQLiteWriter(":memory"), frozen=False)
    """
    def __init__(self, SQLWriter):
        self.writer = SQLWriter 
    
    def new(self, table_name):
        new_object = type(table_name,(object,),{})()
        return new_object

    def save(self, bean):
        self.writer.replace(bean)
    
    def load(self, table_name, id):
        for row in self.writer.get_rows(table_name, "id=?", [id]):
            return self.row_to_object(table_name, row)

    def count(self, table_name, sql = "1", replace=None):
        return self.writer.get_count(table_name, sql, replace if replace is not None else [])

    def find(self, table_name, sql = "1", replace=None):
        for row in self.writer.get_rows(table_name, sql, replace if replace is not None else []):
            yield self.row_to_object(table_name, row)

    def find_one(self, table_name, sql = "1", replace=None):
        try:
            return next(self.find(table_name, sql, replace))
        except StopIteration:
            return None

    def delete(self, bean):
        self.writer.delete(bean)
    
    def link(self, bean_a, bean_b):
        self.writer.link(bean_a, bean_b)
    
    def unlink(self, bean_a, bean_b):
        self.writer.unlink(bean_a, bean_b)
    
    def get_linked(self, bean, table_name):
        for row in self.writer.get_linked_rows(bean, table_name):
            yield self.row_to_object(table_name, row)

    def delete_all(self, table_name, sql = "1", replace=None):
        return self.writer.delete_all(table_name, sql, replace if replace is not None else [])

    def row_to_object(self, table_name, row):
        new_object = type(table_name,(object,),{})()
        for key in row.keys():
            new_object.__dict__[key] = row[key]
        return new_object

    def commit(self):
        self.writer.commit()
</t>
<t tx="amd_yen.20130413002743.2100">http://www-inst.eecs.berkeley.edu/~cs61a/sp11/0.pdf

強調要有數學背景, 最好要有一些程式語言經驗, 然後教導 Schema, 線上課本採用 http://mitpress.mit.edu/sicp/, 任課講師為 UCBLogo 作者

一年之後, 就開始採用 Python 3 進行教學.

http://www-inst.eecs.berkeley.edu/~cs61a/sp12/

並且依照 http://mitpress.mit.edu/sicp/ 教材的編撰精神, 以 Python 3 程式語法編寫了線上教材

http://www-inst.eecs.berkeley.edu/~cs61a/sp12/book/, 並採用 http://creativecommons.org/licenses/by-sa/3.0/ 授權.

到了 http://www-inst.eecs.berkeley.edu/~cs61a/fa12/, 任職於 Google 的 John Denero (也是上述 Python 3 的作者之一)接手開課, 並導入 Philip Guo 所開發的 Python online tutor, 至此, Python online tutor 已經可以利用 cgi 介面執行伺服器上的 Python 3 解譯系統.

http://www-inst.eecs.berkeley.edu/~cs61a/sp13/ 仍然延續 Python 3 教學, 但是講師換成 2012 年剛完成 Ph.D. 學位的 Amir Kamil.
</t>
<t tx="amd_yen.20130413002743.2101">無論是學習程式語言或者是教導程式語言, 其實都不容易, 因為程式語言的目的在於與電腦硬體進行溝通, 假如使用者能夠充分了解電腦硬體的架構與運作原理, 就能有效強化運用程式語言的能力.

寫電腦程式並非電腦系、資訊工程或資訊管理科系所專有, 任何人西運用電腦快速的運算與資料處理能力的使用者, 都應該要能夠寫基本的電腦程式來解決自己所面臨的問題.

以機械設計工程領域的產品開發人員而言, 無論是使用電腦輔助設計或分析套件, 經常必須要透過該套件的延伸程式介面, 來編寫客製化程式, 才能有效解決所面臨的特殊問題.

機械設計流程中所衍生的許多數位資料, 也都必須仰賴產品資料管理與產品生命週期管理系統 (PLM), 才能在多人協同的環境中有效管理並運用各版次的設計資料.

學習程式語言必須要先認清楚學習的動機, 先來看看電腦程式與網路結合下所能到完成的工作.

根據: http://www.opensourceshakespeare.org/views/plays/plays.php 的資料, 莎士比亞的劇作共有 37 部, 全文可以由 http://cae.mde.tw/downloads/shakespeare.txt 下載, 假如我們要求電腦程式解讀這 37 本劇作, 然後找出來其中所用的單字, 包含 5 個與超過 5 個字母的單字中, 順拼與逆拼都是單字的特殊單字共有幾個?

假如用人來進行上述工作, 這真是不可能的任務, 但是電腦程式正好適合用來處理如此繁雜的工作.

.. code-block:: python

    # 本程式取材自: http://www-inst.eecs.berkeley.edu/~cs61a/sp12/book/
    #coding= utf-8
    # 從 urllib.request 模組導入 urlopen 函式
    # 參考資料: http://docs.python.org/3.0/library/urllib.request.html
    from urllib.request import urlopen
     
    # 從網路連結, 取得莎士比亞全文(37 個劇本)資料
    莎士比亞全文 = urlopen('http://cae.mde.tw/downloads/shakespeare.txt')
    # 列出全文物件
    #print(莎士比亞全文)
     
    # 參考資料: http://docs.python.org/3.0/library/stdtypes.html#set
    莎翁劇中全部單字 = set(莎士比亞全文.read().decode().split())
    # 列出全部單字物件
    #print(words)
     
    # 列出 5 個(含)字母以上的單字中, 正拼與反拼都出現在單字集中的單字
    print({單字 for 單字 in 莎翁劇中全部單字 if len(單字) &gt;= 5 and 單字[::-1] in 莎翁劇中全部單字})
     
    '''
    {'rever', 'knits', 'repel', 'level', 'drawer', 'repaid', 'stink', 'redder', 'stops', 'spots', 'asses', 'leets', 'refer', 'steel', 'devil', 'speed', 'keels', 'leper', 'sleek', 'reward', 'minim', 'sessa', 'deeps', 'madam', 'lived', 'diaper'}
    '''
    
也就是說, 符合條件的單字共有 26 個.

再來看下一個比較簡單的範例:

.. code-block:: python

    from math import *
    print(max(6.8,7.8))
    print(max(6.8,7.8,10.2))
    print(max([6.8,7.8,10.2]))
    
這個程式的第一行, from math import *, 在導入 math 模組中的所有函式, 其中包含 max() 函式, 而此一函式可以輸入多個數值, 也可以輸入數列, 都能夠在這些輸入的數值中, 找到最大的數值, 然後利用 print() 函式將結果印出來.

因為程式語言就是在與電腦進行溝通, 假如將上述程式碼改為:

.. code-block:: python

    import math
    print(math.max(6.8,7.8))
    print(math.max(6.8,7.8,10.2))
    print(math.max([6.8,7.8,10.2]))
    
就可以知道與電腦溝通的模式並非固定不變的, 假如導入的寫法不是 from math import *, 而是 import math, 後續的 max() 函式呼叫, 就必須冠上 math, 而成為 math.max()

只要明白這個道理, 同樣在 math 模組中定義的 min(), sin(), cos() 等數學函式的用法也就能夠完全掌握, 這樣的程式學習就稱為 pattern matching, 也就是類似範式的套用, 尤其對於非電腦專業的工程師而言, 只要掌握程式語言在該專業領域應用的範式就能更容易解決可能面臨的問題, 因為大多類似的問題不僅已經被解決, 而且有許多程式碼已經被公開在任何人都可以擷取的網站上, 只要了解程式語言的基本使用原理與架構, 接下來就可以設法找到可用的問題解決範式來加以套用.</t>
<t tx="amd_yen.20130413002743.2102">在十年前的五專時期, 程式語言大多以 C/C++ 教學為主, 尤其是以較為簡單的 C 程式語言教學為主, 在 Windows 95 操作系統上更以 Borland Turbo C/C++ 的教學為主, 到了 Windows NT 以及 Windows 2000 時期則逐步轉換為 Visual C/C++ 環境的教學為主, 進入 Windows XP 時期, 則轉而利用 Code::Block 與 NetBeans 等開放 IDE + MinGW C/C++ 編譯環境為主.

2010 年則以 C+PHP 程式教學為主, 自 2011 年起則全面改採 Python3 進行教學, 主要考量在於 Python3 無論在單機環境或網際環境, 甚或工程或科學運算領域上的應用, 遠比 Java 更容易入手, 且提供更多的整合工具, 尤其是在最近逐步興起的開放 MCAD (Mechanical Computer Aided Design) 與 PLM 領域也大多採 Python 程式架構, 此波趨勢甚至影響到全球各電腦資工科系的基礎教學轉變, 10 年前原先採用 Java 作為導入程式語言的課程, 過去 5 年大多轉向 Python 教學, 尤其自 2009 年起 Javascript 加上 HTML5 已經全面取代 Java applet 曾經獨攬網際平台的光環, 甚而在 2013 年的現在, Node.js 已經被許多團隊用來取代原先用 Java 在 Server 端的地位.

程式語言的應用階次比較 C++ &gt; Java &gt; C &gt; Python, 主要原因在於 Python 為解譯式程式語言, 上手比較容易, 當需要較高速的運算條件時則可以透過 Python 結合 C/C++ 程式, 或者透過 PyCuda 等模組使用 GPU 進行多核平行運算, 或結合 PyZMQ 執行分散運算.

假如再以手機與平板裝置興起的角度來看, 解譯式的 Python 加上 Javascript 更能符合短生命週期與快速變遷的程式環境需求.

因此目前的程式語言、電腦輔助設計、協同產品設計相關教學, 採用 Python 3 + Javascript + PHP + C/C++ 足以勝任大多數的程式環境需求.</t>
<t tx="amd_yen.20130413002743.2103">#coding: utf-8
from sympy
 import *
x, y, z, t = symbols('x y z t')
k, m, n = symbols('k m n', integer=True)
f, g, h = symbols('f g h', cls=Function)
# d:f 表示由 d 到 f
d, e, f = symbols('d:f')
# 表示 g0 與 g1
print(var('g:2'))
print(diff(x**2/2, x))
print(limit(sin(x)/x, x, 0))
print((1/cos(x)).series(x, 0, 10))
print(Rational(2)**50/Rational(10)**50)
R = Rational
print(R(1, 2))
print(pi.evalf())
print((pi*E).evalf())
# oo is infinity (兩個小寫的ㄡ)
print(oo &gt; 9999999)
print(integrate(1/x, x))
print(x+y*2-3*x-5*y)
# 多項式展開
print(((x+y)**2).expand())
# 取代, x=1 代入多項式
print((((x+y)**3).subs(x, 1)).expand())
# 因式分解
print(apart(1/((x+2)*(x+1)), x))
# 合併
print(together(1/x+1/y+1/z))
# 微分
print(diff(sin(2*x), x))
# 複數
print(exp(I*x).expand(complex=True))
# 三角函數
print(cos(x+y).expand(trig=True))
print(sin(x+y).expand(trig=True))</t>
<t tx="amd_yen.20130413002743.2104">下載, 解開, 執行

這裡利用 Python、SciTE、TinyC 與 Leo Editor 建立一個可攜的程式環境.

</t>
<t tx="amd_yen.20130418193628.2121">以下為 CMSimple plugin 以 Javascript 編寫動態四連桿模擬.

&lt;?php

function yen4barMain(){
$output = &lt;&lt;&lt;EOF
&lt;script&gt;
var Point = function Point(x,y){
    this.x=x;
    this.y=y;
}
// 附加 drawMe() 方法, 以繪製出點位置
Point.prototype.drawMe = function drawMe(g,r){
    this.g = g;
    this.r = r;
    this.g.save();
    this.g.moveTo(this.x,this.y);
    this.g.beginPath();
    // draw a radius=4 circle
    this.g.arc(this.x, this.y, this.r, 0, 2 * Math.PI, true);
    this.g.moveTo(this.x,this.y);
    this.g.lineTo(this.x+this.r, this.y);
    this.g.moveTo(this.x, this.y);
    this.g.lineTo(this.x-this.r, this.y);
    this.g.moveTo(this.x, this.y);
    this.g.lineTo(this.x, this.y+this.r);
    this.g.moveTo(this.x, this.y);
    this.g.lineTo(this.x, this.y-this.r);
    this.g.restore();
    this.g.stroke();
}
// 加入 Eq 方法
Point.prototype.Eq = function Eq(pt){
    this.x = pt.x;
    this.y = pt.y;
}
// 加入 setPoint 方法
Point.prototype.setPoint = function setPoint(px,py){
    this.x = px;
    this.y = py;
}
// 加上 distance(pt) 方法, 計算點到 pt 的距離
Point.prototype.distance = function distance(pt){
    this.pt = pt;
    return Math.sqrt(Math.pow(this.x-this.pt.x,2)+Math.pow(this.y-this.pt.y,2));
}
// Line 函式物件
var Line = function Line(p1,p2){
    this.p1 = p1;
    this.p2 = p2;
    this.Tail = this.p1;
    this.Head = this.p2;
    this.length = Math.sqrt(Math.pow(this.p2.x-this.p1.x, 2)+Math.pow(this.p2.y-this.p1.y,2));
}
// setPP 方法 for Line
Line.prototype.setPP = function setPP(p1,p2){
    this.p1 = p1;
    this.p2 = p2;
    this.Tail = this.p1;
    this.Head = this.p2;
    this.length = Math.sqrt(Math.pow(this.p2.x-this.p1.x, 2)+Math.pow(this.p2.y-this.p1.y,2));
}
// setRT 方法 for Line, 應該已經確定 Tail 點, 然後以 r, t 作為設定 Head 的參考
Line.prototype.setRT = function setRT(r,t){
    this.r = r;
    this.t = t;
    var x = this.r * Math.cos(this.t);
    var y = this.r * Math.sin(this.t);
    this.Tail.Eq(this.p1);
    this.Head.setPoint(this.Tail.x + x,this.Tail.y + y);
}
// getR 方法 for Line
Line.prototype.getR = function getR(){
    // x 分量與 y 分量
    var x = this.p1.x - this.p2.x;
    var y = this.p1.y - this.p2.y;
    return Math.sqrt(x * x + y * y);
}
// 根據定義 atan2(y,x), 表示 (x,y) 與 正 x 軸之間的夾角, 介於 PI 與 -PI 間
Line.prototype.getT = function getT(){
    var x = this.p2.x - this.p1.x;
    var y = this.p2.y - this.p1.y;
    if (Math.abs(x) &lt; 1E-100) {
        return y &lt; 0.0 ? -Math.PI/2 : Math.PI/2;
    }else{
        return Math.atan2(y, x);
    }
}
// setTail 方法 for Line
Line.prototype.setTail = function setTail(pt){
    this.pt = pt;
    this.Tail.Eq(pt);
    this.Head.setPoint(this.pt.x + this.x, this.pt.y + this.y);
}
// getHead 方法 for Line
Line.prototype.getHead = function getHead(){
    return this.Head;
}
Line.prototype.getTail = function getTail(){
    return this.Tail;
}
Line.prototype.drawMe = function drawMe(g){
    this.g = g;
    this.g.beginPath();
    this.g.moveTo(this.p1.x,this.p1.y);
    this.g.lineTo(this.p2.x,this.p2.y);
    this.g.stroke();
}
// 轉換函式
function degToRad(x) {
    return x / 180 * Math.PI;
}
function radToDeg(x) {
    return x / Math.PI * 180;
}
//
// 建立一個物件繼承函式
// We need a utility function to do the inheritance
function inherit(superClass, subClass) {
    for(var i in superClass.prototype) {
        subClass.prototype[i] = superClass.prototype[i]
    }
}
// 建立 Link function 物件
var Link = function Link(p1,p2){
    this.p1 = p1;
    this.p2 = p2;
    this.length = Math.sqrt(Math.pow(this.p2.x-this.p1.x, 2)+Math.pow(this.p2.y-this.p1.y,2));
}
// 讓 Link 繼承 Line 的方法與屬性
inherit(Line,Link);
//
//
//
// 建立 Link 特有的 drawMe 方法
Link.prototype.drawMe = function drawMe(g){
    this.g = g;
    var hole = 5;
    var radius = 10;
    var length = this.getR();
    // 儲存先前的繪圖狀態
    this.g.save();
    this.g.translate(this.p1.x,this.p1.y);
    // 這裡的轉角必須配合最初的 Link 是畫在 x 軸上或是 y 軸上來進行座標轉換, 目前是以畫在 y 軸上進行座標軸旋轉, 並且確定 Math.atan2(y,x)
    // 以下 alert 用來 debug
    //alert("角度為"+ radToDeg(this.getT()));
    //alert("座標軸轉角為"+radToDeg(-(Math.PI/2-this.getT())));
    this.g.rotate(-(Math.PI/2-this.getT()));
    // 必須配合畫在 y 軸上的 Link, 進行座標轉換, 也可以改為畫在 x 軸上...
    this.g.moveTo(0,0);
    this.g.beginPath();
    this.g.arc(0, 0, hole, 0, 2*Math.PI, true);
    this.g.stroke();
    //
    this.g.moveTo(0,length);
    this.g.beginPath();
    this.g.arc(0,length, hole, 0, 2*Math.PI, true);
    this.g.stroke();
    //
    this.g.moveTo(0,0);
    this.g.beginPath();
    this.g.arc(0,0, radius, 0, Math.PI, true);
    this.g.moveTo(0+radius,0);
    this.g.lineTo(0+radius,0+length);
    this.g.stroke();
    this.g.moveTo(0,0+length);
    //
    this.g.beginPath();
    this.g.arc(0, 0+length, radius, Math.PI, 0, true);
    this.g.moveTo(0-radius,0+length);
    this.g.lineTo(0-radius,0);
    this.g.stroke();
    //
    this.g.restore();
}
//
//
//
//
//
// ap1 角為 p1 點所在的角度, lenp1 長度則為 ap1 角度對應的邊長
// ap2 角為 p2 點所在的角度, lenp2 長度則為 ap2 角度對應的邊長
// ap3 角為 p3 點所在的角度, lenp3 長度則為 ap3 角度對應的邊長
var Triangle = function Triangle(p1,p2,p3){
    // 先將輸入變數轉為函式物件性質
    this.p1 = p1;
    this.p2 = p2;
    this.p3 = p3;
}
//
Triangle.prototype.getLenp3 = function getLenp3(){
    var p1 = this.p1;
    var ret = p1.distance(this.p2);
    return ret;
}
//
Triangle.prototype.getLenp1 = function getLenp1(){
    var p2 = this.p2;
    var ret = p2.distance(this.p3);
    return ret;
}
//
Triangle.prototype.getLenp2 = function getLenp2(){
    var p1 = this.p1;
    var ret = p1.distance(this.p3);
    return ret;
}
    
// 角度
Triangle.prototype.getAp1 = function getAp1(){
    var ret = Math.acos(((this.getLenp2() * this.getLenp2() + this.getLenp3() * this.getLenp3()) - this.getLenp1() * this.getLenp1()) / (2* this.getLenp2() * this.getLenp3()));
    return ret;
}
//
Triangle.prototype.getAp2 = function getAp2(){
    var ret =Math.acos(((this.getLenp1() * this.getLenp1() + this.getLenp3() * this.getLenp3()) - this.getLenp2() * this.getLenp2()) / (2* this.getLenp1() * this.getLenp3()));
    return ret;
}
//
Triangle.prototype.getAp3 = function getAp3(){
    var ret = Math.acos(((this.getLenp1() * this.getLenp1() + this.getLenp2() * this.getLenp2()) - this.getLenp3() * this.getLenp3()) / (2* this.getLenp1() * this.getLenp2()));
    return ret;
}
//
Triangle.prototype.drawMe = function drawMe(g){
    this.g = g;
    var r = 5;
    // 繪出三個頂點
    this.p1.drawMe(this.g,r);
    this.p2.drawMe(this.g,r);
    this.p3.drawMe(this.g,r);
    var line1 = new Line(this.p1,this.p2);
    var line2 = new Line(this.p1,this.p3);
    var line3 = new Line(this.p2,this.p3);
    // 繪出三邊線
    line1.drawMe(this.g);
    line2.drawMe(this.g);
    line3.drawMe(this.g);
}
// ends Triangle function
// 透過三個邊長定義三角形
Triangle.prototype.setSSS = function setSSS(lenp3,lenp1,lenp2){
    this.lenp3 = lenp3;
    this.lenp1 = lenp1;
    this.lenp2 = lenp2;
    this.ap1 = Math.acos(((this.lenp2 * this.lenp2 + this.lenp3 * this.lenp3) - this.lenp1 * this.lenp1) / (2* this.lenp2 * this.lenp3));
    this.ap2 = Math.acos(((this.lenp1 * this.lenp1 + this.lenp3 * this.lenp3) - this.lenp2 * this.lenp2) / (2* this.lenp1 * this.lenp3));
    this.ap3 = Math.acos(((this.lenp1 * this.lenp1 + this.lenp2 * this.lenp2) - this.lenp3 * this.lenp3) / (2* this.lenp1 * this.lenp2));
}
// ends setSSS
// 透過兩個邊長與夾角定義三角形
Triangle.prototype.setSAS = function setSAS(lenp3,ap2,lenp1){
    this.lenp3 = lenp3;
    this.ap2 = ap2;
    this.lenp1 = lenp1;
    this.lenp2 = Math.sqrt((this.lenp3 * this.lenp3 + this.lenp1 * this.lenp1) - 2* this.lenp3 * this.lenp1 * Math.cos(this.ap2));
    //等於 SSS(AB, BC, CA);
}
// ends setSAS
//
Triangle.prototype.setSaSS = function setSaSS(lenp2,lenp3,lenp1){
    this.lenp2 = lenp2;
    this.lenp3 = lenp3;
    this.lenp1 = lenp1;
    var ret;
    if(this.lenp1 &gt; (this.lenp2 + this.lenp3)){
    // &lt;CAB 夾角為 180 度, 三點共線且 A 介於 BC 之間
        ret = Math.PI;
    } else {
        // &lt;CAB 夾角為 0, 三點共線且 A 不在 BC 之間
        if((this.lenp1 &lt; (this.lenp2 - this.lenp3)) || (this.lenp1 &lt; (this.lenp3 - this.lenp2))){
        ret = 0.0;
        } else {
        // 透過餘絃定理求出夾角 &lt;CAB 
            ret = Math.acos(((this.lenp2 * this.lenp2 + this.lenp3 * this.lenp3) - this.lenp1 * this.lenp1) / (2 * this.lenp2 * this.lenp3));
        }
    }
    return ret;
}
// 取得三角形的三個邊長值
Triangle.prototype.getSSS = function getSSS(){
    var temp = new Array(2);
    temp[0] = this.getLenp1();
    temp[1] = this.getLenp2();
    temp[2] = this.getLenp3();
    return temp;
}
// 取得三角形的三個角度值
Triangle.prototype.getAAA = function getAAA(){
    var temp = new Array(2);
    temp[0] = this.getAp1();
    temp[1] = this.getAp2();
    temp[2] = this.getAp3();
    return temp;
}
// 取得三角形的三個角度與三個邊長
Triangle.prototype.getASASAS = function getASASAS(){
    var temp = new Array(5);
    temp[0] = this.getAp1();
    temp[1] = this.getLenp1();
    temp[2] = this.getAp2();
    temp[3] = this.getLenp2();
    temp[4] = this.getAp3();
    temp[5] = this.getLenp3();
    return temp;
}
Triangle.prototype.setPPSS = function setPPSS(p1,p3,lenp1,lenp3){
var temp = new Array(1);
this.p1 = p1;
this.p3 = p3;
this.lenp1 = lenp1;
this.lenp3 = lenp3;
this.lenp2 = this.p1.distance(this.p3);
// bp3 is the angle beside p3 point, cp3 is the angle for line23, p2 is the output
var ap3,bp3,cp3,p2;
var line31 = new Line(p3,p1);
ap3 = Math.acos(((this.lenp1 * this.lenp1 + this.lenp2 * this.lenp2) - this.lenp3 * this.lenp3) / (2 * this.lenp1 * this.lenp2));
bp3 = line31.getT();
cp3 = bp3 - ap3;
temp[0] = p3.x + this.lenp1*Math.cos(cp3); // p2.x
temp[1] = p3.y + this.lenp1*Math.sin(cp3); // p2.y
return temp;
}
//
//
//
//
// 執行繪圖流程, 注意 x, y 為 global variables
function draw(){
    // 清除畫布
    context.clearRect(0, 0, canvas.width, canvas.height)
    // 畫圖
    line1.drawMe(context);
    line2.drawMe(context);
    line3.drawMe(context);
    // 畫出三角形
    //triangle1.drawMe(context);
    //triangle2.drawMe(context);
    // 旋轉角度進行增量
    theta += dx;
    // 根據旋轉角度計算 p2 點的新位置
    p2.x = p1.x + line1.length*Math.cos(theta*degree);
    p2.y = p1.y - line1.length*Math.sin(theta*degree);
    temp = triangle2.setPPSS(p2,p4,link3_len,link2_len);
    p3.x = temp[0];
    p3.y = temp[1];
}
// ends function draw()
//
//
//
//
// 以上為相關函式物件的定義區
// 全域變數
// 幾何位置輸入變數
var x=10,y=10,r=10;
// 畫布與繪圖內容
var canvas,context;
// 其他輸入變數
var theta = 0;
var degree = Math.PI/180;
var dx = 2;
var dy = 4;
var p1 = new Point(150,100);
var p2 = new Point(150,200);
var p3 = new Point(300,300);
var p4 = new Point(350,100);
var line1 = new Link(p1,p2);
var line2 = new Link(p2,p3);
var line3 = new Link(p3,p4);
var line4 = new Link(p1,p4);
var line5 = new Link(p2,p4);
var link2_len = p2.distance(p3);
var link3_len = p3.distance(p4);
var triangle1 = new Triangle(p1,p2,p4);
var triangle2 = new Triangle(p2,p3,p4);
var temp = new Array(1);
//
//
//
//
// 視窗載入時執行內容
window.onload=function(){
    // 繪圖畫布設定
    canvas = document.getElementById("canvas");
    context = canvas.getContext("2d");
    // 座標轉換, 移動 canvas.height 並且 y 座標變號, 也就是將原點座標移到畫面左下角
    context.translate(0,canvas.height);
    context.scale(1,-1);
    // 座標轉換結束, 之後的繪圖都將在此一座標戲中進行繪製
    /*
    context.translate(dx,dy) &lt;==&gt; context.transform( 1,  0,  0,  1, dx, dy)
    context.rotate(θ)        &lt;==&gt; context.transform( c, -s,  s,  c,  0,  0)
    context.scale(sx,sy)     &lt;==&gt; context.transform(sx,  0,  0, sy,  0,  0)
    */
    //////////
    //////////
    // 以間隔 10 micro seconds 重複呼叫 draw()
    window.setInterval(draw, 10);
}
//
//
//
//
&lt;/script&gt;
&lt;p&gt;
	&lt;canvas height="600" id="canvas" style="border:1px solid black;" width="600"&gt;&lt;/canvas&gt;&lt;/p&gt;
EOF;
return $output;
}</t>
<t tx="amd_yen.20130418193628.2122"></t>
<t tx="amd_yen.20130423211907.2155"></t>
<t tx="amd_yen.20130423211907.2156">PythonCAD 自 2010 年起正以 PyQT GUI 全面改寫(R38)中, 主要特色在於::

    自行打造一個小型的 2D 繪圖 kernel
    
    使用 SQLite 資料庫系統
    
    支援 Scriptable 程式介面

使用者可以透過此一完全以 Python 程式語言打造的 2D 來了解電腦輔助機械設計製圖的初步架構, 進而建立其他客製化的 2D 繪圖應用模組.

截至 2013.04, Python R38 仍然僅支援 Python 2, 若要將程式碼改為 Python 3 相容, 需要進行以下修改:
    
- IDE\Python33\Lib\site-packages\PyQt4\pyrcc4.exe 將 PythonCAD\Interface\cadwindow.qrc 轉為 cadwindow_rc.py 過程必須將 icons 目錄複製為 Interface\images, 然後重新建立 cadwindow_rc.py (pyrcc4 -py3 cadwindow.qrc -o cadwindow_rc.py), 才可建立 Python 3 相容的 cadwindow_rc.py
    
- 必須利用 IDE\Python33\tools\scripts\2to3.py -w PythonCAD 將原先 Python 2 的程式碼轉為 Python 3 相容的程式碼
    
- 實際執行 pythoncad_qt.py 時還必須修改 .toBool() 為 bool(), 以及其他類似的 Python 2 轉為 Python 3 的程式語法差異
    
此外, C:\Documents and Settings\用戶名稱\PythonCAD 目錄中的 PythonCAD_Local.pdr SQLite 資料庫檔案為啟動 PythonCAD 時會自動導入的資料檔案, 由於 Python 2 與 Python 3 有不同版本的 pickle.dumps() 與 pickle.loads() 用法 (Python 2 支援 protocol 2, 而 Python 3 支援 protocol 3), 因此必須全面改寫繪圖檔案的 file io 格式, 才能夠全面將 Python 2 的 PythonCAD 轉為 Python 3.
    
以下為 .pdr 檔案格式中 pycadent, 也就是 PythonCAD entity 資料表格的欄位設計::

    CREATE TABLE pycadent(
                        pycad_id INTEGER PRIMARY KEY,
                        pycad_entity_id INTEGER,
                        pycad_object_type TEXT,
                        pycad_object_definition TEXT,
                        pycad_object_style TEXT,
                        pycad_security_id INTEGER,
                        pycad_undo_id INTEGER,
                        pycad_entity_state TEXT,
                        pycad_index NUMERIC,
                        pycad_visible INTEGER,
                        pycad_undo_visible INTEGER,
                        pycad_locked INTEGER,
                        pycad_bbox_xmin REAL,
                        pycad_bbox_ymin REAL,
                        pycad_bbox_xmax REAL,
                        pycad_bbox_ymax REAL, pycad_property TEXT)
                    
為了將 PythonCAD 改為 Python 3 相容, 必須修改上述資料庫欄位設計, 將 pycad_object_definition TEXT, 改為 pycad_object_definition BLOB, 並且將 pycad_object_style TEXT, 改為 pycad_object_style BLOB, 主要原因在於 Python 3 的 pickle 版本為 3, 而 Python 2 pickle 版本則為 2, 所有在 Python 3 經過 pickle.dumps() 處理過的資料其格式為 bytes, 而且 pickle.loads() 中的輸入資料格式必須為 bytes.
</t>
<t tx="amd_yen.20130423211907.2157"></t>
<t tx="amd_yen.20130423211907.2158">根據 http://docs.python.org/3/library/pickle.html#what-can-be-pickled-and-unpickled 的說明:

The following types can be pickled::

    None, True, and False
    integers, floating point numbers, complex numbers
    strings, bytes, bytearrays
    tuples, lists, sets, and dictionaries containing only picklable objects
    functions defined at the top level of a module
    built-in functions defined at the top level of a module
    classes that are defined at the top level of a module
    instances of such classes whose __dict__ or the result of calling __getstate__() is picklable (see section Pickling Class Instances for details).
</t>
<t tx="amd_yen.20130426235501.4331">機械動態系統分析模擬為自動控制系統設計的第一歩, 這裡所要介紹的系統模擬語言為 Modelica, 執行系統運動方程式數值分析的運算工具則為 OpenModelica, 而進行模擬的套件平台則為 Pysimulator.

在業界(尤其是德國、荷蘭、瑞典與芬蘭), 經常被用來模擬工業機器人(industrial robots)與汽車(automobile).

Modelica: https://www.modelica.org/

OpenModelica: https://www.openmodelica.org/

PySimulator: https://code.google.com/p/pysimulator/ (截至 2013.05, 僅支援 Python 2.7.X)

Modelica 為一種機電光系統的物件導向動態模擬語言, 可用來建立複雜系統的動態模型.</t>
<t tx="amd_yen.20130426235501.4332">Modelica 的資料型別

Real, Integer, Boolean, String

簡單的質量運動模型:

.. code-block:: python

    model MovingMass1        "Moving Mass";
        parameter Real m=2    "Mass of the block";
        parameter Real f=6      "Force";
        Real s                         "Position of the block";
        Real v                         "Velocity of the block";
    equation
        v=der(s);
        m*der(v)=f;
    end MovingMass1;
    
在模型中對分析變數加入屬性:

.. code-block:: modelica

    model MovingMass2        "Moving Mass";
        parameter Real m(min=0, unit="kg")=2    "Mass of the block";
        parameter Real f(unit="N")=6      "Force";
        Real s                         "Position of the block";
        Real v                         "Velocity of the block";
    equation
        v=der(s);
        m*der(v)=f;
    end MovingMass2;
    
導入分析模組後的模型:

.. code-block:: modelica

    model MovingMass3
        package SIunits = Modelica.SIunits;
        parameter SIunits.Mass m = 2 "mass of block";
        parameter SIunits.Force f = 6 "force to pull block";
        SIunits.Position s "position of block";
        SIunits.Velocity v "velocity of block";
        annotation(Diagram(Rectangle(extent=..)..)..);
    equation
        v = der(s);
        m*der(v) = f;
    end MovingMass3;
    
註解: 從 http://www.pydy.org/ 網站中, 可以看出來, 假如能夠在 Sympy 的輔助下, 應該有機會直接利用 Python 來進行複雜系統的動態模擬, 也就是說 Modelica 的所謂物件導向模擬語言, 其實就是用 Modelica 的語法來描述動態系統元件中的變數關係, 然後再定義各元件的介面關係, 最後再以硬體組裝的方式, 將這些  Modelica 模擬元件組合成一個複雜系統的模型, 最後再經過運動方程式推導與約束條件轉換為數值分析程式, 編譯後即可執行分析運算.

例如, 若已經透過 Sympy 推導出系統的運動方程式, 就可以使用 Scipy 解出結果.

.. code-block:: python

    #coding: utf-8
    # 導入 scipy 解常微分方程式用
    from scipy.integrate import odeint
    # 繪圖用
    from pylab import *
    # 定義微分方程式
    def 微分式(y, t):
         a = -2.0
         b = -0.1
         return array([ y[1], a*y[0]+b*y[1] ])
    
    時間級數 = linspace(0.0,10.0,1000)
    y起始條件 = array([0.0005,0.2]) 
    y = odeint(微分式, y起始條件, 時間級數)
    figure()
    plot(時間級數,y[:,0]) 
    xlabel('t')
    ylabel('y')
    show()</t>
<t tx="amd_yen.20130426235501.4333">利用 Sympy 模組中的 KanesMethod() 推導 double pendulum 系統的運動方程式:

http://docs.sympy.org/dev/modules/physics/mechanics/kane.html

.. code-block:: python

    from sympy import symbols  
    from sympy.physics.mechanics import *
     
    q1, q2 = dynamicsymbols('q1 q2')
    q1d, q2d = dynamicsymbols('q1 q2', 1)
    u1, u2 = dynamicsymbols('u1 u2')
    u1d, u2d = dynamicsymbols('u1 u2', 1)
    l, m, g = symbols('l m g')
     
    N = ReferenceFrame('N')
    A = N.orientnew('A', 'Axis', [q1, N.z])
    B = N.orientnew('B', 'Axis', [q2, N.z])
     
    A.set_ang_vel(N, u1 * N.z)
    B.set_ang_vel(N, u2 * N.z)
     
    O = Point('O')
    P = O.locatenew('P', l * A.x)
    R = P.locatenew('R', l * B.x)
     
    O.set_vel(N, 0)
    P.v2pt_theory(O, N, A)
    R.v2pt_theory(P, N, B)
     
    ParP = Particle('ParP', P, m)
    ParR = Particle('ParR', R, m)
     
    kd = [q1d - u1, q2d - u2]
    FL = [(P, m * g * N.x), (R, m * g * N.x)]
    BL = [ParP, ParR]
     
    KM = KanesMethod(N, q_ind=[q1, q2], u_ind=[u1, u2], kd_eqs=kd)
     
    (fr, frstar) = KM.kanes_equations(FL, BL)
    kdd = KM.kindiffdict()
    mm = KM.mass_matrix_full
    fo = KM.forcing_full
    qudots = mm.inv() * fo
    qudots = qudots.subs(kdd)
    qudots.simplify()
    mechanics_printing()
    mprint(qudots)
    
執行後可以得到以下運動方程式:

[u1]

[u2]

[((2*g*sin(q1) + l*(sin(q1)*cos(q2) - sin(q2)*cos(q1))*u2**2)*((sin(q1)*sin(q2) + cos(q1)*cos(q2))**2/((sin(q1)*sin(q2) + cos(q1)*cos(q2))**2 - 2) - 1)/2 - (g*sin(q2) - l*(sin(q1)*cos(q2) - sin(q2)*cos(q1))*u1**2)*(sin(q1)*sin(q2) + cos(q1)*cos(q2))/((sin(q1)*sin(q2) + cos(q1)*cos(q2))**2 - 2))/l]

[(2*g*sin(q2) - 2*l*(sin(q1)*cos(q2) - sin(q2)*cos(q1))*u1**2 - (2*g*sin(q1) + l*(sin(q1)*cos(q2) - sin(q2)*cos(q1))*u2**2)*(sin(q1)*sin(q2) + cos(q1)*cos(q2)))/(l*((sin(q1)*sin(q2) + cos(q1)*cos(q2))**2 - 2))]

透過

q1 = y[0]
q2 = y[1]
u1 = y[2]
u2 = y[3]

可以轉為系統的 State Equations 常微分方程式, 接著利用 Scipy 進行積分, 並且利用 pylab 將結果繪出:

.. code-block:: python

    #coding: utf-8
    # 導入 scipy 解常微分方程式用
    from scipy.integrate import odeint
    from math import *
    # 繪圖用
    from pylab import *
    # 定義微分方程式
    def 微分式(y, t):
        # 系統常數
        # 質量
        m = 1
        # 重力加速度
        g = 9.81
        # 桿長
        l = 1
        #系統變數轉為狀態變數
        u1 = y[2]
        u2 = y[3]
        q1 = y[0]
        q2 = y[1]
        eq3 = ((2*g*sin(q1) + l*(sin(q1)*cos(q2) - sin(q2)*cos(q1))*u2**2)*((sin(q1)*sin(q2) + cos(q1)*cos(q2))**2/((sin(q1)*sin(q2) + cos(q1)*cos(q2))**2 - 2) - 1)/2 - (g*sin(q2) - l*(sin(q1)*cos(q2) - sin(q2)*cos(q1))*u1**2)*(sin(q1)*sin(q2) + cos(q1)*cos(q2))/((sin(q1)*sin(q2) + cos(q1)*cos(q2))**2 - 2))/l
        eq4 = (2*g*sin(q2) - 2*l*(sin(q1)*cos(q2) - sin(q2)*cos(q1))*u1**2 - (2*g*sin(q1) + l*(sin(q1)*cos(q2) - sin(q2)*cos(q1))*u2**2)*(sin(q1)*sin(q2) + cos(q1)*cos(q2)))/(l*((sin(q1)*sin(q2) + cos(q1)*cos(q2))**2 - 2))
        ode_eq = [u1, u2, eq3, eq4]
        return ode_eq
    
    時間級數 = linspace(0.0, 10.0, 1000)
    y起始條件 = array([0.1, 0.2, 0, 0]) 
    y = odeint(微分式, y起始條件, 時間級數)
    q1 = y[:, 0]
    q2 = y[:, 1]
    u1 = y[:, 2]
    u2 = y[:, 3]
    figure()
    plot(時間級數, q1, label="q1") 
    plot(時間級數, q2, label="q2") 
    plot(時間級數, u1, label="u1") 
    plot(時間級數, u2, label="u2") 
    xlabel('t')
    ylabel('y')
    legend(loc=1)
    show()</t>
<t tx="amd_yen.20130426235501.5059"></t>
<t tx="amd_yen.20130429141318.2219">這應該是程式語言(一)第一週的主題, 先放到這裡(將要以 cloned node 放到 C1 第一週), 說明為何需要學習程式語言.

程式語言是使用者與電腦進行溝通最直接的媒介, 因此學習程式語言的目的就是要利用電腦來工作, 但是為何(機械設計)工程師需要利用電腦來工作?

大家一定不是第一次接觸到電腦, 因此應該初步了解電腦的用途很多, 可以在單機環境中執行各種應用程式, 也可以連上網路, 透過各種協定與全世界的電腦連線, 執行更多應用程式, 但是各位在初步學習電腦程式語言之前, 幾乎都是執行其他人所寫的電腦程式, 而不是按照自己的需求與觀點來編寫程式, 進而執行自己所寫的程式來解決問題.

這裡有一個例子, 可以用來比喻執行他人所寫的程式來解決問題與執行自己所寫的程式來解決問題的差別:
    
各位滿 18 歲之後大多數人都會急著要考機車駕照或汽車駕照, 為甚麼?

假如將執行他人所寫的電腦程式以解決運算問題, 用來對比請父母朋友或其他公共運輸駕駛, 騎機車或開車來解決各位的交通問題, 那麼各位學習騎機車與學開車考駕照的目的, 到底為何?

先看看各位來到大學, 從住宿的地方到學校教室上課, 假如不是自己騎車或開車, 而是等公車或搭朋友的便車, 差別在哪裡?沒有錯, 差別就在於方便性.

假如自己擁有機車或汽車駕照, 而且能夠安全地操控這些方便的交通工具, 自己想到哪裡就到哪裡, 臨時碰到急事或有計畫性的旅遊, 各自騎乘交通工具並透過路程規劃順順利利從甲地到乙地, 就可以很方便地解決各位的交通問題.

學習程式語言的目的也就是如此, 要讓各位未來的機械設計工程師可以很方便地解決可能遭遇到的運算問題, 這就與各位能夠合法安全操控各種交通工具的動機一樣, 各位想一想, 假如有一位同學或朋友, 未來幾年內不僅擁有普通機車與普通汽車的駕照, 而且經過層層關卡還通過計程車、大貨車、大客車的駕照, 甚至還擁有各型飛機與遊艇輪船的駕駛資格, 大家與他一起出遊, 該有多麼方便!!

因此這裡要將交通問題與運算問題來作為對比, 探討該如何進行.

從甲地騎車或開車到乙地的交通問題, 必須要同時兼顧安全才算數, 使用電腦來解決運算問題也是一樣, 透過網路將資料從甲地傳送資料到乙地, 也必須是安全地將資料送達, 否則就會白費工夫, 因此在程式語言一年的課程裏也會特別著重網路運算的安全問題, 沒有安全保證的資料傳送就如同騎車或開車不遵守規矩不提高警覺而無法安全抵達目的地一樣可怕.

以下舉幾個比較普通的電腦運算問題來突顯學習電腦程式語言的重要性:
    
幾十個人一起出遊分別用不同的手機或相機以不同的檔案規格與命名法則存下許多相片(幾百張、幾千張甚至更多), 當這些相片集合在同一台電腦硬碟後, 該如何進行處理, 使這些檔案具有格式統一的檔案格式與命名法則?

當然現在的年輕人幾乎都有臉書帳號, 假如將這些數位相片以批次的方式送到臉書伺服器, 就可以使用臉書所提供的各種相片分享與處理功能(例如標註相片中個人的資料與連結或進行特殊處理), 這就好像大家一起搭高鐵出遊所能享受到的便捷, 但是一旦下了高鐵, 到了市區後的交通問題, 高鐵可就無能為力的, 因此目前臉書所提供的各種免費協同資料處理功能, 並無法解決未來各位工程書所可能面臨的運算問題, 以上面的相片影像處理, 各位若具有程式語言中的影像處理能力, 就可以自行編寫電腦程式來解決這種問題.

除了影像檔案的處理問題, 機械設計工程師還會面臨 2D/3D 零組件建構、組合與分析的問題, 大多數的機械零組件繪圖與分析問題都能夠透過現有的商用電腦輔助機械設計套件處理(例如: SolidWorks, Inventor, Creo, NX 或 Catia), 但是就如何前面提到的數位運算問題與交通問題對比的說明, 這些大眾交通工具(大家可以將 SolidWork 與 Inventor 這些工具比擬成計程車, 非常方便但是要付出代價, 即便如此也無法取代各位的機車或自行車)並無法解決各位日常生活所面臨的交通問題, 還是有許多場合各位還是得歩行、騎自行車或機車才能到達目的地.

總而言之, 學習程式的目的就在於希望利用電腦的高速運算能力來解決各位未來所可能面臨的運算問題, 不具備直接且正確操控這些高速運算工具的工程師, 就如同有人很可能面對在校園裡從一棟大樓走到另一棟大樓這麼簡單的交通問題, 卻要呼叫計程車給載到高鐵站, 然後再從高鐵站轉搭接駁車到達市區火車站然後再用跑步到學校最後再爬進所要抵達的大樓目的地一樣離譜.

也就是說, 解決各位日常生活的交通問題, 大家幾乎都會找出最方便快捷且可行的方法, 而解決工程運算問題其實也是一樣, 各位只要具備運用電腦的正確知識, 熟習合用的程式語言, 就有機會面對各種工程運算問題時, 找到正確且可行的解決工具, 順利解決問題.

具備運用電腦的正確知識 - 必須要了解電腦基本的軟硬體運作原理.

熟習合用的程式語言 - 就如何了解各種交通工具的特性, 在適當的情況下選擇合用且能順利解決問題的工具.

面對各種工程運算問題的同時 - 必須具備解讀英文手冊(因為許多中高階套件在第一時間都只提供英文版手冊)、電腦程式回傳的回應訊息(大多原始訊息都是以英文編寫).

解決問題 - 工程師存在的目的是在解決問題, 絕非製造問題.</t>
<t tx="amd_yen.20130429214002.3978"></t>
<t tx="amd_yen.20130429221223.10895"></t>
<t tx="amd_yen.20130429221223.10934">#coding: utf-8
# MissingDialog ui 設計


@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="amd_yen.20130429221223.10935">from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)
</t>
<t tx="amd_yen.20130429221223.10936">class Ui_MissingDialog(object):
    @others
</t>
<t tx="amd_yen.20130429221223.10937">def setupUi(self, MissingDialog):
    MissingDialog.setObjectName(_fromUtf8("MissingDialog"))
    MissingDialog.resize(402, 136)
    self.label = QtGui.QLabel(MissingDialog)
    self.label.setGeometry(QtCore.QRect(20, 10, 91, 17))
    self.label.setObjectName(_fromUtf8("label"))
    self.missingValueslabel = QtGui.QLabel(MissingDialog)
    self.missingValueslabel.setGeometry(QtCore.QRect(20, 40, 321, 21))
    self.missingValueslabel.setText(_fromUtf8(""))
    self.missingValueslabel.setObjectName(_fromUtf8("missingValueslabel"))
    self.pushButton = QtGui.QPushButton(MissingDialog)
    self.pushButton.setGeometry(QtCore.QRect(170, 90, 71, 27))
    self.pushButton.setObjectName(_fromUtf8("pushButton"))

    self.retranslateUi(MissingDialog)
    QtCore.QMetaObject.connectSlotsByName(MissingDialog)
</t>
<t tx="amd_yen.20130429221223.10938">def retranslateUi(self, MissingDialog):
    MissingDialog.setWindowTitle(_translate("MissingDialog", "Missing Fields", None))
    self.label.setText(_translate("MissingDialog", "Missing Fields !!!", None))
    self.pushButton.setText(_translate("MissingDialog", "Ok", None))
</t>
<t tx="amd_yen.20130429221223.2317"></t>
<t tx="amd_yen.20130429221223.2319"></t>
<t tx="amd_yen.20130503085936.2410"></t>
<t tx="amd_yen.20130503185304.2957">以下示範如何在 KMOL Guide 的架構下, 新增一個節點用來產生第二本協同手冊

一本協同手冊的建立總共有三個部分

- 按鈕

用來執行 make html 與 make latex 以及最後的 xelatex 指令, 可以產生 html 與 pdf 格式的報告內容

按鈕的內容如下:

.. code-block:: python

    @language python
    import os
    pos = c.find_h("c2g1 report")[0]
    c.selectPosition(pos)
    c.k.simulateCommand('rst3')
    &lt;&lt; html manual &gt;&gt;
    &lt;&lt; pdf manual &gt;&gt;

必須要在 c.find_h() 中填入所要處理報告的標題, 這裡的範例標題為 c2g1 report, html 部分則需要修改 mandir = d.get('path') + "/c2g1", 指定處理目錄為 c2g1, pdf 部分除了指定文件原始目錄為 c2g1 外, 還需要告知 target_name = "index", 此一設定必須與 conf.py 中的 master_doc = 'index' 彼此對應.

- 設定檔案

共有三個, 包括 conf.py, toc 與 make.bat, conf.py 為 sphinx 的設定檔案, toc 則指定要加入哪些章節檔案, make.bat 則是實際執行 sphinx 指令的批次檔案.

conf.py 中重要的設定為:

_exts = "../exts"
extensions.append('chinese_search')
source_suffix = '.html.txt'
master_doc = 'index'
latex_documents = [
  ('index', 'index.tex', 'C2G1 使用者手冊',
   'Chiaming Yen', 'manual'),]

- 報告內容

報告內容分為兩類, 一類為單機上的資料, 以 @rst 節點導入後, 可以自動依照 Leo 節點從屬關係產生標題與內文, 第二類的報告內容則為由外部送入的檔案, 可以利用 @auto 節點指令將這些內容加入, 各外部檔案的名稱必須在 index.html.txt 中宣告.</t>
<t tx="amd_yen.20130503185304.2958">本檔案主要配合 portableKMOL 系統中的 MiKTeX(位於 portableKMOL\data\extensions\portableLatex 目錄下)與 Sphinx 系統進行文書處理.

Docutils, Sphinx 與 LaTeX 等都是排版系統, 可以將特定格式的標註文件轉換成操作者所希望的最後文檔結果, 這些文書處理的結果可能是 pdf, html, epub 或 chm (Microsoft Compiled HTML Help).</t>
<t tx="amd_yen.20130503185304.2959">許多人曾經浪費許多時間來比較 MicroSoft Word 與 LaTex, 但是千萬要記住, 這兩種產品或技術雖然都可用來處理文書資料, 但是直接比較其功能或優劣並不是很恰當, 簡單說 Word 是一套文書處理系統, 具有"所見即所得"的特性, 而 LaTeX 則是一套"排版程式", LaTeX 系統通常不具備文書編輯時就能"直接"看到文件處理的結果(也就是不具備"所見即所得"的特性).

排版系統是文書處理套件的核心, 就好像拿引擎(LaTeX)與汽車(Word)來比較哪一個是比較好的"交通工具", 並不是很恰當.

因此直接比較"文書處理套件"與"排版程式", 實在無法說明其特點, 只能將兩者的功能列出, 讓使用者在不同需求情境下, 選擇最適合的文書處理工具.

Word 文書處理套件的優勢在於文書內容編排時同時決定初步的文書"整體"格式, 因此具有所見即所得的文書編排結果, 讓使用者以最直覺的方式來處理文書列印後可能的結果. (上了車(Word) 就可以馬上啟動開車, 並且到處遊歷, 但是光拿一顆引擎(LaTeX) 哪裡都不能去, 只是可以先草擬"旅遊計畫", 再想辦法將這顆引擎作為動力來實現所草擬的"旅遊規劃")

LaTeX 排版系統則將文書處理流程切成幾個階段, 當使用者決定採用 LaTeX 進行文書排版後, 可以無需決定文書編排的"整體"格式, 但是仍然必須在局部內容使用 LaTeX 程式的語法(或指令)來編排文書內容, 例如, 輸入數學方程式需要採用特殊標註語法編寫, 特定段落的粗體或斜體文字也都有對應的 LaTeX 標註指令用法.

基本差別: Word 先初步決定整理文書處理格式, 隨後各階段也都可以局部或整體進行格式設定修改, 且在修改後分段執行處理運算, 因此操作流程將資料處理運算分割, 使用者在執行過程並不會覺得文書處理需要"電腦運算".

而 LaTeX 則是完全在資料準備初步時只局部利用特定的標註指令來編寫文書內容, 無論是一般文字、數學方程式或圖形的引用(甚或用指令產生圖檔), 其內容都是純文字資料(就好像在編寫"旅遊計畫"時很難感受到旅遊所可能帶來的快感:-), 也由於在內容準備過程, 沒有將內容資料處理成需要的最後格式編排.

因此就輸入而言, 操作 LaTeX 排版時間就花在輸入標註指令, 最後文書處理流程則是在內容準備完成後, 集中執行轉換運算, 因此許多使用者在用慣 Word 之後, 對於 LaTeX 排版系統需要執行編譯花費不少時間而覺得不可思議, 其實 Word 因為是將處理流程分割, 讓使用者在輸入內容時就決定"局部"或整體的格式, 並且馬上完成處理, 並且顯示出結果, 文書處理運算分散因此讓使用者感受不到轉換運算所花的時間, 但是若使用者要求 Word 自動產生目錄、索引或參考文件與內文參照等資料時, 其實與 LaTeX 排版系統一樣, 仍然必須綜觀全文後, 執行運算後才能產生所需的連結資料.

所以, Word 系統內部仍然有一套類似 LaTeX 的排版系統, 只不過並沒有將送入排版系統的"編排指令"全盤輸出給使用者, 也不允許(?)使用者直接以編寫"文書編排指令"的模式來操作 Word, 同樣道理, 假如在 LaTeX 排版系統的外部包裹一套使用者操作介面, 並且讓使用者在輸入局部內容時就決定局部或整體格式, 並且將處理運算結果及時顯示在文書處理區, 以達到"所見即所得"的文書處理結果, 其實也能夠做到類似 Word 的"簡單易用".

既然這樣, 以 LaTeX 為核心的 "Word" 為何從來就沒有出現過?主要原因可能因為 MicroSoft Word 所屬的 Office 套件, 在過去 30 年內, 無論是行銷或是功能都是世界一流, 而當年曾經擁抱 TeX 或 LaTeX 的電腦界尖兵, 現在大多已經是上了年紀的"待退或已退"老兵, 說說故事還可以, 要集中心力弄出一套能與 Word 抗衡的簡單易用套件, 可能並不容易:-)

而精通 TeX 或 LaTeX 相關編程技術的年輕人也並不是沒有, 但是大多被網際大公司網羅 (Google, Facebook 等) 或者正在創業 (github, dropbox, c9.io 等), 因此也無心與 MS 這這種大公司過不去, 另一個原因則是未來的戰場並非在單機而是在網際空間, 因此目前已經有不少採 LaTeX 的網際編輯器正在發展, 產品發展重點自然不會是類似 Word  的文書處理套件開發.

LaTex 適合用來:

- 執行多人協同文件編輯, 其中在個人產生內容資料的同時, 無需置入文件格式, 只要依循一定的編輯流程, 並且可以直接利用 github 或 bitbucket 等版次管理系統(適合純文字的資料檔案), 同步進行文件內容的編修(透過 fork 與 merge).

- 工程設計文件的編輯, 可以透過文字格式編輯修改數學方程式, 多人協同環境下更可以共享或協同管理相同格式的數學表示式.

- 進行同一基本內容但是輸出許多不同數位格式的出版需求, 例如: 同時出版不同編排模式(單欄位雙欄位), pdf, html, epub 等電子格式資料.

- 管理許多參考文獻的引用與列印編排時.

但是 LaTeX 仍具有下列缺點:

- 等同學習新程式語言來執行文書處理, 而且各種延伸套件眾多, 新手比較不容易入門

- 文書處理過程採用程式編譯流程, 若其中發生錯誤, 需要花時間逐一除錯
</t>
<t tx="amd_yen.20130503185304.2960"></t>
<t tx="amd_yen.20130503185304.2961"></t>
<t tx="amd_yen.20130503185304.2962">@language python

import os
'''
c is the commander of the outline containing the script.
g is Leo's leo.core.leoGlobals module.
p is the presently selected position, the same as c.p.
'''
d = c.scanAllDirectives(p)
#g.es(d)
# d 為 commander 由目前所在目錄進行指令設定掃描
# d 資料格式為 dictionary
''' 
實際操作下, d 為 
{'tabwidth': -4, 'lineending': None, 'language': 'python', 'encoding': None, 'pluginsList': [], 'pagewidth': 70, 'wrap': True, 'path': 'D:\\github\\mdeCourse\\2013spring', 'delims': ('#', '', '')}
'''
# 將目錄指到 latex
mandir = d.get('path') + "/c2wp/latex"
g.es(mandir)
os.chdir(mandir)
target_name = "ex1"
filename = target_name+".tex"
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
filename = target_name+".xdv"
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xdvipdfmx.exe -vv -E "+filename)

filename = target_name+".pdf"
os.system(filename)</t>
<t tx="amd_yen.20130503185304.2963">@language latex
&lt;&lt; document class &gt;&gt;
&lt;&lt; CJK &gt;&gt;
&lt;&lt; author title &gt;&gt;
&lt;&lt; verbatim &gt;&gt;
&lt;&lt; begin document &gt;&gt;
&lt;&lt; make title &gt;&gt;
@others
&lt;&lt; end document &gt;&gt;
</t>
<t tx="amd_yen.20130503185304.2972">This is my \emph{first} document prepared in \LaTeX.
This is my \emph{first} document prepared in \LaTeX. I typed it on \today.

\noindent We have seen that to typeset something in \LaTeX, we type in the
text to be typeset together with some \LaTeX\ commands.
Words must be separated by spaces (does not matter how many)
and lines maybe broken arbitrarily.
The end of a paragraph is specified by a \emph{blank line}
in the input. In other words, whenever you want to start a new
paragraph, just leave a blank line and proceed.

Carrots are good for your eyes, since they contain Vitamin A\@. Have
you ever seen a rabbit wearing glasses?

Carrots are good for your eyes, since they contain Vitamin A. Have
you ever seen a rabbit wearing glasses?

The numbers 1, 2, 3, etc.\ are called natural numbers. According to
Kronecker, they were made by God;all else being the works of Man.
I think \LaTeX is fun.
I think \LaTeX\ is fun.
Note the difference in right and left quotes in `single quotes'
and ``double quotes''.

Note the difference in right and left quotes in \lq single
quotes\rq\ and \lq\lq double quotes\rq\rq.
X-rays are discussed in pages 221--225 of Volume 3---the volume on
electromagnetic waves.
\`{E}l est\`{a} aqu\`{\i}
Maybe I have now learnt about 1\% of \LaTeX.
以下為特殊符號的輸入方法:以下為特殊符號的輸入方法
以下為特殊符號的輸入方法以下為特殊符號的輸入方法
以下為特殊符號的輸入方法以下為特殊符號的輸入方法
以下為特殊符號的輸入方法以下為特殊符號的輸入方法
以下為特殊符號的輸入方法
\textasciitilde  \&amp;
 \# \_
\$ \textbackslash
 \%  \{
\textasciicircum 
 \}
 
We can also give an optional argument to \\ to increase the vertical distance between the
lines. For example,
This is the first line.\\[10pt]
This is the second line

Now there is an extra 10 points of space between the lines (1point is about 1/72nd of an
inch).

\begin{center}
The \TeX nical Institute\\[.75cm]
Certificate 證書
\end{center}
\noindent This is to certify that Mr. N. O. Vice has undergone a
course at this institute and is qualified to be a \TeX nician.\\[.75cm]
\noindent 沒有錯, 這裡要證明他真的要下台了.

\begin{flushright}
The Director\\
The \TeX nical Institute
\end{flushright}

\rule{80mm}{.2pt}
% 要讓 fbox 可以旋轉, 必須要導入 graphicx package
\rotatebox{45}{\fbox{\LARGE{\LaTeX}}}\\[2cm]
\rotatebox{45}{\fbox{\LARGE{真的可以轉}}}
\rotatebox{225}{\fbox{\LARGE{真的可以轉}}}\\[2cm]

文字之間的數學

The equation $x + 2y = 3$ is a linear function,
its graph is a line.
The equation $y = (x-1)^2 + 2$ is a quadratic function,
its graph is a parabola.

The price of the 大爛書 textbook is \$500 NT dollars.

還有以下的數學符號

If the following limit exists:
$$
\lim_{\Delta x\to 0} \frac{f(x_0+\Delta x) - f(x_0)}{\Delta x}
$$
The limit is called {\it the derivative of $f(x)$ at $x_0$},
denoted by $f'(x)$.

準備要列舉

\begin{itemize}
\item Calculus
\item Linear Algebra
\item Basic Computer Concepts
\end{itemize}

還是要列舉

\begin{enumerate}
\item Calculus
\item Linear Algebra
\item Basic Computer Concepts
\end{enumerate}

也是來列舉

\begin{description}
\item [Calculus] Integration and Differentiation
\item [Linear Algebra] Vector space and Basis
\item [Basic Computer Concepts] Programming Language
\end{description}

自己定指令

\newcommand{\nfu}{國立虎尾小科技大學}

我們的學校就是 \nfu

% 要讓 Verbatim 發揮作用需要 \usepackage{fancyvrb} % for frame on Verbatim
% frame=single 會以四邊框起, 若以 frame=lines 會以最長程式為主
\begin{Verbatim}[frame=single, numbers=left]
# 請注意程式內縮
for i in range(4):
    print('Hello!')
    print("應該沒有問題")
\end{Verbatim}
</t>
<t tx="amd_yen.20130503185304.2973">這是第一行\\
這是第二行, 所以兩個反斜線就是強制跳行\\
\framebox [5cm][r]{這是裡面的字串}\\
\framebox [5cm][c]{這是裡面的字串}\\
\framebox [5cm][l]{這是裡面的字串}\\
{\centering
這些內容可以置中這些內容可以置中% 請注意下面一行空白非常重要, 否則無法讓 centering 執行

}

X  X\\
X\enspace  X\\
</t>
<t tx="amd_yen.20130503185304.2974"></t>
<t tx="amd_yen.20130503185304.2976"></t>
<t tx="amd_yen.20130503185304.2977">\end{document}
</t>
<t tx="amd_yen.20130503185304.2978">\maketitle
</t>
<t tx="amd_yen.20130503185304.2979">\begin{document}
</t>
<t tx="amd_yen.20130503185304.2980">% 為了讓 verbatim 註解中能夠加入中文, 採用 roman family 字體
\makeatletter
\def\verbatim@font{\rmfamily\small}
\makeatother
</t>
<t tx="amd_yen.20130503185304.2981">% 加入標題與作者資料, 然後在文章中的 maketitle 中才會顯示出來
\title{就是要學 \LaTeX}
\author{小作者 \and 大作者\footnote{小作者為大老師,
and 大作者為小學生.}}
\date{\today}
</t>
<t tx="amd_yen.20130503185304.2982">\usepackage{xeCJK}    %使用中文環境
\usepackage[T1]{fontspec}    %設定字體用
\usepackage{graphicx}
\usepackage{fancyvrb} % for frame on Verbatim
% 新細明體
% 文鼎ＰＬ新宋
\setCJKmainfont{新細明體}



</t>
<t tx="amd_yen.20130503185304.2983">% The first line \documentclass{article} tells LATEX that what we want to produce is an article.
% 假如要使用雙欄位
\documentclass[twocolumn]{article}
%\documentclass{article}
</t>
<t tx="amd_yen.20130503185304.2984">網際上的 LaTeX editor

http://jaxedit.com/</t>
<t tx="amd_yen.20130503185304.2985">http://asymptote.sourceforge.net/

https://github.com/memmett/PyAsy</t>
<t tx="amd_yen.20130503185304.2986">Leo calculates the home directory in leoApp.py, the method computeHomeDir.

core/leoApp.py 的修改:

因為在 Windows 中文環境下, cp950 若未宣告 encoding 為 utf-8, 存檔會有問題

第 3234 行:

theFile = open(fileName, encoding="utf-8")</t>
<t tx="amd_yen.20130503185304.2987">Scripts can reread @auto nodes with::

    at = c.atFileCommands 
    p = c.currentPosition() # get the current position 
    fileName = p.atAutoNodeName() 
    at.readOneAtAutoNode(fileName,p) 

and can reread @edit nodes with::
        
    at = c.atFileCommands
    p = c.currentPosition() # get the current position 
    fileName = p.atEditNodeName()
    at.readOneAtEditNode (fileName,p)
    
p = g.findNodeAnywhere(c,headline) and/or
p = g.findNodeInTree(c,p,headline)

p.headString() and  p.bodyString()</t>
<t tx="amd_yen.20130503185304.2988">@first &lt;?php
@first $comment = &lt;&lt;&lt;EOD
EOD;

// php code goes here.
echo "boogie";

$comment2 = &lt;&lt;&lt;EOD
@last EOD;
@last ?&gt;</t>
<t tx="amd_yen.20130503185304.2989">@delims /* */
Javascript stuff
@delims &lt;-- --&gt;
HTML stuff

或者

@first &lt;?php
@first /*
*/

echo "hi";

@delims /* */
@last ?&gt;</t>
<t tx="amd_yen.20130503185304.2990">def callback(*args,**keys):
    g.trace()

table = (("Test1",None,callback),)

c.frame.menu.createMenuItemsFromTable('File',table)

另外一個範例

def callback(*args,**keys):
    g.trace()

fileMenu = c.frame.menu.getMenu('File')

# 3 is the position in the menu.  Other kinds of indices are possible.
fileMenu.insert(3,'command',label='Test2',command=callback)</t>
<t tx="amd_yen.20130503185304.2991">The trick is to create a workflow that separates editing from testing. Putting test code in LeoPy.leo would waste a lot of time. To run tests you would have to exit Leo and reload LeoPy.leo. A much quicker way is to put all test code in a test.leo file. So to change and test code, do the following:

Save LeoPy.leo but do not exit Leo.
Quit the copy of Leo running test.leo, then reload test.leo.
Run test scripts from test.leo.
That’s all. Python will recompile any changed .py files in the new copy of Leo. Note: I create a batch file called t.bat that runs test.leo, so to the “edit-reload-test” cycle is just:

Control-S (in LeoPy.leo: saves the .leo file)
t (in a console window: runs test.leo, compiling all changed .py files as a side effect)
Control-E (in test.leo: runs the test script)
The benefits of the new workflow:

test.leo loads _much_ more quickly than LeoPy.leo does. This new approach can increase the speed of the edit-reload-test cycle by more than a factor of 10. Hitting Control-S, t, Control-E takes about 5 seconds.
LeoPy.leo runs with the old code, so it is much easier to fix syntax errors or exceptions in the new code: just fix the problem and save LeoPy.leo without closing LeoPy.leo, then restart test.leo. You run your tests on the new code, but you edit the new code with the old, stable code.
test.leo is the perfect place to develop test. I can create and organize those tests and when I am done, ‘’test.leo’’ is a log of my work.</t>
<t tx="amd_yen.20130503185304.2992">LaTeX 教學

http://web.mit.edu/texsrc/source/latex/lshort/src/</t>
<t tx="amd_yen.20130503185304.2993">\command[optinal parameter]{parameter}

Thus every LaTeX input file must start with the command
\documentclass{...}

文件類別指令:

\documentclass[options]{class}

以下則為可以選擇的文件類別:

article for articles in scientiﬁc journals, presentations, short reports, program documentation, invitations, . . .
proc a class for proceedings based on the article class.
minimal is as small as it can get. It only sets a page size and a base font. It
is mainly used for debugging purposes.
report for longer reports containing several chapters, small books, PhD
theses, . . .
book for real books
slides for slides. The class uses big sans serif letters. You might want to
consider using the Beamer class instead.

以下則為文件類別選項:

10pt, 11pt, 12pt Sets the size of the main font in the document. If no
option is speciﬁed, 10pt is assumed.
a4paper, letterpaper, . . . Deﬁnes the paper size. The default size is
letterpaper. Besides that, a5paper, b5paper, executivepaper,
and legalpaper can be speciﬁed.
fleqn Typesets displayed formulae left-aligned instead of centred.
leqno Places the numbering of formulae on the left hand side instead of
the right.
titlepage, notitlepage Speciﬁes whether a new page should be started
after the document title or not. The article class does not start a
new page by default, while report and book do.
onecolumn, twocolumn Instructs LATEX to typeset the document in one
column or two columns.
twoside, oneside Speciﬁes whether double or single sided output
should be generated. The classes article and report are single sided
and the book class is double sided by default. Note that this option
concerns the style of the document only. The option twoside does not
tell the printer you use that it should actually make a two-sided
printout.
landscape Changes the layout of the document to print in landscape
mode.
openright, openany Makes chapters begin either only on right hand
pages or on the next page available. This does not work with the
article class, as it does not know about chapters. The report class
by default starts chapters on the next page available and the book
class starts them on right hand pages.

特殊套件(package)指令:

\usepackage[options]{package}

以下則為 LaTeX 內建的套件:

doc Allows the documentation of LATEX programs.
exscale Provides scaled versions of the math extension font.
fontenc Speciﬁes which font encoding LATEX should use.
ifthen Provides commands of the form
‘if. . . then do. . . otherwise do. . . .’
latexsym To access the LATEX symbol font, you should use the latexsym
package.
makeidx Provides commands for producing indexes.
syntonly Processes a document without typesetting it.
inputenc Allows the specification of an input encoding such as ASCII, ISO
Latin-1, ISO Latin-2, 437/850 IBM code pages, Apple Macintosh, Next,
ANSI-Windows or user-defined one.

\documentclass{...} specifies what sort of document you intend to write. After that, add
commands to influence the style of the whole document, or load packages
that add new features to the LATEX system. To load such a package you use
the command

\usepackage{...}

When all the setup work is done, you start the body of the text with
the command

\begin{document}

Now you enter the text mixed with some useful LATEX commands. At
the end of the document you add the

\end{document}

以下則為典型的 .tex 檔案

\documentclass[a4paper,11pt]{article}
% define the title
\author{H.~Partl}
\title{Minimalism}
\begin{document}
% generates the title
\maketitle
% insert the table of contents
\tableofcontents
\section{Some Interesting Words}
Well, and here begins my lovely article.
\section{Good Bye World}
\ldots{} and here it ends.
\end{document}

有關 page style

LATEX supports three predeﬁned header/footer combinations—so-called page
styles. The style parameter of the

\pagestyle{style}

command defines which one to use. Table 1.4 lists the predfined page styles.

The Predefined Page Styles of LATEX.

plain prints the page numbers on the bottom of the page, in the middle of
the footer. This is the default page style.
headings prints the current chapter heading and the page number in the
header on each page, while the footer remains empty.
empty sets both the header and the footer to be empty.

It is possible to change the page style of the current page with the
command

\thispagestyle{style}

處理 LaTeX 時, 有關的檔案類型

.tex LATEX or TEX input file. Can be compiled with latex.
.sty LATEX Macro package. Load this into your LATEX document using the
\usepackage command.
.dtx Documented TEX. This is the main distribution format for LATEX style
files. If you process a .dtx file you get documented macro code of the
LATEX package contained in the .dtx file.
.ins The installer for the files contained in the matching .dtx file. If you
download a LATEX package from the net, you will normally get a .dtx
and a .ins file. Run LATEX on the .ins file to unpack the .dtx file.
.cls Class files define what your document looks like. They are selected
with the \documentclass command.
.fd Font description file telling LATEX about new fonts.
The following files are generated when you run LATEX on your input file:
.dvi Device Independent File. This is the main result of a LATEX compile
run. Look at its content with a DVI previewer program or send it to a
printer with dvips or a similar application.
.log Gives a detailed account of what happened during the last compiler
run.
.toc Stores all your section headers. It gets read in for the next compiler
run and is used to produce the table of content.
.lof This is like .toc but for the list of figures.
.lot And again the same for the list of tables.
.aux Another file that transports information from one compiler run to the
next. Among other things, the .aux file is used to store information
associated with cross-references.
.idx If your document contains an index. LATEX stores all the words that
go into the index in this file. Process this file with makeindex.
.ind The processed .idx file, ready for inclusion into your document on the
next compile cycle.
.ilg Logfile telling what makeindex did.

處理較大的專案

When working on big documents, you might want to split the input file into
several parts. LATEX has two commands that help you to do that.

\include{filename}

The second command can be used in the preamble. It allows you to
instruct LATEX to only input some of the \included files.

\includeonly{filename,filename,. . .}

After this command is executed in the preamble of the document, only
\include commands for the filenames that are listed in the argument of
the \includeonly command will be executed. Note that there must be no
spaces between the filenames and the commas.

The \include command starts typesetting the included text on a new
page. This is helpful when you use \includeonly, because the page breaks
will not move, even when some include files are omitted. Sometimes this
might not be desirable. In this case, use the

\input{filename}

command. It simply includes the file specified. No flashy suits, no strings
attached.

To make LATEX quickly check your document use the syntonly package.
This makes LATEX skim through your document only checking for proper
syntax and usage of the commands, but doesn’t produce any (DVI) output.
As LATEX runs faster in this mode you may save yourself valuable time. Usage
is very simple:

\usepackage{syntonly}
\syntaxonly</t>
<t tx="amd_yen.20130503185304.2994">\renewcommand\refname{參考文獻} % 針對 article
\renewcommand\bibname{參考文獻} % 針對 book
\renewcommand\contentsname{目錄}
\renewcommand\listfigurename{插圖目錄}
\renewcommand\listtablename{表格目錄}
\renewcommand\indexname{索引}
\renewcommand\figurename{圖}
\renewcommand\tablename{表}
\renewcommand\abstractname{摘要}
\renewcommand\partname{部}
\renewcommand\appendixname{附錄}</t>
<t tx="amd_yen.20130503185304.2995">\noindent\rule[-1ex]{\textwidth}{3pt}\\[2.0ex] %輸出一條橫線</t>
<t tx="amd_yen.20130503185304.2996">rST support within Leo used to be a plugin but is now a part of Leo's
core.  However, the documentation is still located in Chapter 14 of
Leo's User Guide (http://webpages.charter.net/edreamleo/
rstplugin3.html).  I use rST to create HTML files.  Maybe somebody
else can describe what needs to be done to output Latex files.

Note: The following text uses the code/compile analogy to describe the
use of rST.  I think it best reflects the operation being performed.
Others disagree.

The rST "code" (actually written in the "docutils" language) is placed
within a Leo node that has an "@rst" directive in the node's header.
For example: @rst MyLatexFile

The rST "code" will be stored inside the leo file.  If you prefer to
keep the "code" in a separate file then place the "@rst" node under a
"@thin" node.  For example:

   @thin MyLatexFile.tex
      @rst MyLatexFile

The rST "code" is "compiled" into an HTML or Latex file by issuing the
command: "c.rstCommands.rst3()".  The easiest way to do this is to
create a button in Leo by placing the following node structure in the
Leo outline (or better yet, place it in the outline of your
myLeoSettings.leo file).  You can open up the myLeoSettings.leo file
from the "Help" menu.

   @settings
      @button rst3

Place the "c.rstCommands.rst3()" text (without the quotes) in the body
of the "@button rst3 node".  Save the myLeoSettings.leo file and re-
open your leo file and you should see the button.  Select the @rst
node that you want to "compile" and select the "rst3" button.  This
will place the output file in a directory defined by rST's
"default_path" option.

The rst options are defined in the body of the "@rst MyLatexFile" node
or you can put them in an ancestor node.  See Chapter 14 of the User
Guide for a list of the options.

@ @rst-options
code_mode=False
show_doc_parts_in_rst_mode = False
generate_rst=True
show_organizer_nodes=False
show_headlines=False
show_leo_directives=True
write_intermediate_file = False
verbose=True
@c</t>
<t tx="amd_yen.20130503185304.2997"></t>
<t tx="amd_yen.20130503185304.2998">@language python
import os
pos = c.find_h("c2wp report")[0]
c.selectPosition(pos)
c.k.simulateCommand('rst3')
&lt;&lt; html manual &gt;&gt;
&lt;&lt; pdf manual &gt;&gt;

</t>
<t tx="amd_yen.20130503185304.2999">'''
c is the commander of the outline containing the script.
g is Leo's leo.core.leoGlobals module.
p is the presently selected position, the same as c.p.
'''
d = c.scanAllDirectives(p)
# d 為 commander 由目前所在目錄進行指令設定掃描
# d 資料格式為 dictionary
''' 
實際操作下, d 為 
{'tabwidth': -4, 'lineending': None, 'language': 'python', 'encoding': None, 'pluginsList': [], 'pagewidth': 70, 'wrap': True, 'path': 'D:\\github\\mdeCourse\\2013spring', 'delims': ('#', '', '')}
'''
mandir = d.get('path') + "/c2wp"
# 取出 d dictionary 中的 path 對應值 (也就是目前所在絕對目錄), 再加上 html, 因此 mandir 即為目前所在目錄下的 html 子目錄路徑
g.es(mandir) # 列出 html 子目錄路徑
os.chdir(mandir)  # 更換目錄到 html 子目錄
os.system('make html')  # 執行 make html
</t>
<t tx="amd_yen.20130503185304.3000"># you probably need to install several packages 
# to create pdf (e.g. jadetex)
mandir = d.get('path') + "/c2wp"
g.es(mandir)
os.chdir(mandir)
os.system('make latex')
os.chdir('_build/latex')
# 接下來要設法將 .tex 轉為 .pdf
target_name = "index"
filename = target_name+".tex"
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
filename = target_name+".xdv"
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xdvipdfmx.exe -vv -E "+filename)

#
#os.system(target_name.replace(".xdv", ".pdf"))
filename = target_name+".pdf"
os.system(filename)
#os.system('../../fixup.pl &lt; Leodocumentation.tex &gt; LeoDoc.tex')
#os.system('make LeoDoc.pdf')</t>
<t tx="amd_yen.20130503185304.3001"></t>
<t tx="amd_yen.20130503185304.3002"></t>
<t tx="amd_yen.20130503185304.3006"></t>
<t tx="amd_yen.20130503185304.3010"></t>
<t tx="amd_yen.20130503185304.3011">@language latex
% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}

% \pdfpagewidth 195mm
% \pdfpageheight 271mm
% \textwidth 6.0in
% \textheight 8.8in
% \oddsidemargin -0.1in
% \evensidemargin -0.1in

\textwidth 6.8in
\oddsidemargin -0.2in
\evensidemargin -0.3in

\usepackage{pdfpages}
\usepackage[BoldFont,CJKchecksingle]{xeCJK}

    \usepackage{fancyvrb}    % for frame on Verbatim
    \usepackage{fancyhdr}
    \usepackage[T1]{fontspec}    %設定字體用

\usepackage{float}
\usepackage{ccaption}
\usepackage{pifont}
% \usepackage{fancybox}
\usepackage{fontspec,xunicode,xltxtra}

\setsansfont{Times New Roman}
\setmainfont{Times New Roman}
\setmonofont{Times New Roman}
% 新細明體
% 文鼎ＰＬ新宋
% 文鼎ＰＬ明體U20-L
% 文鼎ＰＬ报宋二GBK
\setCJKsansfont[BoldFont={新細明體},ItalicFont={新細明體}]{新細明體}
\setCJKromanfont[BoldFont={新細明體},ItalicFont={新細明體}]{新細明體}
\setCJKmainfont[BoldFont={新細明體},ItalicFont={新細明體}]{新細明體}
\setCJKmonofont[BoldFont={新細明體},ItalicFont={新細明體}]{新細明體}

    \makeatletter
    \def\verbatim@font{\rmfamily\small}    %為了讓 verbatim 註解中能夠加入中文, 採用 roman family 字體
    \makeatother

\XeTeXlinebreaklocale "zh"    %讓中文自動換行
\XeTeXlinebreakskip = 0pt plus 1pt
\renewcommand{\baselinestretch}{1.3} 
\setcounter{tocdepth}{3}
\captiontitlefont{\small\sffamily}
\captiondelim{ - }
\renewcommand\today{\number\year年\number\month月\number\day日}
\makeatletter
\renewcommand*\l@subsection{\@dottedtocline{2}{2.0em}{4.0em}}
\renewcommand*\l@subsubsection{\@dottedtocline{3}{3em}{5em}}
\makeatother
\titleformat{\chapter}[display]
{\bfseries\Huge}
{\filleft \Huge 第 \hspace{2 mm} \thechapter \hspace{4 mm} 章}
{4ex}
{\titlerule
\vspace{1ex}%
\filright}
[\vspace{1ex}%
\titlerule]
%\definecolor{VerbatimBorderColor}{rgb}{0.2,0.2,0.2}
\definecolor{VerbatimColor}{rgb}{0.95,0.95,0.95}


\title{C2WP 使用者手冊}
\date{}
\release{1.0}
\author{Chiaming Yen}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{版次}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&amp;}
\def\PYGZlt{\char`\&lt;}
\def\PYGZgt{\char`\&gt;}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


\href{http://blog.kmol.info}{KMOL's home page}


\chapter{C2G1 報告}
\label{frontmatter:kmol-s-users-guide}\label{frontmatter::doc}\label{frontmatter:c2g1}
\index{C2G1 報告}\setbox0\vbox{
\begin{minipage}{0.95\linewidth}
\textbf{Contents}

\medskip

\begin{itemize}
\item {} 
{\hyperref[frontmatter:c2g1]{C2G1 報告}}
\begin{itemize}
\item {} 
{\hyperref[frontmatter:id1]{前言}}

\item {} 
{\hyperref[frontmatter:latex]{數學方程式(LaTeX)}}

\item {} 
{\hyperref[frontmatter:id2]{圖形}}

\item {} 
{\hyperref[frontmatter:rest]{數學(rest)}}

\item {} 
{\hyperref[frontmatter:id3]{參考資料}}

\end{itemize}

\end{itemize}
\end{minipage}}
\begin{center}\setlength{\fboxsep}{5pt}\shadowbox{\box0}\end{center}


\section{前言}
\label{frontmatter:id1}
\begin{center}有關文書處理
\end{center}
雙欄位編排
documentclass{[}11pt,twocolumn{]}\{article\}


\section{數學方程式(LaTeX)}
\label{frontmatter:latex}\chapter{數學方程式排版}

\begin{intro}
  Now you are ready! In this chapter, we will attack the main strength
  of \TeX{}: mathematical typesetting. But be warned, this chapter
  only scratches the surface. While the things explained here are
  sufficient for many people, don't despair if you can't find a
  solution to your mathematical typesetting needs here. It is highly likely
  that your problem is addressed in \AmS-\LaTeX{}%
  \footnote{The \emph{American Mathematical Society} has produced a
  powerful extension to \LaTeX{}. Many of the examples in this
  chapter make use of this extension. It is provided with all recent
  \TeX{} distributions. If yours is missing it, go to \texttt{CTAN:/tex-archive/macros/latex/required/amslatex}.}
\end{intro}

\section{General}

\LaTeX{} has a special mode for typesetting \wi{mathematics}. Mathematics
can be typeset inline within a paragraph, or the paragraph can be broken to
typeset it separately. Mathematical text \emph{within} a paragraph is entered between \ci{(}
and \ci{)}, \index{$@\texttt{\$}} %$
between \texttt{\$} and \texttt{\$}, or between %}
\verb|\begin{|\ei{math}\verb|}| and \verb|\end{math}|.\index{formulae}
\begin{example}
Add $a$ squared and $b$ squared
to get $c$ squared. Or, using
a more mathematical approach:
$c^{2}=a^{2}+b^{2}$
\end{example}
\begin{example}
\TeX{} is pronounced as
\(\tau\epsilon\chi\).\\[6pt]
100~m$^{3}$ of water\\[6pt]
This comes from my
\begin{math}\heartsuit\end{math}
\end{example}

When you want your larger mathematical equations or formulae to be set apart
from the rest of the paragraph, it is preferable to \emph{display} them,
rather than to break the paragraph apart.
To do this, you can either enclose them
in \ci{[} and \ci{]}, or between
\verb|\begin{|\ei{displaymath}\verb|}| and
\verb|\end{displaymath}|.
\begin{example}
Add $a$ squared and $b$ squared
to get $c$ squared. Or, using
a more mathematical approach:
\begin{displaymath}
c^{2}=a^{2}+b^{2}
\end{displaymath}
or you can type less with:
\[a+b=c\]
\end{example}
If you want \LaTeX{} to enumerate your equations, you can use the
\ei{equation} environment.
You can then \ci{label} an equation number and refer to it somewhere else in the
text by using \ci{ref} or \ci{eqref}:
\begin{example}
\begin{equation} \label{eq:eps}
\epsilon &gt; 0
\end{equation}
From (\ref{eq:eps}), we gather
\ldots{}From \eqref{eq:eps} we
do the same.
\end{example}

Note the difference in typesetting style between equations that are typeset and those
that are displayed:

\begin{example}
$\lim_{n \to \infty}
\sum_{k=1}^n \frac{1}{k^2}
= \frac{\pi^2}{6}$
\end{example}
\begin{example}
\begin{displaymath}
\lim_{n \to \infty}
\sum_{k=1}^n \frac{1}{k^2}
= \frac{\pi^2}{6}
\end{displaymath}
\end{example}



There are differences between \emph{math mode} and \emph{text mode}. For
example, in \emph{math mode}:

\begin{enumerate}

\item Most spaces and line breaks do not have any significance, as all spaces
are either derived logically from the mathematical expressions, or
have to be specified with special commands such as \ci{,}, \ci{quad} or
\ci{qquad}.

\item Empty lines are not allowed. Only one paragraph per formula.

\item Each letter is considered to be the name of a variable and will be
typeset as such. If you want to typeset normal text within a formula
(normal upright font and normal spacing) then you have to enter the
text using the \verb|\textrm{...}| commands.
\end{enumerate}
\begin{example}
\begin{equation}
\forall x \in \mathbf{R}:
\qquad x^{2} \geq 0
\end{equation}
\end{example}
\begin{example}
\begin{equation}
x^{2} \geq 0\qquad
\textrm{for all }x\in\mathbf{R}
\end{equation}
\end{example}


%
% Add AMSSYB Package ... Blackboard bold .... R for realnumbers
%
Mathematicians can be very fussy about which symbols are used:
it would be conventional here to use `\wi{blackboard bold}',
\index{bold symbols} which is obtained using \ci{mathbb} from the
package \pai{amsfonts} or \pai{amssymb}.
\ifx\mathbb\undefined\else
The last example becomes
\begin{example}
\begin{displaymath}
x^{2} \geq 0\qquad
\textrm{for all }x\in\mathbb{R}
\end{displaymath}
\end{example}
\fi

\section{Grouping in Math Mode}

Most math mode commands act only on the next character, so if you
want a command to affect several characters, you have to group them
together using curly braces: \verb|{...}|.
\begin{example}
\begin{equation}
a^x+y \neq a^{x+y}
\end{equation}
\end{example}

\section{圖形}
\label{frontmatter:id2}%Version Aug 93    cgl@risc1.rug.nl
\noindent
       \setlength{\unitlength}{3.8ex}
\begin{picture}(14,15.6)(-.5, -2.5)
%1st column
\put(1, 0){\line(0, 1){1.5}}
\put(1, 2){\oval(2, 1)}
\put(1, 2){\makebox(0, 0){\texttt{.pk}}}
\put(1, 4){\vector(0, -1){1.5}}
\put(-.5, 4){\framebox(3, 1){METAfont}}
\put(1, 6.5){\vector(0, -1){1.5}}
\put(1,7){\oval(2, 1)}
\put(1, 7){\makebox(0, 0){\texttt{.mf}}}
%second column
\put(7.5, -.5){\framebox(2, 1){driver}}
\put(9.75, .75){\line(-1, 0){1.25}}
\put(9.75, .75){\line( 0, -1){.5}}
\put(9.75, .25){\line(-1, 0){.25}}
\put(9.85, .23){{\tiny \texttt{dvips}}}
\put(10, 1){\line(-1, 0){1.25}}
\put(10, 1){\line( 0, -1){.5}}
\put(10, .5){\line(-1, 0){.25}}
\put(8.75, 1){\line( 0, -1){.25}}
\put(10.1, .63){{\tiny \texttt{xdvi}}}
\put(10.1, 1.1){\hbox{.}\kern.1ex\raise.5ex\hbox{.}\kern.1ex\raise1ex\hbox{.}}
\put(8.5, 1.5){\vector(0, -1){1}}
\put(8.5, 2){\oval(2, 1)}
\put(8.5, 2){\makebox(0, 0){\texttt{.dvi}}}
\put(8.5, 4){\vector(0, -1){1.5}}
\put(7.5, 4){\framebox(2, 1){\TeX}}
%Plain
\put(9.75, 5.25){\line(-1, 0){1.25}}
\put(9.75, 5.25){\line( 0, -1){.5}}
\put(9.75, 4.75){\line(-1, 0){.25}}
\put(9.8, 4.68){{\tiny Plain}}
%LaTeX
\put(10, 5.5){\line(-1, 0){1.25}}
\put(10, 5.5){\line( 0, -1){.5}}
\put(10, 5){\line(-1, 0){.25}}
\put(8.75, 5.5){\line( 0, -1){.25}}
\put(10.1, 4.95){{\tiny \LaTeXe}}
\put(10.25, 5.75){\line(-1, 0){1.25}}
\put(10.25, 5.75){\line( 0, -1){.5}}
\put(10.25, 5.25){\line(-1, 0){.25}}
\put(9, 5.75){\line( 0, -1){.25}}
\put(10.35, 5.4){{\tiny AMS-Package}}
%
\put(10.35, 5.85){\hbox{.}\kern.1ex
\raise.5ex\hbox{.}\kern.1ex\raise1ex\hbox{.}}
%
\put(8.5, 6.5){\vector(0, -1){1.5}}
\put(8.5, 7){\oval(2, 1)}
\put(8.5, 7){\makebox(0, 0){\texttt{.tex}}}
%
\multiput(8.5, 9)(0, -.415){3}{\line(0, -1){.25}}
\put(8.5, 8.7){\vector(0, 1){.3}}
\put(8.5, 7.8){\vector(0, -1){.3}}
\put(7.5, 9){\framebox(2, 1){editor}}
%Spelling checker
\put(9.75, 10.25){\line(-1, 0){1.25}}
\put(9.75, 10.25){\line( 0, -1){.5}}
\put(9.75, 9.75){\line(-1, 0){.25}}
\put(9.85, 9.75){{\tiny \texttt{emacs}}}
%Style checker
\put(10, 10.5){\line(-1, 0){1.25}}
\put(10, 10.5){\line( 0, -1){.5}}
\put(10, 10){\line(-1, 0){.25}}
\put(8.75, 10.5){\line( 0, -1){.25}}
\put(10.1, 10){{\tiny \texttt{ispell}}}
%
\put(10.1, 10.6){\hbox{.}\kern.1ex
\raise.5ex\hbox{.}\kern.1ex\raise1ex\hbox{.}}
%
\put(8.5, 11.5){\vector(0, -1){1.5}}
\put(8.5, 12){\oval(2, 1)}
\put(8.5, 12){\makebox(0, 0){copy}}
%basis
\put(1, 0){\vector(1, 0){6.5}}
\put(9.5, 0){\vector(1, 0){2}}
\put(11.5, -.75){\framebox(2, 1.5){}}
\put(11.70, -.4){\shortstack{\small printer\\\small screen}}
%middle
\multiput(5, 5.25)(0, 1){3}{\line(0,1){.5}}
\multiput(5,  .25)(0, 1){4}{\line(0,1){.5}}
\multiput(5, -1.75)(0, 1.3){2}{\line(0,1){.2}}
%
\put(3.5, -1.250){\dashbox{.25}(3, .5){{\tiny \textsc{PostScript}}}}
\multiput(6.5, -1)(.45, 0){4}{\line(1,0){.25}}
\put(8.5, -1){\line( -1, 0){.2}}
%
\put(8.5, -1){\vector(0, 1){.5}}
\put(2.5, 4.5){\vector(1, 0){1.5}}
\put(5, 4.5){\oval(2, 1)}
\put(5, 4.5){\makebox(0, 0){\texttt{.tfm}}}
\put(6, 4.5){\vector(1, 0){1.5}}
\put(9.5, 4.5){\vector(1, 0){2}}
\put(12.5, 4.5){\oval(2, 1)}
\put(12.5, 4.5){\makebox(0, 0){\texttt{.log}}}
%base line
\put(.51,-1.75){\vector(-1, 0){1}}
\put(2.25, -1.75){\makebox(0, 0){Fonts}}
\put(3.9,-1.75){\vector( 1, 0){1}}
\put(6.1,-1.75){\vector(-1, 0){1}}
\put(9, -1.75){\makebox(0, 0){Typesetting}}
\put(12.4,-1.75){\vector(1, 0){1}}
\end{picture}

\section{數學(rest)}
\label{frontmatter:rest}
以下為數學式:
\begin{gather}
\begin{split}E_r^2 - |\boldsymbol{p}|^2 c^2 &amp;= m_0^2 c^4 \\
E_r^2 - (pc)^2 &amp;= (m_0 c^2)^2\end{split}\notag
\end{gather}
或者
\begin{gather}
\begin{split}E_r = \sqrt{(m_0 c^2)^2 + (pc)^2}\end{split}\notag
\end{gather}
至於文章中的數學符號用法:

Here the $(pc)^2$ term represents the square of the Euclidean norm (total vector length) of the various momentum vectors in the system, which reduces to the square of the simple momentum magnitude, if only a single particle is considered. This equation reduces to {\color{red}\bfseries{}\textbar{}E=mc²\textbar{}} when the momentum term is zero. For photons where $\boldsymbol{m_0 = 0}$, the equation reduces to $\boldsymbol{E_r = pc}$.
\begin{gather}
\begin{split}E_k = m_0(\gamma-1)c^2 = \frac{m_0 c^2}{\sqrt{1 - \frac{v^2}{c^2}}} - {m_0 c^2},\end{split}\notag
\end{gather}
with {\color{red}\bfseries{}\textbar{}v\textbar{}} the velocity, $m_0$ the rest mass, and \(\gamma\) the Lorentz factor.

He included the second term on the right to make sure that for small velocities, the energy would be the same as in classical mechanics:
\begin{gather}
\begin{split}E_k = \frac{1}{2} m_0 v^2 + \cdots.\end{split}\notag
\end{gather}
Without this second term, there would be an additional contribution in the energy when the particle is not moving.

Einstein found that the total momentum of a moving particle is:
\begin{gather}
\begin{split}P = \frac{m_0 v}{\sqrt{1-\frac{v^2}{c^2}}}.\end{split}\notag
\end{gather}
and it is this quantity which is conserved in collisions. The ratio of the momentum to the velocity is the relativistic mass, {\color{red}\bfseries{}\textbar{}m\textbar{}}:
\begin{gather}
\begin{split}m = \frac{m_0}{\sqrt{1-\frac{v^2}{c^2}}}\end{split}\notag
\end{gather}
and the relativistic mass and the relativistic kinetic energy are related by the formula:
\begin{gather}
\begin{split}E_k = {m c^2} - {m_0 c^2}.\end{split}\notag
\end{gather}
Einstein wanted to omit the unnatural second term on the right-hand side, whose only purpose is to make the energy at rest zero, and to declare that the particle has a total energy which obeys:
\begin{gather}
\begin{split}E = mc^2\end{split}\notag
\end{gather}
which is a sum of the rest energy $m_0 c^2$ and the kinetic energy. This total energy is mathematically more elegant, and fits better with the momentum in relativity. But to come to this conclusion, Einstein needed to think carefully about collisions. This expression for the energy implied that matter at rest has a huge amount of energy, and it is not clear whether this energy is physically real, or just a mathematical artifact with no physical meaning.

In a collision process where all the rest-masses are the same at the beginning as at the end, either expression for the energy is conserved. The two expressions only differ by a constant which is the same at the beginning and at the end of the collision. Still, by analyzing the situation where particles are thrown off a heavy central particle, it is easy to see that the inertia of the central particle is reduced by the total energy emitted. This allowed Einstein to conclude that the inertia of a heavy particle is increased or diminished according to the energy it absorbs or emits.


\section{參考資料}
\label{frontmatter:id3}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Contents: The Bibliography
% File: biblio.tex (lshort2e.tex)
% $Id: biblio.tex,v 1.1.1.1 2002/02/26 10:04:20 oetiker Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{thebibliography}{99}
% 因為會自動加上 \bibname, 因此蓋掉下列重複的 \bibname
%\addcontentsline{toc}{chapter}{\bibname}
\bibitem{manual} Leslie Lamport.  \newblock \emph{{\LaTeX:} A Document
    Preparation System}.  \newblock Addison-Wesley, Reading,
  Massachusetts, second edition, 1994, ISBN~0-201-52983-1.

\bibitem{texbook} Donald~E. Knuth.  \newblock \textit{The \TeX{}book,}
  Volume~A of \textit{Computers and Typesetting}, Addison-Wesley,
  Reading, Massachusetts, second edition, 1984, ISBN~0-201-13448-9.

\bibitem{companion} Michel Goossens, Frank Mittelbach and Alexander
  Samarin.  \newblock \emph{The {\LaTeX} Companion}.  \newblock
  Addison-Wesley, Reading, Massachusetts, 1994, ISBN~0-201-54199-8.

\bibitem{local} Each \LaTeX{} installation should provide a so-called
  \emph{\LaTeX{} Local Guide}, which explains the things that are
  special to the local system.  It should be contained in a file called
  \texttt{local.tex}. Unfortunately, some lazy sysops do not provide such a
  document. In this case, go and ask your local \LaTeX{} guru for help.

\bibitem{usrguide} \LaTeX3 Project Team.  \newblock \emph{\LaTeXe~for
    authors}.  \newblock Comes with the \LaTeXe{} distribution as
  \texttt{usrguide.tex}.

\bibitem{clsguide} \LaTeX3 Project Team.  \newblock \emph{\LaTeXe~for
    Class and Package writers}.  \newblock Comes with the \LaTeXe{}
  distribution as \texttt{clsguide.tex}.

\bibitem{fntguide} \LaTeX3 Project Team.  \newblock \emph{\LaTeXe~Font
    selection}.  \newblock Comes with the \LaTeXe{} distribution as
  \texttt{fntguide.tex}.

\bibitem{graphics} D.~P.~Carlisle.  \newblock \emph{Packages in the
    `graphics' bundle}.  \newblock Comes with the `graphics' bundle as
  \texttt{grfguide.tex}, available from the same source your \LaTeX{}
  distribution came from.

\bibitem{verbatim} Rainer~Sch\"opf, Bernd~Raichle, Chris~Rowley.
\newblock \emph{A New Implementation of \LaTeX's verbatim
  Environments}.
 \newblock Comes with the `tools' bundle as
  \texttt{verbatim.dtx}, available from the same source your \LaTeX{}
  distribution came from.

\bibitem{catalogue} Graham~Williams.  \newblock \emph{The TeX
    Catalogue} is a very complete listing of many \TeX{} and \LaTeX{}
    related packages.
  \newblock Available online from \texttt{CTAN:/tex-archive/help/Catalogue/catalogue.html}

\bibitem{eps} Keith~Reckdahl.  \newblock \emph{Using EPS Graphics in
    \LaTeXe{} Documents}, which explains everything and much more than
  you ever wanted to know about EPS files and their use in \LaTeX{}
  documents.  \newblock Available online from
  \texttt{CTAN:/tex-archive/info/epslatex.ps}

\bibitem{xy-pic} Kristoffer H. Rose
  \newblock \emph{\Xy-pic User's Guide}.  \newblock
  Downloadable from CTAN with \Xy-pic distribution

\end{thebibliography}


%

% Local Variables:
% TeX-master: "lshort2e"
% mode: latex
% mode: flyspell
% End:

\chapter{這是 outside 標題}
\label{fromoutside::doc}\label{fromoutside:outside}
\index{outside 標題}\setbox0\vbox{
\begin{minipage}{0.95\linewidth}
\textbf{Contents}

\medskip

\begin{itemize}
\item {} 
{\hyperref[fromoutside:outside]{這是 outside 標題}}
\begin{itemize}
\item {} 
{\hyperref[fromoutside:id1]{小標題}}

\item {} 
{\hyperref[fromoutside:id2]{小標題2}}

\end{itemize}

\end{itemize}
\end{minipage}}
\begin{center}\setlength{\fboxsep}{5pt}\shadowbox{\box0}\end{center}

以下就是 outside 的內容, 由某一位組員負責編寫

這是外部的檔案, 來自外部的內容

這是第二次從外部更新的檔案


\section{小標題}
\label{fromoutside:id1}
這是小標題之後的內容, 假如希望從網際系統取得組員的 frontouside.html.txt, 可以透過 CMSimple 的 upload 機制.


\section{小標題2}
\label{fromoutside:id2}
這是小標題2之後的內容, 經過 sphinx 處理後的 html 目錄則可以利用 mongoose 或 nginx 派送到網站上, 也可以將 html 目錄中的內容轉送到雲端網站中.

以下嘗試由 literalinclude 導入程式碼:

\begin{Verbatim}[commandchars=\\\{\}]
\# -*- coding: utf-8 -*-
\# 配合程式所使用的 @asis 會將資料存在 .leo 檔案
\# 建立虛擬的班級人員名單
import random
import string
學號碼數 = 4
姓名字數 = 3
姓氏檔案 = "lastname.txt"
名字檔案 = "firstname.txt"
學生人數 = [53, 55]
\# 讀進姓氏檔案與名字檔案
各班學生人數=random.randint(學生人數[0], 學生人數[1])
def makeNumber(學號碼數):
    return ''.join([random.choice(string.digits) for 索引 in range(學號碼數)])

開啟姓氏檔案 = open(姓氏檔案, "r", encoding="utf-8")
姓氏 = 開啟姓氏檔案.readlines()
開啟名字檔案 = open(名字檔案, "r", encoding="utf-8")
學員檔案 = open("虛設學員.txt","w",encoding='utf-8')
名字 = 開啟名字檔案.readlines()
科系碼 = makeNumber(學號碼數)
for 索引 in range(1, 各班學生人數):
    if(len(str(索引)) == 1):
        學號 = "0" + str(索引)
    else:
        學號 = str(索引)
    \# 設法製造缺號
    if random.randint(0, 100) \textgreater{} 3 :
        姓 = 姓氏[0][random.randint(0, len(姓氏[0])-1)]
        名 = 名字[0][random.randint(0, len(名字[0])-1)]
        名 += 名字[0][random.randint(0, len(名字[0])-1)]
        print("90"+科系碼+學號+" "+姓+名)
        學員檔案.write("90"+科系碼+學號+" "+姓+名+"\PYGZbs{}n")

開啟姓氏檔案.close()
開啟名字檔案.close()
學員檔案.close()

'''

以下為 lastname.txt 的內容:

趙錢孫李周吳鄭王馮陳褚衛蔣沈韓楊朱秦尤許何呂施張孔曹嚴華金魏陶薑
戚謝鄒喻柏水竇章雲蘇潘葛奚範彭郎魯韋昌馬苗鳳花方俞任袁柳酆鮑史唐
費廉岑薛雷賀倪湯滕殷羅畢郝鄔安常樂於時傅皮卞齊康伍餘元蔔顧孟平黃
和穆蕭尹姚邵湛汪祁毛禹狄米貝明臧計伏成戴談宋茅龐熊紀舒屈項祝董梁
杜阮藍閔席季麻強賈路婁危江童顏郭梅盛林刁鍾徐邱駱高夏蔡田樊胡淩霍
虞萬支柯昝管盧莫柯房裘繆幹解應宗丁宣賁鄧鬱單杭洪包諸左石崔吉鈕龔
程嵇邢滑裴陸榮翁荀羊于惠甄曲家封芮羿儲靳汲邴糜松井段富巫烏焦巴弓
牧隗山穀車侯宓蓬全郗班仰秋仲伊宮甯仇欒暴甘鈄曆戎祖武符劉景詹束龍
葉幸司韶郜黎薊溥印宿白懷蒲邰從鄂索鹹籍賴卓藺屠蒙池喬陽鬱胥能蒼雙
聞莘党翟譚貢勞逄姬申扶堵冉宰酈雍卻璩桑桂濮牛壽通邊扈燕冀浦尚農溫
別莊晏柴瞿閻充慕連茹習宦艾魚容向古易慎戈廖庾終暨居衡步都耿滿弘匡
國文寇廣祿闕東歐殳沃利蔚越夔隆師鞏厙聶晁勾敖融冷訾辛闞那簡饒空曾
毋沙乜養鞠須豐巢關蒯相查後荊紅

以下為 firstname.txt 的內容:

平燦惠歡佩泰州江揚剛乃屏珊易吟定小其菱幼函琴青博兆菁重立呈然永奕
漢義萍皓力昌妍合仲佳虹慧蓮恭石展軒啟奇秀駿晉冰政綸丹邦大冠貞生思
玄威嘉依音雲英能緯彬妙聖協法瑞恆采心友昀花樺航玫宛順儀寶婷書妮胤
彥修火雨俞孝蕙允城盈家陽琳阿紹誠倫亨星美和予念鳳凱松幸凡雯士達泓
金瑜勇必珍芷岳鈺方琬成霞麟致哲台睿賢珠瑩南克為尹妤春怡亮伯喬夫昕
亞真喜初愛清禮斌吉淳百臻寧以筠諭仕子文雅郁柏秋蓉伸福劭木宗傑丞昭
芝弘宇明月峰東聿登左祥迪蘭佑甫雄俊之卉谷玲禾茹榮堯芬姍少謙琇禎蘋
年姵勳任信旭燕苓豐惟盛發齊介芳容于維侑舜洋璇茂芃伊玉海建季雪柔汝
千富男新昱人添群欣綠馨利宜堅意名右姿智韻典竹巧坤可全潔裕毓孜仁韋
慈志琦宣希云茜辛薇梅樂妏嬌安上仰長承旺珮良鑫桓瑋光貴茵憲品綺芸天
源娟輝君銘夙來昇如泉正廷峻瑤恬靖淑瑄行秉伶康水羽治妹宥夢映霖儒枝
沛香皇一龍興延翰山卿白忠恩亭俐孟均元凌又偉強育辰萱鴻宸亦娥振中紫
倩民隆善玟紋杰旻學若華豪湖帆恒佐桂蓁穎軍德財庭琪世林純岑原尚昆妃
宏
'''
\end{Verbatim}


\chapter{這是 collaboration3 標題}
\label{collaboration3::doc}\label{collaboration3:collaboration3}
\index{outside 標題}\setbox0\vbox{
\begin{minipage}{0.95\linewidth}
\textbf{Contents}

\medskip

\begin{itemize}
\item {} 
{\hyperref[collaboration3:collaboration3]{這是 collaboration3 標題}}
\begin{itemize}
\item {} 
{\hyperref[collaboration3:id1]{小標題}}

\item {} 
{\hyperref[collaboration3:id2]{小標題2}}

\end{itemize}

\end{itemize}
\end{minipage}}
\begin{center}\setlength{\fboxsep}{5pt}\shadowbox{\box0}\end{center}

若檔案未關閉, 必須要 refresh from outside

以下就是 outside 的內容, 由某一位組員負責編寫

這是外部的檔案, 來自外部的內容

這是第二次從外部更新的檔案


\section{小標題}
\label{collaboration3:id1}
這是小標題之後的內容, 假如希望從網際系統取得組員的 frontouside.html.txt, 可以透過 CMSimple 的 upload 機制.


\section{小標題2}
\label{collaboration3:id2}
這是小標題2之後的內容, 經過 sphinx 處理後的 html 目錄則可以利用 mongoose 或 nginx 派送到網站上, 也可以將 html 目錄中的內容轉送到雲端網站中.

以下嘗試由 literalinclude 導入程式碼:

\begin{Verbatim}[commandchars=\\\{\}]
\# -*- coding: utf-8 -*-
\# 配合程式所使用的 @asis 會將資料存在 .leo 檔案
\# 建立虛擬的班級人員名單
import random
import string
學號碼數 = 4
姓名字數 = 3
姓氏檔案 = "lastname.txt"
名字檔案 = "firstname.txt"
學生人數 = [53, 55]
\# 讀進姓氏檔案與名字檔案
各班學生人數=random.randint(學生人數[0], 學生人數[1])
def makeNumber(學號碼數):
    return ''.join([random.choice(string.digits) for 索引 in range(學號碼數)])

開啟姓氏檔案 = open(姓氏檔案, "r", encoding="utf-8")
姓氏 = 開啟姓氏檔案.readlines()
開啟名字檔案 = open(名字檔案, "r", encoding="utf-8")
學員檔案 = open("虛設學員.txt","w",encoding='utf-8')
名字 = 開啟名字檔案.readlines()
科系碼 = makeNumber(學號碼數)
for 索引 in range(1, 各班學生人數):
    if(len(str(索引)) == 1):
        學號 = "0" + str(索引)
    else:
        學號 = str(索引)
    \# 設法製造缺號
    if random.randint(0, 100) \textgreater{} 3 :
        姓 = 姓氏[0][random.randint(0, len(姓氏[0])-1)]
        名 = 名字[0][random.randint(0, len(名字[0])-1)]
        名 += 名字[0][random.randint(0, len(名字[0])-1)]
        print("90"+科系碼+學號+" "+姓+名)
        學員檔案.write("90"+科系碼+學號+" "+姓+名+"\PYGZbs{}n")

開啟姓氏檔案.close()
開啟名字檔案.close()
學員檔案.close()

'''

以下為 lastname.txt 的內容:

趙錢孫李周吳鄭王馮陳褚衛蔣沈韓楊朱秦尤許何呂施張孔曹嚴華金魏陶薑
戚謝鄒喻柏水竇章雲蘇潘葛奚範彭郎魯韋昌馬苗鳳花方俞任袁柳酆鮑史唐
費廉岑薛雷賀倪湯滕殷羅畢郝鄔安常樂於時傅皮卞齊康伍餘元蔔顧孟平黃
和穆蕭尹姚邵湛汪祁毛禹狄米貝明臧計伏成戴談宋茅龐熊紀舒屈項祝董梁
杜阮藍閔席季麻強賈路婁危江童顏郭梅盛林刁鍾徐邱駱高夏蔡田樊胡淩霍
虞萬支柯昝管盧莫柯房裘繆幹解應宗丁宣賁鄧鬱單杭洪包諸左石崔吉鈕龔
程嵇邢滑裴陸榮翁荀羊于惠甄曲家封芮羿儲靳汲邴糜松井段富巫烏焦巴弓
牧隗山穀車侯宓蓬全郗班仰秋仲伊宮甯仇欒暴甘鈄曆戎祖武符劉景詹束龍
葉幸司韶郜黎薊溥印宿白懷蒲邰從鄂索鹹籍賴卓藺屠蒙池喬陽鬱胥能蒼雙
聞莘党翟譚貢勞逄姬申扶堵冉宰酈雍卻璩桑桂濮牛壽通邊扈燕冀浦尚農溫
別莊晏柴瞿閻充慕連茹習宦艾魚容向古易慎戈廖庾終暨居衡步都耿滿弘匡
國文寇廣祿闕東歐殳沃利蔚越夔隆師鞏厙聶晁勾敖融冷訾辛闞那簡饒空曾
毋沙乜養鞠須豐巢關蒯相查後荊紅

以下為 firstname.txt 的內容:

平燦惠歡佩泰州江揚剛乃屏珊易吟定小其菱幼函琴青博兆菁重立呈然永奕
漢義萍皓力昌妍合仲佳虹慧蓮恭石展軒啟奇秀駿晉冰政綸丹邦大冠貞生思
玄威嘉依音雲英能緯彬妙聖協法瑞恆采心友昀花樺航玫宛順儀寶婷書妮胤
彥修火雨俞孝蕙允城盈家陽琳阿紹誠倫亨星美和予念鳳凱松幸凡雯士達泓
金瑜勇必珍芷岳鈺方琬成霞麟致哲台睿賢珠瑩南克為尹妤春怡亮伯喬夫昕
亞真喜初愛清禮斌吉淳百臻寧以筠諭仕子文雅郁柏秋蓉伸福劭木宗傑丞昭
芝弘宇明月峰東聿登左祥迪蘭佑甫雄俊之卉谷玲禾茹榮堯芬姍少謙琇禎蘋
年姵勳任信旭燕苓豐惟盛發齊介芳容于維侑舜洋璇茂芃伊玉海建季雪柔汝
千富男新昱人添群欣綠馨利宜堅意名右姿智韻典竹巧坤可全潔裕毓孜仁韋
慈志琦宣希云茜辛薇梅樂妏嬌安上仰長承旺珮良鑫桓瑋光貴茵憲品綺芸天
源娟輝君銘夙來昇如泉正廷峻瑤恬靖淑瑄行秉伶康水羽治妹宥夢映霖儒枝
沛香皇一龍興延翰山卿白忠恩亭俐孟均元凌又偉強育辰萱鴻宸亦娥振中紫
倩民隆善玟紋杰旻學若華豪湖帆恒佐桂蓁穎軍德財庭琪世林純岑原尚昆妃
宏
'''
\end{Verbatim}

\href{http://blog.kmol.info}{KMOL's home page}



\renewcommand{\indexname}{索引}
\printindex
\end{document}
</t>
<t tx="amd_yen.20130503185304.3013"></t>
<t tx="amd_yen.20130503185304.3014">@language python

'''
主要用來細部修改 tex 檔案後, 再次產生所需要的 pdf 檔案
'''
#coding: utf-8
import os
d = c.scanAllDirectives(p)
# you probably need to install several packages 
# to create pdf (e.g. jadetex)
# 讀取原先單欄位的 index.tex 內容, 以 readlines 讀出所有內容
mandir = d.get('path') + "/c2wp/_build/latex"
filehandle = open(mandir+"/index.tex", encoding="UTF-8")
texcontent = filehandle.readlines()
filehandle.close()
#g.es(texcontent)
#texcontent[2] = "\documentclass[twocolumn]{article}"
# 將數列中設定單欄位與雙欄位的第三行, 也就是 index 索引為 2 的行內容替換後重新寫檔, 改寫為 index_twocolumn.tex 檔案然後轉為 pdf
filehandle = open(mandir+"/index_twocolumn.tex", "w", encoding="UTF-8")
linenumber = len(texcontent)
#g.es(linenumber)
for i in range(linenumber):
    if i == 2:
        filehandle.write("\documentclass[twocolumn]{article}\n")
    else:
        filehandle.write(texcontent[i])
filehandle.close()
#g.es("done")
g.es(mandir)
os.chdir(mandir)
#os.system('make latex')
#os.chdir('_build/latex')
# 接下來要設法將 .tex 轉為 .pdf
target_name = "index_twocolumn"
filename = target_name+".tex"
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
filename = target_name+".xdv"
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xdvipdfmx.exe -vv -E "+filename)

#
#os.system(target_name.replace(".xdv", ".pdf"))
filename = target_name+".pdf"
os.system(filename)
#os.system('../../fixup.pl &lt; Leodocumentation.tex &gt; LeoDoc.tex')
#os.system('make LeoDoc.pdf')</t>
<t tx="amd_yen.20130503185304.3015"></t>
<t tx="amd_yen.20130503185304.3016">@language rest
@tabwidth -4

@ @rst-options
call_docutils=False
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = True
verbose=True
@c
</t>
<t tx="amd_yen.20130503185304.3017">################################################
C2G1 報告
################################################

.. index:: C2G1 報告

.. contents::
    :depth: 3</t>
<t tx="amd_yen.20130503185304.3018">.. centered:: 有關文書處理

雙欄位編排
\documentclass[11pt,twocolumn]{article}</t>
<t tx="amd_yen.20130503185304.3019">.. 註解:: LaTeX raw 資料無法由 Sphinx 轉為 html

.. raw:: latex
     
    \chapter{數學方程式排版}
    
    \begin{intro}
      Now you are ready! In this chapter, we will attack the main strength
      of \TeX{}: mathematical typesetting. But be warned, this chapter
      only scratches the surface. While the things explained here are
      sufficient for many people, don't despair if you can't find a
      solution to your mathematical typesetting needs here. It is highly likely
      that your problem is addressed in \AmS-\LaTeX{}%
      \footnote{The \emph{American Mathematical Society} has produced a
      powerful extension to \LaTeX{}. Many of the examples in this
      chapter make use of this extension. It is provided with all recent
      \TeX{} distributions. If yours is missing it, go to \texttt{CTAN:/tex-archive/macros/latex/required/amslatex}.}
    \end{intro}
      
    \section{General}
    
    \LaTeX{} has a special mode for typesetting \wi{mathematics}. Mathematics
    can be typeset inline within a paragraph, or the paragraph can be broken to
    typeset it separately. Mathematical text \emph{within} a paragraph is entered between \ci{(}
    and \ci{)}, \index{$@\texttt{\$}} %$
    between \texttt{\$} and \texttt{\$}, or between %}
    \verb|\begin{|\ei{math}\verb|}| and \verb|\end{math}|.\index{formulae}
    \begin{example}
    Add $a$ squared and $b$ squared 
    to get $c$ squared. Or, using 
    a more mathematical approach:
    $c^{2}=a^{2}+b^{2}$
    \end{example}
    \begin{example}
    \TeX{} is pronounced as 
    \(\tau\epsilon\chi\).\\[6pt]
    100~m$^{3}$ of water\\[6pt]
    This comes from my
    \begin{math}\heartsuit\end{math}
    \end{example}
    
    When you want your larger mathematical equations or formulae to be set apart
    from the rest of the paragraph, it is preferable to \emph{display} them,
    rather than to break the paragraph apart.
    To do this, you can either enclose them
    in \ci{[} and \ci{]}, or between
    \verb|\begin{|\ei{displaymath}\verb|}| and
    \verb|\end{displaymath}|.
    \begin{example}
    Add $a$ squared and $b$ squared
    to get $c$ squared. Or, using
    a more mathematical approach:
    \begin{displaymath}
    c^{2}=a^{2}+b^{2}
    \end{displaymath}
    or you can type less with:
    \[a+b=c\]
    \end{example}
    If you want \LaTeX{} to enumerate your equations, you can use the
    \ei{equation} environment.
    You can then \ci{label} an equation number and refer to it somewhere else in the
    text by using \ci{ref} or \ci{eqref}:
    \begin{example}
    \begin{equation} \label{eq:eps}
    \epsilon &gt; 0
    \end{equation}
    From (\ref{eq:eps}), we gather 
    \ldots{}From \eqref{eq:eps} we
    do the same.
    \end{example}
    
    Note the difference in typesetting style between equations that are typeset and those
    that are displayed:
    
    \begin{example}
    $\lim_{n \to \infty} 
    \sum_{k=1}^n \frac{1}{k^2} 
    = \frac{\pi^2}{6}$
    \end{example}
    \begin{example}
    \begin{displaymath}
    \lim_{n \to \infty} 
    \sum_{k=1}^n \frac{1}{k^2} 
    = \frac{\pi^2}{6}
    \end{displaymath}
    \end{example}
    
    
    
    There are differences between \emph{math mode} and \emph{text mode}. For
    example, in \emph{math mode}: 
    
    \begin{enumerate}
    
    \item Most spaces and line breaks do not have any significance, as all spaces
    are either derived logically from the mathematical expressions, or
    have to be specified with special commands such as \ci{,}, \ci{quad} or
    \ci{qquad}.
     
    \item Empty lines are not allowed. Only one paragraph per formula.
    
    \item Each letter is considered to be the name of a variable and will be
    typeset as such. If you want to typeset normal text within a formula
    (normal upright font and normal spacing) then you have to enter the
    text using the \verb|\textrm{...}| commands.
    \end{enumerate}
    \begin{example}
    \begin{equation}
    \forall x \in \mathbf{R}:
    \qquad x^{2} \geq 0
    \end{equation}
    \end{example}
    \begin{example}
    \begin{equation}
    x^{2} \geq 0\qquad
    \textrm{for all }x\in\mathbf{R}
    \end{equation}
    \end{example}
     
    
    %
    % Add AMSSYB Package ... Blackboard bold .... R for realnumbers
    %
    Mathematicians can be very fussy about which symbols are used:
    it would be conventional here to use `\wi{blackboard bold}',
    \index{bold symbols} which is obtained using \ci{mathbb} from the
    package \pai{amsfonts} or \pai{amssymb}.
    \ifx\mathbb\undefined\else
    The last example becomes
    \begin{example}
    \begin{displaymath}
    x^{2} \geq 0\qquad
    \textrm{for all }x\in\mathbb{R}
    \end{displaymath}
    \end{example}
    \fi
    
    \section{Grouping in Math Mode}
    
    Most math mode commands act only on the next character, so if you
    want a command to affect several characters, you have to group them
    together using curly braces: \verb|{...}|.
    \begin{example}
    \begin{equation}
    a^x+y \neq a^{x+y}
    \end{equation}
    \end{example}</t>
<t tx="amd_yen.20130503185304.3020">.. 註解:: LaTeX picture: http://en.wikibooks.org/wiki/LaTeX/Picture

.. 註解:: 使用 Tikz 的繪圖範例: http://www.texample.net/tikz/examples/all/

.. raw:: latex

    %Version Aug 93    cgl@risc1.rug.nl
    \noindent
           \setlength{\unitlength}{3.8ex}
    \begin{picture}(14,15.6)(-.5, -2.5)
    %1st column
    \put(1, 0){\line(0, 1){1.5}}
    \put(1, 2){\oval(2, 1)}
    \put(1, 2){\makebox(0, 0){\texttt{.pk}}}
    \put(1, 4){\vector(0, -1){1.5}}
    \put(-.5, 4){\framebox(3, 1){METAfont}}
    \put(1, 6.5){\vector(0, -1){1.5}}
    \put(1,7){\oval(2, 1)}
    \put(1, 7){\makebox(0, 0){\texttt{.mf}}}
    %second column
    \put(7.5, -.5){\framebox(2, 1){driver}}
    \put(9.75, .75){\line(-1, 0){1.25}}
    \put(9.75, .75){\line( 0, -1){.5}}
    \put(9.75, .25){\line(-1, 0){.25}}
    \put(9.85, .23){{\tiny \texttt{dvips}}}
    \put(10, 1){\line(-1, 0){1.25}}
    \put(10, 1){\line( 0, -1){.5}}
    \put(10, .5){\line(-1, 0){.25}}
    \put(8.75, 1){\line( 0, -1){.25}}
    \put(10.1, .63){{\tiny \texttt{xdvi}}}
    \put(10.1, 1.1){\hbox{.}\kern.1ex\raise.5ex\hbox{.}\kern.1ex\raise1ex\hbox{.}}
    \put(8.5, 1.5){\vector(0, -1){1}}
    \put(8.5, 2){\oval(2, 1)}
    \put(8.5, 2){\makebox(0, 0){\texttt{.dvi}}}
    \put(8.5, 4){\vector(0, -1){1.5}}
    \put(7.5, 4){\framebox(2, 1){\TeX}}
    %Plain
    \put(9.75, 5.25){\line(-1, 0){1.25}}
    \put(9.75, 5.25){\line( 0, -1){.5}}
    \put(9.75, 4.75){\line(-1, 0){.25}}
    \put(9.8, 4.68){{\tiny Plain}}
    %LaTeX
    \put(10, 5.5){\line(-1, 0){1.25}}
    \put(10, 5.5){\line( 0, -1){.5}}
    \put(10, 5){\line(-1, 0){.25}}
    \put(8.75, 5.5){\line( 0, -1){.25}}
    \put(10.1, 4.95){{\tiny \LaTeXe}}
    \put(10.25, 5.75){\line(-1, 0){1.25}}
    \put(10.25, 5.75){\line( 0, -1){.5}}
    \put(10.25, 5.25){\line(-1, 0){.25}}
    \put(9, 5.75){\line( 0, -1){.25}}
    \put(10.35, 5.4){{\tiny AMS-Package}}
    %
    \put(10.35, 5.85){\hbox{.}\kern.1ex
    \raise.5ex\hbox{.}\kern.1ex\raise1ex\hbox{.}}
    %
    \put(8.5, 6.5){\vector(0, -1){1.5}}
    \put(8.5, 7){\oval(2, 1)}
    \put(8.5, 7){\makebox(0, 0){\texttt{.tex}}}
    %
    \multiput(8.5, 9)(0, -.415){3}{\line(0, -1){.25}}
    \put(8.5, 8.7){\vector(0, 1){.3}}
    \put(8.5, 7.8){\vector(0, -1){.3}}
    \put(7.5, 9){\framebox(2, 1){editor}}
    %Spelling checker
    \put(9.75, 10.25){\line(-1, 0){1.25}}
    \put(9.75, 10.25){\line( 0, -1){.5}}
    \put(9.75, 9.75){\line(-1, 0){.25}}
    \put(9.85, 9.75){{\tiny \texttt{emacs}}}
    %Style checker
    \put(10, 10.5){\line(-1, 0){1.25}}
    \put(10, 10.5){\line( 0, -1){.5}}
    \put(10, 10){\line(-1, 0){.25}}
    \put(8.75, 10.5){\line( 0, -1){.25}}
    \put(10.1, 10){{\tiny \texttt{ispell}}}
    %
    \put(10.1, 10.6){\hbox{.}\kern.1ex
    \raise.5ex\hbox{.}\kern.1ex\raise1ex\hbox{.}}
    %
    \put(8.5, 11.5){\vector(0, -1){1.5}}
    \put(8.5, 12){\oval(2, 1)}
    \put(8.5, 12){\makebox(0, 0){copy}}
    %basis
    \put(1, 0){\vector(1, 0){6.5}}
    \put(9.5, 0){\vector(1, 0){2}}
    \put(11.5, -.75){\framebox(2, 1.5){}}
    \put(11.70, -.4){\shortstack{\small printer\\\small screen}}
    %middle
    \multiput(5, 5.25)(0, 1){3}{\line(0,1){.5}}
    \multiput(5,  .25)(0, 1){4}{\line(0,1){.5}}
    \multiput(5, -1.75)(0, 1.3){2}{\line(0,1){.2}}
    %
    \put(3.5, -1.250){\dashbox{.25}(3, .5){{\tiny \textsc{PostScript}}}}
    \multiput(6.5, -1)(.45, 0){4}{\line(1,0){.25}}
    \put(8.5, -1){\line( -1, 0){.2}}
    %
    \put(8.5, -1){\vector(0, 1){.5}}
    \put(2.5, 4.5){\vector(1, 0){1.5}}
    \put(5, 4.5){\oval(2, 1)}
    \put(5, 4.5){\makebox(0, 0){\texttt{.tfm}}}
    \put(6, 4.5){\vector(1, 0){1.5}}
    \put(9.5, 4.5){\vector(1, 0){2}}
    \put(12.5, 4.5){\oval(2, 1)}
    \put(12.5, 4.5){\makebox(0, 0){\texttt{.log}}}
    %base line
    \put(.51,-1.75){\vector(-1, 0){1}}
    \put(2.25, -1.75){\makebox(0, 0){Fonts}}
    \put(3.9,-1.75){\vector( 1, 0){1}}
    \put(6.1,-1.75){\vector(-1, 0){1}}
    \put(9, -1.75){\makebox(0, 0){Typesetting}}
    \put(12.4,-1.75){\vector(1, 0){1}}
    \end{picture}



</t>
<t tx="amd_yen.20130503185304.3021">以下為數學式:

.. math::

   E_r^2 - |\boldsymbol{p}|^2 c^2 &amp;= m_0^2 c^4 \\
   E_r^2 - (pc)^2 &amp;= (m_0 c^2)^2

或者

.. math::

   E_r = \sqrt{(m_0 c^2)^2 + (pc)^2}
   
至於文章中的數學符號用法:

Here the :math:`(pc)^2` term represents the square of the Euclidean norm (total vector length) of the various momentum vectors in the system, which reduces to the square of the simple momentum magnitude, if only a single particle is considered. This equation reduces to |E=mc²| when the momentum term is zero. For photons where :math:`\boldsymbol{m_0 = 0}`, the equation reduces to :math:`\boldsymbol{E_r = pc}`.


.. math::

   E_k = m_0(\gamma-1)c^2 = \frac{m_0 c^2}{\sqrt{1 - \frac{v^2}{c^2}}} - {m_0 c^2},

with |v| the velocity, :math:`m_0` the rest mass, and γ the Lorentz factor.

He included the second term on the right to make sure that for small velocities, the energy would be the same as in classical mechanics:

.. math::

   E_k = \frac{1}{2} m_0 v^2 + \cdots.

Without this second term, there would be an additional contribution in the energy when the particle is not moving.

Einstein found that the total momentum of a moving particle is:

.. math::

   P = \frac{m_0 v}{\sqrt{1-\frac{v^2}{c^2}}}.

and it is this quantity which is conserved in collisions. The ratio of the momentum to the velocity is the relativistic mass, |m|:

.. math::

   m = \frac{m_0}{\sqrt{1-\frac{v^2}{c^2}}}

and the relativistic mass and the relativistic kinetic energy are related by the formula:

.. math::

   E_k = {m c^2} - {m_0 c^2}.

Einstein wanted to omit the unnatural second term on the right-hand side, whose only purpose is to make the energy at rest zero, and to declare that the particle has a total energy which obeys:

.. math::

   E = mc^2

which is a sum of the rest energy :math:`m_0 c^2` and the kinetic energy. This total energy is mathematically more elegant, and fits better with the momentum in relativity. But to come to this conclusion, Einstein needed to think carefully about collisions. This expression for the energy implied that matter at rest has a huge amount of energy, and it is not clear whether this energy is physically real, or just a mathematical artifact with no physical meaning.

In a collision process where all the rest-masses are the same at the beginning as at the end, either expression for the energy is conserved. The two expressions only differ by a constant which is the same at the beginning and at the end of the collision. Still, by analyzing the situation where particles are thrown off a heavy central particle, it is easy to see that the inertia of the central particle is reduced by the total energy emitted. This allowed Einstein to conclude that the inertia of a heavy particle is increased or diminished according to the energy it absorbs or emits.
</t>
<t tx="amd_yen.20130503185304.3022">.. 註解:: 以下將 latex 語法的內容直接透過 raw 指令傳遞, 但是 LaTeX raw 資料無法由 Sphinx 轉為 html

.. raw:: latex

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Contents: The Bibliography
    % File: biblio.tex (lshort2e.tex)
    % $Id: biblio.tex,v 1.1.1.1 2002/02/26 10:04:20 oetiker Exp $
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \begin{thebibliography}{99}
    % 因為會自動加上 \bibname, 因此蓋掉下列重複的 \bibname
    %\addcontentsline{toc}{chapter}{\bibname} 
    \bibitem{manual} Leslie Lamport.  \newblock \emph{{\LaTeX:} A Document
        Preparation System}.  \newblock Addison-Wesley, Reading,
      Massachusetts, second edition, 1994, ISBN~0-201-52983-1.
      
    \bibitem{texbook} Donald~E. Knuth.  \newblock \textit{The \TeX{}book,}
      Volume~A of \textit{Computers and Typesetting}, Addison-Wesley,
      Reading, Massachusetts, second edition, 1984, ISBN~0-201-13448-9.
    
    \bibitem{companion} Michel Goossens, Frank Mittelbach and Alexander
      Samarin.  \newblock \emph{The {\LaTeX} Companion}.  \newblock
      Addison-Wesley, Reading, Massachusetts, 1994, ISBN~0-201-54199-8.
     
    \bibitem{local} Each \LaTeX{} installation should provide a so-called
      \emph{\LaTeX{} Local Guide}, which explains the things that are
      special to the local system.  It should be contained in a file called
      \texttt{local.tex}. Unfortunately, some lazy sysops do not provide such a
      document. In this case, go and ask your local \LaTeX{} guru for help.
     
    \bibitem{usrguide} \LaTeX3 Project Team.  \newblock \emph{\LaTeXe~for
        authors}.  \newblock Comes with the \LaTeXe{} distribution as
      \texttt{usrguide.tex}.
    
    \bibitem{clsguide} \LaTeX3 Project Team.  \newblock \emph{\LaTeXe~for
        Class and Package writers}.  \newblock Comes with the \LaTeXe{}
      distribution as \texttt{clsguide.tex}.
    
    \bibitem{fntguide} \LaTeX3 Project Team.  \newblock \emph{\LaTeXe~Font
        selection}.  \newblock Comes with the \LaTeXe{} distribution as
      \texttt{fntguide.tex}.
    
    \bibitem{graphics} D.~P.~Carlisle.  \newblock \emph{Packages in the
        `graphics' bundle}.  \newblock Comes with the `graphics' bundle as
      \texttt{grfguide.tex}, available from the same source your \LaTeX{}
      distribution came from.
    
    \bibitem{verbatim} Rainer~Sch\"opf, Bernd~Raichle, Chris~Rowley.  
    \newblock \emph{A New Implementation of \LaTeX's verbatim
      Environments}.
     \newblock Comes with the `tools' bundle as
      \texttt{verbatim.dtx}, available from the same source your \LaTeX{}
      distribution came from. 
    
    \bibitem{catalogue} Graham~Williams.  \newblock \emph{The TeX
        Catalogue} is a very complete listing of many \TeX{} and \LaTeX{}
        related packages.
      \newblock Available online from \texttt{CTAN:/tex-archive/help/Catalogue/catalogue.html}
      
    \bibitem{eps} Keith~Reckdahl.  \newblock \emph{Using EPS Graphics in
        \LaTeXe{} Documents}, which explains everything and much more than
      you ever wanted to know about EPS files and their use in \LaTeX{}
      documents.  \newblock Available online from
      \texttt{CTAN:/tex-archive/info/epslatex.ps}
    
    \bibitem{xy-pic} Kristoffer H. Rose
      \newblock \emph{\Xy-pic User's Guide}.  \newblock
      Downloadable from CTAN with \Xy-pic distribution 
    
    \end{thebibliography}
    
    
    %
    
    % Local Variables:
    % TeX-master: "lshort2e"
    % mode: latex
    % mode: flyspell
    % End:
</t>
<t tx="amd_yen.20130503185304.5137"></t>
<t tx="amd_yen.20130503185304.5145">Chapter 6: More on Strings and Arrays of Strings

第六章: 更多關於字串與字串陣列的用法

接著, 再回到字串的用法. 下面的例子, 都以全域的方式運用, 亦即, 可以在任何函式之外發生作用, 包括主函式.

先前的章節曾經談過:

   char my_string[40] = "Ted";
   
將會配置足夠存放 40 個位元組陣列的空間來存放該變數的值, 並且在最前面的 4 個位元組中放入所設定的字元 (前面三個位元組放入雙引號中的字元, 而最後則放入 '\0')

而實際上, 也可以將 "Ted"  這個字串寫成:

   char my_name[] = "Ted";
   
編譯器屆時就會計算字元個數, 並且預留最後的 null 字元, 以便能將全部四個字元存入記憶體, 並傳回存放字元的陣列名稱, 這裡採用 my_name.

在某些程式中, 也可以寫成:

   char *my_name = "Ted";
   
這種方式, 與先前兩種方法有何不同? 答案是: 當然不同. 採用陣列來存放四個位元組是將資料放在靜態記憶體區塊, 每一個字元的最後都會放入 null 字元. 但是若採用指標的方式, 也是需要相同的四個位元組, 並加上 N 個位元組來存放 my_name 這個指標變數 (N 取決於系統, 但通常至少 2 位元組, 也可能是 4 個以上)

陣列的表示法中, my_name 是 &amp;myname[0] 的縮寫, 也就是第一個陣列元素的位址. 由於該陣列位址在執行期間是固定的, 因此不會改變 (不是變數). 而若採用指標的方式, my_name 則是變數. 因此採用指標是較好的方式, 當然也取決於隨後要如何應用這個變數.

若再進一步觀察採用不同方式宣告後, 在函數內將如何發生變化, 這與處在任何函式外的全域用法有很大的不同.

void my_function_A(char *ptr)
{
    char a[] = "ABCDE"
    .
    .
} 
void my_function_B(char *ptr)
{
    char *cp = "FGHIJ"
    .
    .
}

在 my_function_A 的案例中, 陣列 a[] 的值, 就是存放其中的資料. 陣列可視為以 ABCDE 值進行啟始化. 而在 my_function_B 的案例, cp 指標值才代表所存放的資料. 指標的啟始是指向 FGHIJ 字串. 在兩個函式內, 變數定義都是局部, 因此 ABCDE 字串存在指標變數所對應值的堆疊中, 而 FGHIJ 則可能存在任何地方. 在我的系統中, 是存在資料區段中.

此外, 採陣列變數自動起始, 就如同 my_function_A 中所示, 在舊的 K&amp;R C 中是無法使用的, 只能用在 ANSI C 的環境中. 這點在考量程式的可攜或向後相容時就顯得很重要.

只要討論有關指標與陣列的關係與差異時, 就需要更進一步討論多維度陣列. 例如下列陣列:

    char multi[5][10];
    
這代表什麼? 讓我們看看.

    char multi[5][10];
    
若將有底線的部分視為陣列的變數名稱. 先前的 char 代表資料型別, 而隨後的 [10] 則代表擁有時個字元的陣列. 但是 multi[5] 本身又是一個具有 5 個成員的陣列, 而每一個都帶有 10 個字元的陣列. 亦即, 總共有 5 個陣列各自帶有 10 個字元的陣列.

假設將這個二維的陣列填入資料, 在記憶體中, 可以表示成為五個各自分離的陣列:

    multi[0] = {'0','1','2','3','4','5','6','7','8','9'}
    multi[1] = {'a','b','c','d','e','f','g','h','i','j'}
    multi[2] = {'A','B','C','D','E','F','G','H','I','J'}
    multi[3] = {'9','8','7','6','5','4','3','2','1','0'}
    multi[4] = {'J','I','H','G','F','E','D','C','B','A'}
    
同時, 個別元素可以再表示為:

    multi[0][3] = '3'
    multi[1][7] = 'h'
    multi[4][0] = 'J'
    
由於陣列在記憶體中是連續的資料, 因此在真實的記憶區段中, 就成為:

    0123456789abcdefghijABCDEFGHIJ9876543210JIHGFEDCBA
    ^
    |_____ starting at the address &amp;multi[0][0]
    
請注意, 這裡並沒有將 multi[0] 寫成"0123456789". 因為若寫成這樣, 電腦會在最
後面補上字串結束用的 '\0', 因為雙引號中間的資料會被當作字串. 這樣, 每一個變數
就會帶有 11 個字元, 而非該有的 10 個字元.

前面的用意在昭示記憶體如何處理二維陣列. 亦即, 以一個二維字元陣列來存放資料, 而不是存成字串陣列.

接著, 編譯器知道陣列中需要多少行, 因此會用 mylti +1 作為 'a' 在第二列之首, 也就是每一列會加上 10, 結合所指的列數來取得正確的資料.

若處理的數值為整數與相同維數的陣列, 在我使用的機器上, 編譯器會加上 10*sizeof(int), 而得到 20. 因此第四列第九行的位址, 表示為指標, 將會是 &amp;multi[3][0] 或 *(multi + 3). 若希望取得第四列第二個數值, 就可以在此位址上加上 1, 得到下列結果

    *(*(multi + 3) + 1)
    
再繼續探究, 可知

    *(*(multi + row) + col)    與
    
    multi[row][col]            可得到相同的結果.

下列程式採用整數數列而非字元陣列來驗證這個結果:

------------------- program 6.1 ----------------------

/* Program 6.1 from PTRTUT10.HTM   6/13/97*/

#include &lt;stdio.h&gt;
#define ROWS 5
#define COLS 10
int multi[ROWS][COLS];
int main(void)
{
    int row, col;
    for (row = 0; row &lt; ROWS; row++)
    {
        for (col = 0; col &lt; COLS; col++)
        {
            multi[row][col] = row*col;
        }
    }
    for (row = 0; row &lt; ROWS; row++)
    {
        for (col = 0; col &lt; COLS; col++)
        {
            printf("\n%d  ",multi[row][col]);
            printf("%d ",*(*(multi + row) + col));
        }
    }
    return 0;
}

----------------- end of program 6.1 ---------------------   

由於在陣列程式版本中進行了兩次交互參照取值, 二維陣列的名稱就如同指向陣列的指標. 至於三維陣列則用來處理陣列中陣列所指向的陣列, 因此也等同是指向陣列中陣列的指標. 但這裡的說明將陣列所佔記憶體區段以陣列來加以表示, 因此所處理的記憶體位址為常數而非變數. 亦即所討論的是固定的位址而非變數指標.

上述的取值函式允許從陣列中, 以無需變更位址數值的方式從陣列中取出任何數值 (例如, 以 multi[0][0]  的位址取 multi 符號所對應的值)
</t>
<t tx="amd_yen.20130503185304.5147">CHAPTER 7: More on Multi-Dimensional Arrays

In the previous chapter we noted that given

    #define ROWS 5
    #define COLS 10

    int multi[ROWS][COLS];
we can access individual elements of the array multi using either:

    multi[row][col]
or

    *(*(multi + row) + col)
To understand more fully what is going on, let us replace

    *(multi + row)
with X as in:

    *(X + col)
Now, from this we see that X is like a pointer since the expression is de-referenced and we know that col is an integer. Here the arithmetic being used is of a special kind called "pointer arithmetic" is being used. That means that, since we are talking about an integer array, the address pointed to by (i.e. value of) X + col + 1 must be greater than the address X + col by and amount equal to sizeof(int).

Since we know the memory layout for 2 dimensional arrays, we can determine that in the expression multi + row as used above, multi + row + 1 must increase by value an amount equal to that needed to "point to" the next row, which in this case would be an amount equal to COLS * sizeof(int).

That says that if the expression *(*(multi + row) + col) is to be evaluated correctly at run time, the compiler must generate code which takes into consideration the value of COLS, i.e. the 2nd dimension. Because of the equivalence of the two forms of expression, this is true whether we are using the pointer expression as here or the array expression multi[row][col].

Thus, to evaluate either expression, a total of 5 values must be known:

The address of the first element of the array, which is returned by the expression multi, i.e., the name of the array.
The size of the type of the elements of the array, in this case sizeof(int).
The 2nd dimension of the array
The specific index value for the first dimension, row in this case.
The specific index value for the second dimension, col in this case.
Given all of that, consider the problem of designing a function to manipulate the element values of a previously declared array. For example, one which would set all the elements of the array multi to the value 1.

    void set_value(int m_array[][COLS])
    {
        int row, col;
        for (row = 0; row &lt; ROWS; row++)
        {
            for (col = 0; col &lt; COLS; col++)
            {
                m_array[row][col] = 1;
            }
        }
    }

And to call this function we would then use:

    set_value(multi);
Now, within the function we have used the values #defined by ROWS and COLS that set the limits on the for loops. But, these #defines are just constants as far as the compiler is concerned, i.e. there is nothing to connect them to the array size within the function. row and col are local variables, of course. The formal parameter definition permits the compiler to determine the characteristics associated with the pointer value that will be passed at run time. We really don’t need the first dimension and, as will be seen later, there are occasions where we would prefer not to define it within the parameter definition, out of habit or consistency, I have not used it here. But, the second dimension must be used as has been shown in the expression for the parameter. The reason is that we need this in the evaluation of m_array[row][col] as has been described. While the parameter defines the data type (int in this case) and the automatic variables for row and column are defined in the for loops, only one value can be passed using a single parameter. In this case, that is the value of multi as noted in the call statement, i.e. the address of the first element, often referred to as a pointer to the array. Thus, the only way we have of informing the compiler of the 2nd dimension is by explicitly including it in the parameter definition.

In fact, in general all dimensions of higher order than one are needed when dealing with multi-dimensional arrays. That is if we are talking about 3 dimensional arrays, the 2nd and 3rd dimension must be specified in the parameter definition.


</t>
<t tx="amd_yen.20130503185304.5148">CHAPTER 8: Pointers to Arrays

Pointers, of course, can be "pointed at" any type of data object, including arrays. While that was evident when we discussed program 3.1, it is important to expand on how we do this when it comes to multi-dimensional arrays.

To review, in Chapter 2 we stated that given an array of integers we could point an integer pointer at that array using:

    int *ptr;
    ptr = &amp;my_array[0];       /* point our pointer at the first
                                 integer in our array */
As we stated there, the type of the pointer variable must match the type of the first element of the array.

In addition, we can use a pointer as a formal parameter of a function which is designed to manipulate an array. e.g.

Given:

    int array[3] = {1, 5, 7};
    void a_func(int *p);
Some programmers might prefer to write the function prototype as:

   void a_func(int p[]);
which would tend to inform others who might use this function that the function is designed to manipulate the elements of an array. Of course, in either case, what actually gets passed is the value of a pointer to the first element of the array, independent of which notation is used in the function prototype or definition. Note that if the array notation is used, there is no need to pass the actual dimension of the array since we are not passing the whole array, only the address to the first element.

We now turn to the problem of the 2 dimensional array. As stated in the last chapter, C interprets a 2 dimensional array as an array of one dimensional arrays. That being the case, the first element of a 2 dimensional array of integers is a one dimensional array of integers. And a pointer to a two dimensional array of integers must be a pointer to that data type. One way of accomplishing this is through the use of the keyword "typedef". typedef assigns a new name to a specified data type. For example:

    typedef unsigned char byte;
causes the name byte to mean type unsigned char. Hence

    byte b[10];     would be an array of unsigned characters.
Note that in the typedef declaration, the word byte has replaced that which would normally be the name of our unsigned char. That is, the rule for using typedef is that the new name for the data type is the name used in the definition of the data type. Thus in:

    typedef int Array[10];
Array becomes a data type for an array of 10 integers. i.e. Array my_arr; declares my_arr as an array of 10 integers and Array arr2d[5]; makes arr2d an array of 5 arrays of 10 integers each.

Also note that Array *p1d; makes p1d a pointer to an array of 10 integers. Because *p1d points to the same type as arr2d, assigning the address of the two dimensional array arr2d to p1d, the pointer to a one dimensional array of 10 integers is acceptable. i.e. p1d = &amp;arr2d[0]; or p1d = arr2d; are both correct.

Since the data type we use for our pointer is an array of 10 integers we would expect that incrementing p1d by 1 would change its value by 10*sizeof(int), which it does. That is, sizeof(*p1d) is 20. You can prove this to yourself by writing and running a simple short program.

Now, while using typedef makes things clearer for the reader and easier on the programmer, it is not really necessary. What we need is a way of declaring a pointer like p1d without the need of the typedef keyword. It turns out that this can be done and that

    int (*p1d)[10];
is the proper declaration, i.e. p1d here is a pointer to an array of 10 integers just as it was under the declaration using the Array type. Note that this is different from

    int *p1d[10];
which would make p1d the name of an array of 10 pointers to type int.
</t>
<t tx="amd_yen.20130503185304.5149">CHAPTER 9: Pointers and Dynamic Allocation of Memory

There are times when it is convenient to allocate memory at run time using malloc(), calloc(), or other allocation functions. Using this approach permits postponing the decision on the size of the memory block need to store an array, for example, until run time. Or it permits using a section of memory for the storage of an array of integers at one point in time, and then when that memory is no longer needed it can be freed up for other uses, such as the storage of an array of structures.

When memory is allocated, the allocating function (such as malloc(), calloc(), etc.) returns a pointer. The type of this pointer depends on whether you are using an older K&amp;R compiler or the newer ANSI type compiler. With the older compiler the type of the returned pointer is char, with the ANSI compiler it is void.

If you are using an older compiler, and you want to allocate memory for an array of integers you will have to cast the char pointer returned to an integer pointer. For example, to allocate space for 10 integers we might write:

    int *iptr;
    iptr = (int *)malloc(10 * sizeof(int));
    if (iptr == NULL)

    { .. ERROR ROUTINE GOES HERE .. }
If you are using an ANSI compliant compiler, malloc() returns a void pointer and since a void pointer can be assigned to a pointer variable of any object type, the (int *) cast shown above is not needed. The array dimension can be determined at run time and is not needed at compile time. That is, the 10 above could be a variable read in from a data file or keyboard, or calculated based on some need, at run time.

Because of the equivalence between array and pointer notation, once iptr has been assigned as above, one can use the array notation. For example, one could write:

    int k;
    for (k = 0; k &lt; 10; k++)
       iptr[k] = 2;
to set the values of all elements to 2.

Even with a reasonably good understanding of pointers and arrays, one place the newcomer to C is likely to stumble at first is in the dynamic allocation of multi-dimensional arrays. In general, we would like to be able to access elements of such arrays using array notation, not pointer notation, wherever possible. Depending on the application we may or may not know both dimensions at compile time. This leads to a variety of ways to go about our task.

As we have seen, when dynamically allocating a one dimensional array its dimension can be determined at run time. Now, when using dynamic allocation of higher order arrays, we never need to know the first dimension at compile time. Whether we need to know the higher dimensions depends on how we go about writing the code. Here I will discuss various methods of dynamically allocating room for 2 dimensional arrays of integers.

First we will consider cases where the 2nd dimension is known at compile time.

METHOD 1:

One way of dealing with the problem is through the use of the typedef keyword. To allocate a 2 dimensional array of integers recall that the following two notations result in the same object code being generated:

    multi[row][col] = 1;     *(*(multi + row) + col) = 1;

It is also true that the following two notations generate the same code:

    multi[row]            *(multi + row)

Since the one on the right must evaluate to a pointer, the array notation on the left must also evaluate to a pointer. In fact multi[0] will return a pointer to the first integer in the first row, multi[1] a pointer to the first integer of the second row, etc. Actually, multi[n] evaluates to a pointer to that array of integers that make up the n-th row of our 2 dimensional array. That is, multi can be thought of as an array of arrays and multi[n] as a pointer to the n-th array of this array of arrays. Here the word pointer is being used to represent an address value. While such usage is common in the literature, when reading such statements one must be careful to distinguish between the constant address of an array and a variable pointer which is a data object in itself.

Consider now:

--------------- Program 9.1 --------------------------------

/* Program 9.1 from PTRTUT10.HTM  6/13/97 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define COLS 5

typedef int RowArray[COLS];
RowArray *rptr;

int main(void)
{
    int nrows = 10;
    int row, col;
    rptr = malloc(nrows * COLS * sizeof(int));
    for (row = 0; row &lt; nrows; row++)
    {
        for (col = 0; col &lt; COLS; col++)
        {
            rptr[row][col] = 17;
        }
    }

    return 0;
}
------------- End of Prog. 9.1 --------------------------------

Here I have assumed an ANSI compiler so a cast on the void pointer returned by malloc() is not required. If you are using an older K&amp;R compiler you will have to cast using:

    rptr = (RowArray *)malloc(.... etc.
Using this approach, rptr has all the characteristics of an array name name, (except that rptr is modifiable), and array notation may be used throughout the rest of the program. That also means that if you intend to write a function to modify the array contents, you must use COLS as a part of the formal parameter in that function, just as we did when discussing the passing of two dimensional arrays to a function.

METHOD 2:

In the METHOD 1 above, rptr turned out to be a pointer to type "one dimensional array of COLS integers". It turns out that there is syntax which can be used for this type without the need of typedef. If we write:

    int (*xptr)[COLS];

the variable xptr will have all the same characteristics as the variable rptr in METHOD 1 above, and we need not use the typedef keyword. Here xptr is a pointer to an array of integers and the size of that array is given by the #defined COLS. The parenthesis placement makes the pointer notation predominate, even though the array notation has higher precedence. i.e. had we written

    int *xptr[COLS];
we would have defined xptr as an array of pointers holding the number of pointers equal to that #defined by COLS. That is not the same thing at all. However, arrays of pointers have their use in the dynamic allocation of two dimensional arrays, as will be seen in the next 2 methods.

METHOD 3:

Consider the case where we do not know the number of elements in each row at compile time, i.e. both the number of rows and number of columns must be determined at run time. One way of doing this would be to create an array of pointers to type int and then allocate space for each row and point these pointers at each row. Consider:

-------------- Program 9.2 ------------------------------------

/* Program 9.2 from PTRTUT10.HTM   6/13/97 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int nrows = 5;     /* Both nrows and ncols could be evaluated */
    int ncols = 10;    /* or read in at run time */
    int row;
    int **rowptr;
    rowptr = malloc(nrows * sizeof(int *));
    if (rowptr == NULL)
    {
        puts("\nFailure to allocate room for row pointers.\n");
        exit(0);
    }

    printf("\n\n\nIndex   Pointer(hex)   Pointer(dec)   Diff.(dec)");

    for (row = 0; row &lt; nrows; row++)
    {
        rowptr[row] = malloc(ncols * sizeof(int));
        if (rowptr[row] == NULL)
        {
            printf("\nFailure to allocate for row[%d]\n",row);
            exit(0);
        }
        printf("\n%d         %p         %d", row, rowptr[row], rowptr[row]);
        if (row &gt; 0)
        printf("              %d",(int)(rowptr[row] - rowptr[row-1]));
    }

    return 0;
}

--------------- End 9.2 ------------------------------------

In the above code rowptr is a pointer to pointer to type int. In this case it points to the first element of an array of pointers to type int. Consider the number of calls to malloc():

    To get the array of pointers             1     call
    To get space for the rows                5     calls
                                          -----
                     Total                   6     calls
If you choose to use this approach note that while you can use the array notation to access individual elements of the array, e.g. rowptr[row][col] = 17;, it does not mean that the data in the "two dimensional array" is contiguous in memory.

You can, however, use the array notation just as if it were a continuous block of memory. For example, you can write:

    rowptr[row][col] = 176;
just as if rowptr were the name of a two dimensional array created at compile time. Of course row and col must be within the bounds of the array you have created, just as with an array created at compile time.

If you want to have a contiguous block of memory dedicated to the storage of the elements in the array you can do it as follows:

METHOD 4:

In this method we allocate a block of memory to hold the whole array first. We then create an array of pointers to point to each row. Thus even though the array of pointers is being used, the actual array in memory is contiguous. The code looks like this:

----------------- Program 9.3 -----------------------------------

/* Program 9.3 from PTRTUT10.HTM   6/13/97 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int **rptr;
    int *aptr;
    int *testptr;
    int k;
    int nrows = 5;     /* Both nrows and ncols could be evaluated */
    int ncols = 8;    /* or read in at run time */
    int row, col;

    /* we now allocate the memory for the array */

    aptr = malloc(nrows * ncols * sizeof(int));
    if (aptr == NULL)
    {
        puts("\nFailure to allocate room for the array");
        exit(0);
    }

    /* next we allocate room for the pointers to the rows */

    rptr = malloc(nrows * sizeof(int *));
    if (rptr == NULL)
    {
        puts("\nFailure to allocate room for pointers");
        exit(0);
    }

    /* and now we 'point' the pointers */

    for (k = 0; k &lt; nrows; k++)
    {
        rptr[k] = aptr + (k * ncols);
    }

    /* Now we illustrate how the row pointers are incremented */
    printf("\n\nIllustrating how row pointers are incremented");
    printf("\n\nIndex   Pointer(hex)  Diff.(dec)");

    for (row = 0; row &lt; nrows; row++)
    {
        printf("\n%d         %p", row, rptr[row]);
        if (row &gt; 0)
        printf("              %d",(rptr[row] - rptr[row-1]));
    }
    printf("\n\nAnd now we print out the array\n");
    for (row = 0; row &lt; nrows; row++)
    {
        for (col = 0; col &lt; ncols; col++)
        {
            rptr[row][col] = row + col;
            printf("%d ", rptr[row][col]);
        }
        putchar('\n');
    }

    puts("\n");

    /* and here we illustrate that we are, in fact, dealing with
       a 2 dimensional array in a contiguous block of memory. */
    printf("And now we demonstrate that they are contiguous in memory\n");

    testptr = aptr;
    for (row = 0; row &lt; nrows; row++)
    {
        for (col = 0; col &lt; ncols; col++)
        {
            printf("%d ", *(testptr++));
        }
        putchar('\n');
    }

    return 0;
}




------------- End Program 9.3 -----------------

Consider again, the number of calls to malloc()

    To get room for the array itself      1      call
    To get room for the array of ptrs     1      call
                                        ----
                         Total            2      calls

Now, each call to malloc() creates additional space overhead since malloc() is generally implemented by the operating system forming a linked list which contains data concerning the size of the block. But, more importantly, with large arrays (several hundred rows) keeping track of what needs to be freed when the time comes can be more cumbersome. This, combined with the contiguousness of the data block that permits initialization to all zeroes using memset() would seem to make the second alternative the preferred one.

As a final example on multidimensional arrays we will illustrate the dynamic allocation of a three dimensional array. This example will illustrate one more thing to watch when doing this kind of allocation. For reasons cited above we will use the approach outlined in alternative two. Consider the following code:

------------------- Program 9.4 -------------------------------------

/* Program 9.4 from PTRTUT10.HTM   6/13/97 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stddef.h&gt;

int X_DIM=16;
int Y_DIM=5;
int Z_DIM=3;

int main(void)
{
    char *space;
    char ***Arr3D;
    int y, z;
    ptrdiff_t diff;

    /* first we set aside space for the array itself */

    space = malloc(X_DIM * Y_DIM * Z_DIM * sizeof(char));

    /* next we allocate space of an array of pointers, each
       to eventually point to the first element of a
       2 dimensional array of pointers to pointers */

    Arr3D = malloc(Z_DIM * sizeof(char **));

    /* and for each of these we assign a pointer to a newly
       allocated array of pointers to a row */

    for (z = 0; z &lt; Z_DIM; z++)
    {
        Arr3D[z] = malloc(Y_DIM * sizeof(char *));

        /* and for each space in this array we put a pointer to
           the first element of each row in the array space
           originally allocated */

        for (y = 0; y &lt; Y_DIM; y++)
        {
            Arr3D[z][y] = space + (z*(X_DIM * Y_DIM) + y*X_DIM);
        }
    }

    /* And, now we check each address in our 3D array to see if
       the indexing of the Arr3d pointer leads through in a
       continuous manner */

    for (z = 0; z &lt; Z_DIM; z++)
    {
        printf("Location of array %d is %p\n", z, *Arr3D[z]);
        for ( y = 0; y &lt; Y_DIM; y++)
        {
            printf("  Array %d and Row %d starts at %p", z, y, Arr3D[z][y]);
            diff = Arr3D[z][y] - space;
            printf("    diff = %d  ",diff);
            printf(" z = %d  y = %d\n", z, y);
        }
    }
    return 0;
}

------------------- End of Prog. 9.4 ----------------------------

If you have followed this tutorial up to this point you should have no problem deciphering the above on the basis of the comments alone. There are a couple of points that should be made however. Let's start with the line which reads:

    Arr3D[z][y] = space + (z*(X_DIM * Y_DIM) + y*X_DIM);
Note that here space is a character pointer, which is the same type as Arr3D[z][y]. It is important that when adding an integer, such as that obtained by evaluation of the expression (z*(X_DIM * Y_DIM) + y*X_DIM), to a pointer, the result is a new pointer value. And when assigning pointer values to pointer variables the data types of the value and variable must match.
</t>
<t tx="amd_yen.20130503185304.5150">CHAPTER 10: Pointers to Functions

Up to this point we have been discussing pointers to data objects. C also permits the declaration of pointers to functions. Pointers to functions have a variety of uses and some of them will be discussed here.

Consider the following real problem. You want to write a function that is capable of sorting virtually any collection of data that can be stored in an array. This might be an array of strings, or integers, or floats, or even structures. The sorting algorithm can be the same for all. For example, it could be a simple bubble sort algorithm, or the more complex shell or quick sort algorithm. We'll use a simple bubble sort for demonstration purposes.

Sedgewick [1] has described the bubble sort using C code by setting up a function which when passed a pointer to the array would sort it. If we call that function bubble(), a sort program is described by bubble_1.c, which follows:

/*-------------------- bubble_1.c --------------------*/

/* Program bubble_1.c from PTRTUT10.HTM   6/13/97 */

#include &lt;stdio.h&gt;

int arr[10] = { 3,6,1,2,3,8,4,1,7,2};

void bubble(int a[], int N);

int main(void)
{
    int i;
    putchar('\n');
    for (i = 0; i &lt; 10; i++)
    {
        printf("%d ", arr[i]);
    }
    bubble(arr,10);
    putchar('\n');

    for (i = 0; i &lt; 10; i++)
    {
        printf("%d ", arr[i]);
    }
    return 0;
}

void bubble(int a[], int N)
{
    int i, j, t;
    for (i = N-1; i &gt;= 0; i--)
    {
        for (j = 1; j &lt;= i; j++)
        {
            if (a[j-1] &gt; a[j])
            {
                t = a[j-1];
                a[j-1] = a[j];
                a[j] = t;
            }
        }
    }
}



/*---------------------- end bubble_1.c -----------------------*/

The bubble sort is one of the simpler sorts. The algorithm scans the array from the second to the last element comparing each element with the one which precedes it. If the one that precedes it is larger than the current element, the two are swapped so the larger one is closer to the end of the array. On the first pass, this results in the largest element ending up at the end of the array. The array is now limited to all elements except the last and the process repeated. This puts the next largest element at a point preceding the largest element. The process is repeated for a number of times equal to the number of elements minus 1. The end result is a sorted array.

Here our function is designed to sort an array of integers. Thus in line 1 we are comparing integers and in lines 2 through 4 we are using temporary integer storage to store integers. What we want to do now is see if we can convert this code so we can use any data type, i.e. not be restricted to integers.

At the same time we don't want to have to analyze our algorithm and the code associated with it each time we use it. We start by removing the comparison from within the function bubble() so as to make it relatively easy to modify the comparison function without having to re-write portions related to the actual algorithm. This results in bubble_2.c:

/*---------------------- bubble_2.c -------------------------*/

/* Program bubble_2.c from PTRTUT10.HTM   6/13/97 */

   /* Separating the comparison function */

#include &lt;stdio.h&gt;

int arr[10] = { 3,6,1,2,3,8,4,1,7,2};

void bubble(int a[], int N);
int compare(int m, int n);

int main(void)
{
    int i;
    putchar('\n');
    for (i = 0; i &lt; 10; i++)
    {
        printf("%d ", arr[i]);
    }
    bubble(arr,10);
    putchar('\n');

    for (i = 0; i &lt; 10; i++)
    {
        printf("%d ", arr[i]);
    }
    return 0;
}

void bubble(int a[], int N)

{
    int i, j, t;
    for (i = N-1; i &gt;= 0; i--)
    {
        for (j = 1; j &lt;= i; j++)
        {
            if (compare(a[j-1], a[j]))
            {
                t = a[j-1];
                a[j-1] = a[j];
                a[j] = t;
            }
        }
    }
}

int compare(int m, int n)
{
    return (m &gt; n);
}
/*--------------------- end of bubble_2.c -----------------------*/
If our goal is to make our sort routine data type independent, one way of doing this is to use pointers to type void to point to the data instead of using the integer data type. As a start in that direction let's modify a few things in the above so that pointers can be used. To begin with, we'll stick with pointers to type integer.

/*----------------------- bubble_3.c -------------------------*/

/* Program bubble_3.c from PTRTUT10.HTM    6/13/97 */

#include &lt;stdio.h&gt;

int arr[10] = { 3,6,1,2,3,8,4,1,7,2};

void bubble(int *p, int N);
int compare(int *m, int *n);

int main(void)
{
    int i;
    putchar('\n');

    for (i = 0; i &lt; 10; i++)
    {
        printf("%d ", arr[i]);
    }
    bubble(arr,10);
    putchar('\n');

    for (i = 0; i &lt; 10; i++)
    {
        printf("%d ", arr[i]);
    }
    return 0;
}

void bubble(int *p, int N)
{
    int i, j, t;
    for (i = N-1; i &gt;= 0; i--)
    {
        for (j = 1; j &lt;= i; j++)
        {
            if (compare(&amp;p[j-1], &amp;p[j]))
            {
                t = p[j-1];
                p[j-1] = p[j];
                p[j] = t;
            }
        }
    }
}

int compare(int *m, int *n)
{
    return (*m &gt; *n);
}

/*------------------ end of bubble3.c -------------------------*/

Note the changes. We are now passing a pointer to an integer (or array of integers) to bubble(). And from within bubble we are passing pointers to the elements of the array that we want to compare to our comparison function. And, of course we are dereferencing these pointer in our compare() function in order to make the actual comparison. Our next step will be to convert the pointers in bubble() to pointers to type void so that that function will become more type insensitive. This is shown in bubble_4.

/*------------------ bubble_4.c ----------------------------*/

/* Program bubble_4.c from PTRTUT10,HTM   6/13/97 */

#include &lt;stdio.h&gt;

int arr[10] = { 3,6,1,2,3,8,4,1,7,2};

void bubble(int *p, int N);
int compare(void *m, void *n);

int main(void)
{
    int i;
    putchar('\n');

    for (i = 0; i &lt; 10; i++)
    {
        printf("%d ", arr[i]);
    }
    bubble(arr,10);
    putchar('\n');

    for (i = 0; i &lt; 10; i++)
    {
        printf("%d ", arr[i]);
    }
    return 0;
}

void bubble(int *p, int N)
{
    int i, j, t;
    for (i = N-1; i &gt;= 0; i--)
    {
        for (j = 1; j &lt;= i; j++)
        {
            if (compare((void *)&amp;p[j-1], (void *)&amp;p[j]))
            {
                t = p[j-1];
                p[j-1] = p[j];
                p[j] = t;
            }
        }
    }
}

int compare(void *m, void *n)
{
    int *m1, *n1;
    m1 = (int *)m;
    n1 = (int *)n;
    return (*m1 &gt; *n1);
}

/*------------------ end of bubble_4.c ---------------------*/

Note that, in doing this, in compare() we had to introduce the casting of the void pointer types passed to the actual type being sorted. But, as we'll see later that's okay. And since what is being passed to bubble() is still a pointer to an array of integers, we had to cast these pointers to void pointers when we passed them as parameters in our call to compare().

We now address the problem of what we pass to bubble(). We want to make the first parameter of that function a void pointer also. But, that means that within bubble() we need to do something about the variable t, which is currently an integer. Also, where we use t = p[j-1]; the type of p[j-1] needs to be known in order to know how many bytes to copy to the variable t (or whatever we replace t with).

Currently, in bubble_4.c, knowledge within bubble() as to the type of the data being sorted (and hence the size of each individual element) is obtained from the fact that the first parameter is a pointer to type integer. If we are going to be able to use bubble() to sort any type of data, we need to make that pointer a pointer to type void. But, in doing so we are going to lose information concerning the size of individual elements within the array. So, in bubble_5.c we will add a separate parameter to handle this size information.

These changes, from bubble4.c to bubble5.c are, perhaps, a bit more extensive than those we have made in the past. So, compare the two modules carefully for differences.

/*---------------------- bubble5.c ---------------------------*/

/* Program bubble_5.c from PTRTUT10.HTM    6/13/97 */



#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

long arr[10] = { 3,6,1,2,3,8,4,1,7,2};

void bubble(void *p, size_t width, int N);
int compare(void *m, void *n);

int main(void)
{
    int i;
    putchar('\n');

    for (i = 0; i &lt; 10; i++)
    {
        printf("%d ", arr[i]);
    }
    bubble(arr, sizeof(long), 10);
    putchar('\n');

    for (i = 0; i &lt; 10; i++)
    {
        printf("%ld ", arr[i]);
    }

    return 0;
}

void bubble(void *p, size_t width, int N)
{
    int i, j;
    unsigned char buf[4];
    unsigned char *bp = p;

    for (i = N-1; i &gt;= 0; i--)
    {
        for (j = 1; j &lt;= i; j++)
        {
            if (compare((void *)(bp + width*(j-1)),
                        (void *)(bp + j*width)))  /* 1 */
            {
/*              t = p[j-1];   */
                memcpy(buf, bp + width*(j-1), width);
/*              p[j-1] = p[j];   */
                memcpy(bp + width*(j-1), bp + j*width , width);
/*              p[j] = t;   */
                memcpy(bp + j*width, buf, width);
            }
        }
    }
}

int compare(void *m, void *n)
{
    long *m1, *n1;
    m1 = (long *)m;
    n1 = (long *)n;
    return (*m1 &gt; *n1);
}

/*--------------------- end of bubble5.c ---------------------*/

Note that I have changed the data type of the array from int to long to illustrate the changes needed in the compare() function. Within bubble() I've done away with the variable t (which we would have had to change from type int to type long). I have added a buffer of size 4 unsigned characters, which is the size needed to hold a long (this will change again in future modifications to this code). The unsigned character pointer *bp is used to point to the base of the array to be sorted, i.e. to the first element of that array.

We also had to modify what we passed to compare(), and how we do the swapping of elements that the comparison indicates need swapping. Use of memcpy() and pointer notation instead of array notation work towards this reduction in type sensitivity.

Again, making a careful comparison of bubble5.c with bubble4.c can result in improved understanding of what is happening and why.

We move now to bubble6.c where we use the same function bubble() that we used in bubble5.c to sort strings instead of long integers. Of course we have to change the comparison function since the means by which strings are compared is different from that by which long integers are compared. And,in bubble6.c we have deleted the lines within bubble() that were commented out in bubble5.c.

/*--------------------- bubble6.c ---------------------*/
/* Program bubble_6.c from PTRTUT10.HTM   6/13/97 */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAX_BUF 256

char arr2[5][20] = {  "Mickey Mouse",

                      "Donald Duck",

                      "Minnie Mouse",

                      "Goofy",

                      "Ted Jensen" };

void bubble(void *p, int width, int N);
int compare(void *m, void *n);

int main(void)
{
    int i;
    putchar('\n');

    for (i = 0; i &lt; 5; i++)
    {
        printf("%s\n", arr2[i]);
    }
    bubble(arr2, 20, 5);
    putchar('\n\n');

    for (i = 0; i &lt; 5; i++)
    {
        printf("%s\n", arr2[i]);
    }
    return 0;
}

void bubble(void *p, int width, int N)
{
    int i, j, k;
    unsigned char buf[MAX_BUF];
    unsigned char *bp = p;

    for (i = N-1; i &gt;= 0; i--)
    {
        for (j = 1; j &lt;= i; j++)
        {
          k = compare((void *)(bp + width*(j-1)), (void *)(bp + j*width));
          if (k &gt; 0)
            {
             memcpy(buf, bp + width*(j-1), width);
             memcpy(bp + width*(j-1), bp + j*width , width);
             memcpy(bp + j*width, buf, width);
            }
        }
    }
}

int compare(void *m, void *n)
{
    char *m1 = m;
    char *n1 = n;
    return (strcmp(m1,n1));
}

/*------------------- end of bubble6.c ---------------------*/

But, the fact that bubble() was unchanged from that used in bubble5.c indicates that that function is capable of sorting a wide variety of data types. What is left to do is to pass to bubble() the name of the comparison function we want to use so that it can be truly universal. Just as the name of an array is the address of the first element of the array in the data segment, the name of a function decays into the address of that function in the code segment. Thus we need to use a pointer to a function. In this case the comparison function.

Pointers to functions must match the functions pointed to in the number and types of the parameters and the type of the return value. In our case, we declare our function pointer as:

   int (*fptr)(const void *p1, const void *p2);
Note that were we to write:

    int *fptr(const void *p1, const void *p2);
we would have a function prototype for a function which returned a pointer to type int. That is because in C the parenthesis () operator have a higher precedence than the pointer * operator. By putting the parenthesis around the string (*fptr) we indicate that we are declaring a function pointer.

We now modify our declaration of bubble() by adding, as its 4th parameter, a function pointer of the proper type. It's function prototype becomes:

    void bubble(void *p, int width, int N,
                int(*fptr)(const void *, const void *));
When we call the bubble(), we insert the name of the comparison function that we want to use. bubble7.c illustrate how this approach permits the use of the same bubble() function for sorting different types of data.

/*------------------- bubble7.c ------------------*/

/* Program bubble_7.c from PTRTUT10.HTM  6/10/97 */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAX_BUF 256

long arr[10] = { 3,6,1,2,3,8,4,1,7,2};
char arr2[5][20] = {  "Mickey Mouse",
                      "Donald Duck",
                      "Minnie Mouse",
                      "Goofy",
                      "Ted Jensen" };

void bubble(void *p, int width, int N,
            int(*fptr)(const void *, const void *));
int compare_string(const void *m, const void *n);
int compare_long(const void *m, const void *n);

int main(void)
{
    int i;
    puts("\nBefore Sorting:\n");

    for (i = 0; i &lt; 10; i++)               /* show the long ints */
    {
        printf("%ld ",arr[i]);
    }
    puts("\n");

    for (i = 0; i &lt; 5; i++)                  /* show the strings */
    {
        printf("%s\n", arr2[i]);
    }
    bubble(arr, 4, 10, compare_long);          /* sort the longs */
    bubble(arr2, 20, 5, compare_string);     /* sort the strings */
    puts("\n\nAfter Sorting:\n");

    for (i = 0; i &lt; 10; i++)             /* show the sorted longs */
    {
        printf("%d ",arr[i]);
    }
    puts("\n");

    for (i = 0; i &lt; 5; i++)            /* show the sorted strings */
    {
        printf("%s\n", arr2[i]);
    }
    return 0;
}

void bubble(void *p, int width, int N,
            int(*fptr)(const void *, const void *))
{
    int i, j, k;
    unsigned char buf[MAX_BUF];
    unsigned char *bp = p;

    for (i = N-1; i &gt;= 0; i--)
    {
        for (j = 1; j &lt;= i; j++)
        {
            k = fptr((void *)(bp + width*(j-1)), (void *)(bp + j*width));
            if (k &gt; 0)
            {
                memcpy(buf, bp + width*(j-1), width);
                memcpy(bp + width*(j-1), bp + j*width , width);
                memcpy(bp + j*width, buf, width);
            }
        }
    }
}

int compare_string(const void *m, const void *n)
{
    char *m1 = (char *)m;
    char *n1 = (char *)n;
    return (strcmp(m1,n1));
}

int compare_long(const void *m, const void *n)
{
    long *m1, *n1;
    m1 = (long *)m;
    n1 = (long *)n;
    return (*m1 &gt; *n1);
}

/*----------------- end of bubble7.c -----------------*/

References for Chapter 10:

"Algorithms in C"
Robert Sedgewick
Addison-Wesley
ISBN 0-201-51425-7</t>
<t tx="amd_yen.20130504232827.6216"></t>
<t tx="amd_yen.20130504232827.6219">@language python

import os
'''
c is the commander of the outline containing the script.
g is Leo's leo.core.leoGlobals module.
p is the presently selected position, the same as c.p.
'''
d = c.scanAllDirectives(p)
#g.es(d)
# d 為 commander 由目前所在目錄進行指令設定掃描
# d 資料格式為 dictionary
''' 
實際操作下, d 為 
{'tabwidth': -4, 'lineending': None, 'language': 'python', 'encoding': None, 'pluginsList': [], 'pagewidth': 70, 'wrap': True, 'path': 'D:\\github\\mdeCourse\\2013spring', 'delims': ('#', '', '')}
'''
# 將目錄指到 latex
mandir = d.get('path') + "/c2wp/resume"
g.es(mandir)
os.chdir(mandir)
target_name = "myresume"
filename = target_name+".tex"
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
filename = target_name+".xdv"
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xdvipdfmx.exe -vv -E "+filename)

filename = target_name+".pdf"
os.system(filename)</t>
<t tx="amd_yen.20130504232827.8947"></t>
<t tx="amd_yen.20130504232827.8948">@language python

import os
'''
c is the commander of the outline containing the script.
g is Leo's leo.core.leoGlobals module.
p is the presently selected position, the same as c.p.
'''
d = c.scanAllDirectives(p)
#g.es(d)
# d 為 commander 由目前所在目錄進行指令設定掃描
# d 資料格式為 dictionary
''' 
實際操作下, d 為 
{'tabwidth': -4, 'lineending': None, 'language': 'python', 'encoding': None, 'pluginsList': [], 'pagewidth': 70, 'wrap': True, 'path': 'D:\\github\\mdeCourse\\2013spring', 'delims': ('#', '', '')}
'''
# 將目錄指到 latex
mandir = d.get('path') + "/lshort"
g.es(mandir)
os.chdir(mandir)
target_name = "lshort"
filename = target_name+".tex"
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename+" -output-directory=_build")
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename+" -output-directory=_build")
filename = target_name+".xdv"
os.chdir("_build")
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xdvipdfmx.exe -vv -E "+filename)

filename = target_name+".pdf"
os.system(filename)</t>
<t tx="amd_yen.20130506144326.2650">@language python

import os
os.system("eric5")

'''詳細說明請參考
#KMOL Guide--&gt;程式語言(二)--&gt;@file c2.txt--&gt;@rst document\c2.html--&gt;C2 第十二週--&gt;Python 程式開發 IDE
'''</t>
<t tx="mde_leo.20130508162404.2651">瀏覽器: http://code.google.com/p/qtweb/</t>
<t tx="mde_leo.20130510215619.6870">LaTeX 是一套排版系統, 而 Word 則是一套文書處理系統, 兩者是不同屬性的工具, 但是對某些使用者而言, 這兩者都能夠將文字與圖形內容轉換為 pdf, 因此仍然必須針對兩者的特性進行比較, 以便讓使用者在不同需求選擇最適用的工具.

編寫長篇科學文件的環境需求不同於一般文書處理工作. 長篇科學文件處理的目的在產生工程師所要表達的結果, 這些結果通常含有許多交互參照的數學方程式與文獻資料管理, 若以資料處理專業者的認知來說, 使用 LaTeX 排版流程, 較能得到令人滿意的結果, 其中包括數學方程式列印與字距配置結果.

以下就是針對在不同使用需求下, LaTeX 與 Word 的特性比較.

Word 擅長領域:

- 快速處理較短的文件(百頁以內), 內容帶有較少的數學符號與方程式.

- (因為 LaTeX 基本流程分為內容準備與格式輸出等兩階段, 內容準備階段通常無所見即所得的即時顯示功能)

- 操作流程較為直覺, 一般功能的學習速度較快.

- (LaTeX 操作流程較不直覺, 使用者必須具備基本的標註使用能力)

- 通用性較佳

- (許多人對於 LaTeX 的特性與概念較為生疏, 初學者經常望而卻步)

LaTeX 擅長領域:

- 適合處理較長的文件(超過百頁), 因為資料內容準備時, 無需花費時間在格式化的資料輸出處理.

- (Word 通常在資料準備過程就必須設定各種為了所見即所得資料處理所需的格式設定.)

- 文件輸出結果比較令人滿意, 多人協同處理專業文書出版過程較具效率.

- 參考資料: http://nitens.org/taraborelli/latex

-(採用 Word 處理數學符合或方程式的結果較差)

- 許多專業編輯的功能較為完整 (尤其是針對交互參照、文獻管理與引用), 幾乎可以處理任何領域資料排版(樂譜)

- (非常特殊的專業排版功能必須額外購買)

- 完全開放的套件內容, 自由且免費.

- (Word 為商用系統, 必須花錢購買, 且特殊的系統功能延伸較受限制(因為 Word 的套件位階高於 LaTeX 排版程式))

何時用 LaTeX? 何時用 Word? 仔細閱讀下列資料後, 應該就會有答案.

http://standardwisdom.com/softwarejournal/2010/12/word-latex-comparison/</t>
<t tx="mde_leo.20130510215619.7355">機械設計牽涉機械、設計與其過程所涉各項事物的管理與表達.

管理的目的在提升效能, 而表達的目標則在增進溝通, 降低過程中不同團隊成員間產生謬誤與衝突的機會.

機械設計所需的能力:

1. 產生想法與表達想法的能力 - 如何產生構想與創意、如何表達構想與創意等.

2. 評量想法所需的理論知識能力 - 評量所設計產品所需成本、採用何種方法完成某一事物、所能達到的產品品質、推出市場所需的時間、製造所需的技術等.

3. 累積經驗的能力 - 如何整理經驗、如何管理經驗過程中所積壘的資料.

4. 與其他專業團隊成員溝通的能力 - 溝通的本質在於透明與全盤托出事物的核心價值.</t>
<t tx="mde_leo.20130510215619.7356"></t>
<t tx="mde_leo.20130510215619.7357"></t>
<t tx="mde_leo.20130510215619.7358"></t>
<t tx="mde_leo.20130510215619.7359"></t>
<t tx="mde_leo.20130510215619.7360">指已經存在的商用或自由軟體套件, 可用來輔助操作者進行機械設計</t>
<t tx="mde_leo.20130510215619.7361">指由操作者編寫程式, 用來延伸既有套件的功能, 以擴增設計效益.</t>
<t tx="mde_leo.20130510215619.7362">指整體架構完全由設計者自行編寫建構的程式工具或套件系統</t>
<t tx="mde_leo.20130510215619.7363"></t>
<t tx="mde_leo.20130510215619.7364"></t>
<t tx="mde_leo.20130510215619.7365"></t>
<t tx="mde_leo.20130510215619.7366"></t>
<t tx="mde_leo.20130510215619.7367"></t>
<t tx="mde_leo.20130510215619.7368"></t>
<t tx="mde_leo.20130510215619.7369"></t>
<t tx="mde_leo.20130510215619.7370"></t>
<t tx="mde_leo.20130510215619.7371"></t>
<t tx="mde_leo.20130510215619.7372"></t>
<t tx="mde_leo.20130510215619.7373"></t>
<t tx="mde_leo.20130510215619.7374"></t>
<t tx="mde_leo.20130510215619.7375"></t>
<t tx="mde_leo.20130510215619.7376"></t>
<t tx="mde_leo.20130510215619.7377"></t>
<t tx="mde_leo.20130510215619.7378"></t>
<t tx="mde_leo.20130510215619.7379"></t>
<t tx="mde_leo.20130510215619.7380"></t>
<t tx="mde_leo.20130510215619.7381"></t>
<t tx="mde_leo.20130510215619.7382"></t>
<t tx="mde_leo.20130510215619.7383"></t>
<t tx="mde_leo.20130510215619.7384"></t>
<t tx="mde_leo.20130510215619.7385"></t>
<t tx="mde_leo.20130510215619.7386"></t>
<t tx="mde_leo.20130510215619.7387"></t>
<t tx="mde_leo.20130510215619.7388"></t>
<t tx="mde_leo.20130510215619.7389"></t>
<t tx="mde_leo.20130510215619.7390">指使用者利用電腦與網路搜尋與設計內容相關的資料

取用他人所提供的相關設計資料</t>
<t tx="mde_leo.20130510215619.7391">指由設計者利用網路, 搭建自我團隊可運用之程式, 以達到增進設計效益的目的.

經由各種方法接收基本資料, 經過處理或運算成為其他可引用的設計資料</t>
<t tx="mde_leo.20130510215619.7392">指在設計者的搭建下, 由機器對機器, 經由網路, 自動傳輸所需的設計相關資料.

例如, 分散機械設計系統與自動資料備份系統</t>
<t tx="mde_leo.20130510215619.7393"></t>
<t tx="mde_leo.20130510215619.7394"></t>
<t tx="mde_leo.20130510215619.7395"></t>
<t tx="mde_leo.20130510215619.7396"></t>
<t tx="mde_leo.20130510215619.7397"></t>
<t tx="mde_leo.20130510215619.7398"></t>
<t tx="mde_leo.20130510215619.7399"></t>
<t tx="mde_leo.20130510215619.7400"></t>
<t tx="mde_leo.20130510215619.7401"></t>
<t tx="mde_leo.20130510215619.7402">專門用來提供資料給使用者的電腦</t>
<t tx="mde_leo.20130510215619.7403">以近距離組合的方式組成一可共享運算資源的電腦</t>
<t tx="mde_leo.20130510215619.7404">電腦主機分散在不同位置而組成一個可彼此共享運算資源的組合

與叢集電腦相比, 以較長距離組合的方式組成一可共享運算資源的電腦</t>
<t tx="mde_leo.20130510215619.7405">具有非常多核心運算單元的電腦</t>
<t tx="mde_leo.20130510215619.7406">特指可採用虛擬模式, 及時依照使用負載而彈性配置運算與資料儲存單元的電腦組合.</t>
<t tx="mde_leo.20130510215619.7407">輕便且使用者可隨身攜帶, 具有螢幕與鍵盤滑鼠等配置的電腦</t>
<t tx="mde_leo.20130510215619.7408">輕便且使用者可隨身攜帶, 並且只具有螢幕的電腦</t>
<t tx="mde_leo.20130510215619.7409">主要功能用於個人通訊, 但仍提供基本電腦功能之裝置.</t>
<t tx="mde_leo.20130510215619.7410">本身具有運算單元主體的小型電子裝置.</t>
<t tx="mde_leo.20130510215619.7411"></t>
<t tx="mde_leo.20130510215619.7412">經由物理性質的改變而感知之電子裝置</t>
<t tx="mde_leo.20130510215619.7413">傳遞數據或資料的電子裝置</t>
<t tx="mde_leo.20130510215619.7414">無需實體連線, 即可藉以操作控制某一裝置的資訊傳遞元件</t>
<t tx="mde_leo.20130510215619.7415">提供資料運算或分析的小型電子裝置</t>
<t tx="mde_leo.20130510215619.7416">指該項事物並非主體, 而是從體.</t>
<t tx="mde_leo.20130510215619.7417"></t>
<t tx="mde_leo.20130510215619.7418">指從電腦與使用者之間的互動模式自動化與否進行分類</t>
<t tx="mde_leo.20130510215619.7419">指設計者只需將設計需求告知電腦套件或程式, 由電腦設法找出可行設計方案或最佳設計方案</t>
<t tx="mde_leo.20130510215619.7420">指由操作者與電腦程式或套件, 以對談互動的模式進行機械設計</t>
<t tx="mde_leo.20130510215619.7421">利用電腦(網路)程式, 設法增進電腦或其操作者更高的設計效率.</t>
<t tx="mde_leo.20130510215619.7422">指依照採用不同的設計原理來加以輔助的角度進行分類</t>
<t tx="mde_leo.20130510215619.7423"></t>
<t tx="mde_leo.20130510215619.7424"></t>
<t tx="mde_leo.20130510215619.7425"></t>
<t tx="mde_leo.20130510215619.7426"></t>
<t tx="mde_leo.20130510215619.7427"></t>
<t tx="mde_leo.20130510215619.7428"></t>
<t tx="mde_leo.20130510215619.7429"></t>
<t tx="mde_leo.20130510215619.7430"></t>
<t tx="mde_leo.20130510215619.7431"></t>
<t tx="mde_leo.20130510215619.7432"></t>
<t tx="mde_leo.20130510215619.7433"></t>
<t tx="mde_leo.20130510215619.7434"></t>
<t tx="mde_leo.20130510215619.7435"></t>
<t tx="mde_leo.20130510215619.7436"></t>
<t tx="mde_leo.20130510215619.7437"></t>
<t tx="mde_leo.20130510215619.7438"></t>
<t tx="mde_leo.20130510215619.7439"></t>
<t tx="mde_leo.20130510215619.7440"></t>
<t tx="mde_leo.20130510215619.7441"></t>
<t tx="mde_leo.20130510215619.7442"></t>
<t tx="mde_leo.20130510215619.7443"></t>
<t tx="mde_leo.20130510215619.7444">指從事與力學相關的工程設計, 且其產品元件或組成會隨時間而改變其屬性的設計.

</t>
<t tx="mde_leo.20130510215619.7445">設計

是一種溝通與協同的創造性活動

設計的本質是講道理, 定計畫, 勤執行, 做紀錄, 忙修改的求同步重複遞迴行動

也就是

    講道理 - 要有所本
    定計畫 - 要有條理
    勤執行 - 要說到做到
    做紀錄 - 要鉅細靡遺
    忙修改 - 要修補漏洞
    求同步 - 要積極進取
    重複遞迴 - 可收斂的設計才是成功的設計
</t>
<t tx="mde_leo.20130510215619.7446"></t>
<t tx="mde_leo.20130510215619.7447"></t>
<t tx="mde_leo.20130510215619.7448"></t>
<t tx="mde_leo.20130510215619.7449"></t>
<t tx="mde_leo.20130510215619.7450"></t>
<t tx="mde_leo.20130510215619.7451">指採用既有之通用設計與規格之機械元件進行設計</t>
<t tx="mde_leo.20130510215619.7452">指完全由設計者量身打造, 可專屬使用之機械元件, 通常由專屬機械元件所組成之設計產品可包含相關的產品專利與特有設計工具或技術</t>
<t tx="mde_leo.20130510215619.7453"></t>
<t tx="mde_leo.20130510215619.7454"></t>
<t tx="mde_leo.20130510215619.7455"></t>
<t tx="mde_leo.20130510215619.7456"></t>
<t tx="mde_leo.20130510215619.7457"></t>
<t tx="mde_leo.20130510215619.7458"></t>
<t tx="mde_leo.20130510215619.7459"></t>
<t tx="mde_leo.20130510215619.7460"></t>
<t tx="mde_leo.20130510215619.7461"></t>
<t tx="mde_leo.20130510215619.7462"></t>
<t tx="mde_leo.20130510215619.7463"></t>
<t tx="mde_leo.20130510215619.7464"></t>
<t tx="mde_leo.20130510215619.7465"></t>
<t tx="mde_leo.20130510215619.7466"></t>
<t tx="mde_leo.20130510215619.7467"></t>
<t tx="mde_leo.20130510215619.7468"></t>
<t tx="mde_leo.20130510215619.7469"></t>
<t tx="mde_leo.20130510215619.7470"></t>
<t tx="mde_leo.20130510215619.7471"></t>
<t tx="mde_leo.20130510215619.7472"></t>
<t tx="mde_leo.20130510215619.7473"></t>
<t tx="mde_leo.20130510215619.7474"></t>
<t tx="mde_leo.20130510215619.7475"></t>
<t tx="mde_leo.20130510215619.7476"></t>
<t tx="mde_leo.20130510215619.7477"></t>
<t tx="mde_leo.20130510215619.7478"></t>
<t tx="mde_leo.20130510215619.7479"></t>
<t tx="mde_leo.20130510215619.7480"></t>
<t tx="mde_leo.20130510215619.7481"></t>
<t tx="mde_leo.20130510215619.7482"></t>
<t tx="mde_leo.20130510215619.7483"></t>
<t tx="mde_leo.20130510215619.7484"></t>
<t tx="mde_leo.20130510215619.7485"></t>
<t tx="mde_leo.20130510215619.7486"></t>
<t tx="mde_leo.20130510215619.7487"></t>
<t tx="mde_leo.20130510215619.7488"></t>
<t tx="mde_leo.20130510215619.7489"></t>
<t tx="mde_leo.20130510215619.7490"></t>
<t tx="mde_leo.20130510215619.7491"></t>
<t tx="mde_leo.20130510215619.7492"></t>
<t tx="mde_leo.20130510215619.7493"></t>
<t tx="mde_leo.20130510215619.7494"></t>
<t tx="mde_leo.20130510215619.7495"></t>
<t tx="mde_leo.20130510215619.7496"></t>
<t tx="mde_leo.20130510215619.7497"></t>
<t tx="mde_leo.20130510215619.7498"></t>
<t tx="mde_leo.20130510215619.7499"></t>
<t tx="mde_leo.20130510215619.7500"></t>
<t tx="mde_leo.20130510215619.7501"></t>
<t tx="mde_leo.20130510215619.7502"></t>
<t tx="mde_leo.20130510215619.7503">設計就是設想然後加以評量, 最後將經過設想與評量的結果表示出來.  因此設計牽涉至少三個步驟:

1. 設想 - 所謂設想就是在尚未落實與評價之前, 對於某一事物執行過程的想法, 可以是初步的原始概念, 也可以是根據現況加以修改的想法.

2. 評量 - 就是採用各種可行方法對設想的內容加以評價, 判定想法是否可行, 或者思考或實際驗證採用哪一做法可以得到更好的預期結果.

3. 呈現出結果 - 利用其他人可以充分理解或接受的表示方法, 將設想與評量結果表達出來.

範例:

設計的動機 - 在校園裡的自行車經常會遭竊, 因此希望能夠有一種自行車在不使用時, 能夠降低遭竊的機會.

設想階段 - 根據自行車產品遭竊的流程, 就是因為自行車僅使用簡單的鎖具, 因此保全度不佳, 設計的想法之一就是加強鎖固自行車的設施.

而另一種設計的想法則是, 讓自行車"始終"在使用者的身邊, 可以再不使用時摺疊成可以隨身攜帶的狀況, 因此另外一種設計的想法就是減輕自行車的重量, 縮小摺疊後的體積.

完成基本的設想階段後, 就是評量"加強鎖固自行車的設施" 與 "輕量可摺疊隨身" 的自行車與附件產品的進一步設計構想與細節驗證等.

而最後的設計結果, 就是根據想法與驗證, 將可行方案的執行方式細節完整表達.</t>
<t tx="mde_leo.20130510215619.7504">達成目的的最簡單做法
最經濟的做法 (整體產品生命週期過程中成本最低者)
所需時間最短的做法
產品容易使用與維修 (護) - 符合人體工學與本能操作流程
擁有最長使用壽命
外觀容易為使用者接受 (賞心悅目)
採用先進並符合潮流之技術</t>
<t tx="mde_leo.20130510215619.7505">創新設計 (原創設計) - 產出前所未有的新穎與高性能設計內容, 重點在於 innovation 創新

概念設計 (重新設計) - 根據構想、方法或工具的激發, 大致安排所需的內容設計, 重點在於 concept 概念

參數設計 - 基本概念已經決定, 但是必須根據所需的產品規格來調整變化產品的設計參數, 以調配出所需的設計元件, 重點在於 parametric 改變與組合

配置設計 - 基本元件參數已經決定, 但是必須從這些基本的元件加以組合, 配置成不同的設計以進行評估及選擇, 重點在於 configuration 配置

元件細部設計 - 配置方法已經決定, 但必須從既有的標準元件中選擇適合規格與性能的設計元件, 重點在於 selection 選擇</t>
<t tx="mde_leo.20130510215619.7506">機械為經過機巧安排的器械, 通常牽涉利用能量的轉換來達成機巧的安排, 固力的機巧安排通常為機構, 而流力的機巧安排則牽涉到熱與流體的能量交換.</t>
<t tx="mde_leo.20130510215619.7507">力學 - 靜力學、動力學、材料力學、熱力學、流體力學

機構 - 機構學、機動學、機器動力學

數學 - 微積分、工程數學、工程分析、變分學

控制 - 電子學、電路學、振動學、自動控制

程式 - 程式語言、網際程式、資料庫程式、專利寫作實務

管理 - 內容管理、產品資料管理、產品生命週期管理、工廠管理

設計 - 電腦輔助設計、協同產品設計、機械元件設計、機械系統設計、系統整合設計

分析 - 電腦輔助工程分析、機械系統分析與模擬

製造 - 工廠實習、機械製圖、機械公差、夾治具設計、工具機實習、模具設計、非傳統加工
</t>
<t tx="mde_leo.20130510215619.7508">設計運算 - design computatin

設計繪圖 - design graphics

設計模擬 - design animation

設計資料管理 - design data management (包括文書處理與資料處理或轉換)</t>
<t tx="mde_leo.20130510215619.7509">設計分工以爭取時效 - 將大任務分成許多部份由多人同步開展

專業分工以提升產品品質 - 以全球觀點尋找最適合團隊 (搭配性、技術性、互補性等) 來進行產品某部分專業的設計

區域分工以降低產品成本 - 依照產品材料取得與設計、製造、行銷或回收等成本考量, 由不同地理區域團隊分工執行

策略分工以防止核心技術外流或侵權 - 依照產品技術拆解或專利部署考量, 廠商間進行交叉代工合作</t>
<t tx="mde_leo.20130510215619.7510">趨勢發展:

Python 與 CUDA

http://mathema.tician.de/software/pycuda</t>
<t tx="mde_leo.20130510215619.7519">為了推廣 Leo 編輯器的使用, 將要先設法打造一套可以在 Win32 環境中使用的基本 Leo 編輯器可攜套件, 步驟如下:

1. 從 http://www.python.org/download/ 下載 Python 3.3.1, 安裝時 Doc 與 test scripts 不安裝, 容量大約 26 MB.

2. 接著從 http://www.lfd.uci.edu/~gohlke/pythonlibs/#distribute 下載 distribute-0.6.36.win32-py3.3.‌exe, 安裝後約佔 30MB.

3. 接著從 http://www.lfd.uci.edu/~gohlke/pythonlibs/#pip 下載 pip-1.3.1.win32-py3.3.‌exe, 安裝後約佔 32MB.

4. 接著從 http://sourceforge.net/projects/pywin32/files/pywin32/Build%20218/ 下載 pywin32-218.win32-py3.3.exe, 安裝後約佔 58MB.

5. 接著從 http://www.riverbankcomputing.com/software/pyqt/download 下載 PyQt4-4.10-gpl-Py3.3-Qt5.0.1-x32-2.exe, Doc 與 Examples 不安裝, 安裝後約佔 166MB.

註: 因為安裝 PyQt4/Qt5 必須要從 http://www.microsoft.com/en-us/download/search.aspx?q=directx 更新 directx, 對於沒有更新的電腦就無法讓 Leo Editor 擷取到最新的 directx dll, 因為這不是 Leo 編輯器的問題, 而是 PyQt4 連結 Qt5 dll 所造成的問題, 目前還不知道 PyQt5 是否可以在未更新 directx 的情況下讓 2014 年即將退役的 Windows XP 正常使用 Qt5 的 dll, 因此依賴 PyQt 的 Leo Editor 根本無法主動修改, 只有兩條路可以走, 就是在 PyQt4 配合 Qt5  的情況下, 更新 Windows 的 directx, 或者是回到 PyQt4 與 Qt4 的搭配, 等待 PyQt5 與 Qt5 的版本到來, 然後再看是否能在未更新 dirextx 或更新 directx 的操作系統中彼此相容.

這裡我們選擇在 PyQt4/Qt4 的模式下來啟動 Leo 編輯器, 也就從  http://www.riverbankcomputing.com/software/pyqt/download 下載 PyQt4-4.10-gpl-Py3.3-Qt4.8.4-x32.exe, 而非 PyQt4-4.10-gpl-Py3.3-Qt5.0.1-x32-2.exe.

6. 接著從 http://www.lfd.uci.edu/~gohlke/pythonlibs/#docutils 下載 docutils-0.10.win32-py3.3.‌exe, 安裝後約佔 172MB.

7. 接著從 http://www.greygreen.org/leo/ 下載 leo-editor-snapshot-20130408.zip, 解開後將 leo 目錄放到 C:\Python33\Lib\site-packages\, 整個 C:\Python33 約為 190MB.

 安裝至此, 雖然 Leo Editor 已經可以在單機啟動, 但是我們卻希望將 Leo 編輯器放到隨身碟上工作, 因此將 C:\Python33 整個目錄複製到 C:\leoeditor\data\ 目錄中, 然後將上面 7 個步驟的安裝, 利用系統移除程式進行反安裝, 最後當然就是刪除 C:\Python33.

接下來, 希望除了 Leo 編輯器外, 還要有一個可以解譯 Python3 與簡單 C 程式的搭配用文字編輯器, 可以從 http://www.scintilla.org/SciTEDownload.html 下載 http://prdownloads.sourceforge.net/scintilla/wscite330.zip?download, 解開後將 wscite 目錄, 放入 C:\leoeditor\data 目錄中.

接下來, 則從 http://download.savannah.gnu.org/releases/tinycc/ 下載 tcc-0.9.26-win32-bin.zip, 解開後將 tcc 目錄,  放入 C:\leoeditor\data 目錄中.

截至目前, 我們在 C:\leoeditor\data 目錄中共有 Python33, wsite 與 tcc 等三個目錄, Python33 是從正式安裝 C:\Python33 複製得來, wscite 目錄則將用來編輯文件或解譯 Python3 與 C 程式, 而 tcc 目錄中則有完整的 TinyC 0.9.26 版本程式, 接下來則是要讓此一 Leo Editor 能夠正常啟動的設定工作, 而這些設定所需要的檔案, 可以利用 wscite 目錄中的 SciTE.exe 編輯取得.

以下則為此一可攜 Leo Editor 系統的設定步驟:

1. 開啟 wcite/SciTE.exe, 選擇 Options-&gt;Open Global Options File, 找到 code.page=0, 然後改為 code.page=65001, 表示要將原先設為系統編碼 (在 Windows XP 中為 Big-5) 改為 65001 編碼, 也就是改為 UTF-8 編碼, 另外再新增一個 output.code.page=0 設定, 表示輸出編碼則選用系統編碼.

2. 接著選擇 Options-&gt;Open cpp.properties 檔案, 將 C 程式的編譯指定給 tcc 處理:
#ccopts=-pedantic -Os
cc=y:/tcc/tcc.exe -run
ccc=y:/tcc/tcc.exe -run
command.go.*.c=$(cc) $(FileNameExt)
#command.go.*.c=./$(FileName)
 
修改之後, 就可以直接在 SciTE 中編輯一個 .c 的小程式, 然後選擇 Tools-&gt;Go 就可以在輸出區看到執行結果.
 
3. 接著選擇 Options-&gt;Open python.properties 檔案, 將 Python 程式的解譯指定給 y:\Python33\pythonw.exe 處理:
 
if PLAT_WIN
command.go.*.py=y:\Python33\pythonw -u "$(FileNameExt)"
 
修改之後, 就可以編輯一個 .py 程式, 然後選擇 Tools-&gt;Go 執行.

4. 接著再編輯 start.bat, stop.bat 與 README.md 等三個檔案, 內容如下:

start.bat 內容:
@echo off
REM 設定 y 硬碟代號與 data 目錄對應
set Disk=y
subst %Disk%: "data"
REM 將後續的指令執行, 以 %Disk% 為主
%Disk%:
REM 設定 PYTHONPATH
set PYTHONPATH=%Disk%:\Python33
REM 設定 Leo 所用的編輯器
set LEO_EDITOR=%Disk%:\wscite\SciTE.exe
REM 指令搜尋路徑設定
set path1=%PATH%;%Disk%:\commands;%Disk%:\Python33;%Disk%:\Python33\Lib\site-packages\;
set path2=%Disk%:\Python33\Lib\site-packages\pywin32_system32;%Disk%:\Python33\Scripts;
path=%path1%;%path2%
REM 啟動 SciTE 編輯器
start %Disk%:\wscite\SciTE.exe
REM 以最小畫面開啟兩個指令視窗備用
start cmd.exe /MIN
start cmd.exe /MIN
REM 啟動 Leo 編輯器
%Disk%:\Python33\python.exe %Disk%:\commands\launchLeo.py
EXIT
 
stop.bat 內容:
 
@echo off
set Disk=y
REM 關閉 python
taskkill /IM python.exe /F
path=%PATH%;
subst %Disk%: /D
REM 關閉 cmd 指令視窗
taskkill /IM cmd.exe /F
EXIT
 
README.md 內容:
 
portable leoeditor
===================
 
Portable Leo Editor for win32 system.
 
Files structure:
 
Directories:
 
data/wsite - SciTE editor
data/Python33 - Python 3.3.1 interpreter
data/tcc - TinyC compiler
data/commands - all the commands
data/examples - example files
README.md
start.bat
stop.bat
 
5. 最後, 啟動 start.bat, 就可以自動開啟 SciTE 與 Leo Editor, 開始進入 Leo 編輯器的探索之旅, 關閉系統則執行 stop.bat.
 
6. 下載可攜 Leo Editor - 共有兩個檔案: portable_leoeditor_20130409.7z.001 與 portable_leoeditor_20130409.7z.002, 在 Windows 環境下, 利用 7zip 解開後就可以執行.
 
https://sites.google.com/a/mde.tw/service/public/portable_leoeditor_20130409.7z.001?attredirects=0&amp;d=1
 
https://sites.google.com/a/mde.tw/service/public/portable_leoeditor_20130409.7z.002?attredirects=0&amp;d=1
</t>
<t tx="mde_leo.20130510215619.7520">有關 @chapters 的用法

為何使用 @auto-rst

使用 @@pagewidth 70 以及 @@language rest

針對特定 tree 執行 rst3 的指令: c.rstCommands.rst3()

</t>
<t tx="mde_leo.20130510215619.7521">1. 下載可攜 Leo Editor - 共有兩個檔案: portable_leoeditor_20130409.7z.001 與 portable_leoeditor_20130409.7z.002, 在 Windows 環境下, 利用 7zip 解開後就可以執行.

https://sites.google.com/a/mde.tw/service/public/portable_leoeditor_20130409.7z.001?attredirects=0&amp;d=1

https://sites.google.com/a/mde.tw/service/public/portable_leoeditor_20130409.7z.002?attredirects=0&amp;d=1

2. 假如您不想要使用上述的可攜版本, 可以參考 http://main.kmol.info/?Python_Leo_editor 中的說明, 自行打造, 在建立此一可攜 Leo Editor 系統的同時, 有一個重要的 PyQt 設定步驟, 先前忘了說明, 也就是 leoeditor\data\Python33 目錄下的 qt.conf 設定檔案, 內容必須與可攜系統中的 Python33 搭配, 也就是必須改為:

[Paths]
Prefix = y:/Python33/Lib/site-packages/PyQt4
Binaries = y:/Python33/Lib/site-packages/PyQt4

其中指定了 PyQt4 的安裝目錄, 假如沒能正確設定, Leo Editor 開啟後, 特定的小圖像將會無法顯示.

3. 當使用者執行 start.bat 後, 系統會將 leoeditor 目錄中的 data 目錄與 Y: 硬碟對應, Y:\ 硬碟中的檔案其實就是 leoeditor/data 目錄, 兩個目錄為同步對應.

假設將上述兩個壓縮檔案下載後, 直接解開到 C:\Documents and Settings\amd\My Documents\Downloads\leoeditor, 然後就可以點擊其中的 start.bat, 將會分別開啟兩個 cmd.exe 視窗, SciTE 編輯器與 Leo Editor, 這時進入 Y: 硬碟, 就可以看到 commands, exammples, Python33, tcc 與 wscite 等五個目錄, 其中 Python33 為可攜的 Python 3.3.1, tcc 為 TinyC 編譯程式, scite 則為 SciTE 編輯器.

啟動 Leo Editor 後, 使用者可以利用 http://leoeditor.com/ 中的說明, 逐步了解如何使用 Leo 編輯器, 以下為幾個使用上的關鍵點:

1. Leo Editor 的啟動設定分為系統設定與使用者設定, 系統設定可以從下拉式功能表 Help-&gt;Open leoSettings.leo 中開啟看到內容, 其中最重要的設定之一就是畫面相關字型大小的設定, 也就是標題為 @data qt-gui-plugin-style-sheet 的內容設定.

由於 Leo Editor 是一個大綱編輯器, 當使用者利用下拉式功能表 File-&gt;New 一個檔案後, 視窗正中央會出現三個不同顏色的視窗, 淺黃色的視窗稱為大綱標題視窗, 淡綠色則為 Log 視窗, 而淡紅色的則為與大綱標題對應的內容視窗, 新開一個大綱檔案後, 會有一個 NewHeadline 的標題 (稱為 outline head), 而其對應內容區 (稱為 outline body) 則為空內容.

當使用者從 Help-&gt;Open leoSettings.leo 開啟系統設定後, 可以利用 ctrl+f 啟動螢幕下方淡藍色的 Minibuffer 區, 當使用者利用 ctrl 按鍵加上 f 表示要輸入搜尋關鍵字, Minibuffer 區就會自動出現 Search, 並且等待使用者輸入關鍵字, 這時若在 Search: 之後輸入 style-sheet, 然後按下 Enter,  Leo Editor 就會自動停留到標題為 @data qt-gui-plugin-style-sheet 的節點 (稱為 node), 而 @data qt-gui-plugin-style-sheet 標題節點的內容就視用來設定 Leo Editor 的各項顯示, 其中包括目前畫面各區域的字元大小設定.

QTreeWidget 設定為節點標題字型設定, QTextEdit 為 log 區字型設定, QTextEdit#richTextEdit 則為節點內文字型設定, QLabel 則為 Minibuffer 區的字型設定.

一勞永逸的做法可以將 leoSettings.leo 中 @data qt-gui-plugin-style-sheet 節點內容 12px 全部改為 18px, 重新開啟 Leo Editor 後, 就會依照新的設定顯示, 但是在 Leo 4.11 20130408 版本使用的結果顯示, 若隨後開啟的 .leo  檔案中有 @data qt-gui-plugin-style-sheet 節點內容, 則 Leo 會全部以新設定來顯示畫面中的內容.

而更具彈性的做法則是在各別 .leo 檔案中設定 @data qt-gui-plugin-style-sheet 節點內容, 一旦開啟此 .leo 檔案, 系統就會以此設定來顯示畫面中的各區域內容.

2. 開始建立大綱標題與內容

利用 File-&gt;New 開啟一個新的 .leo 檔案, 然後利用 ctrl + i 插入一個大綱標題, 其他的操作為:

ctrl + i 插入 (insert) 大綱節點

ctrl + r 將所選擇的大綱節點往右邊 (right) 移動

ctrl + l 將所選擇的大綱節點往左邊 (left) 移動

ctrl + u 將所選擇的大綱節點往上方 (up) 移動

ctrl + d 將所選擇的大綱節點往下邊 (down) 移動

ctrl + s 存檔

使用者可以從 https://sites.google.com/a/mde.tw/service/public/tutorial1.leo?attredirects=0&amp;d=1 下載 tutorial1.leo 檔案.

3. 下載 tutorial1.leo 開啟後, 就可以利用滑鼠點按 newHeadline 兩次, 編輯節點標題, 移到下方的淡紅色對應內文區, 就可以輸入與 newHeadline 對應的大綱內容.

在這個簡單的 Leo Editor 使用說明裏, 我們說明了如何下載或建立可攜的 Leo Editor 編輯器系統, 啟動後, 開啟 tutorial1.leo 就可以讓 Leo Editor 使用 @data qt-gui-plugin-style-sheet 節點中的設定 ,假如這時再以 Help-&gt;Open leoSettings.leo 檔案, Leo Editor 又會以 leoSettings.leo 中的小字型 (12px) 設定來顯示畫面中的各區內容.

另外, File-&gt;Recent Files 下, 使用者可以選擇先前已經開啟的 .leo 檔案或清除 Recent Files 紀錄, clear 應該是暫時清除 Recent Files 顯示, 而 clean 應該就是將存在系統中的紀錄刪除 (實際測試好像看不出 clear 與 clean 的差別).

好了, 你已經完成了最基本的 Leo Editor 操作, 接下來就是如何利用 Leo Editor 與外部檔案進行互動.</t>
<t tx="mde_leo.20130510215619.7522">首先, 我們為了要方便啟動 Leo Editor, 可以在 commands 目錄下建立一個 start_leo.bat, 內容為:

y:\Python33\python.exe y:\commands\launchLeo.py

使用者只要在 cmd 對應視窗中, 執行 start_leo, 就可以開啟 Leo Editor.

在這個教學流程中, 我們將會使用幾個 Leo Editor 特定的 @language, @path 以及 @auto 指令, 其中 @language 用於節點內文, 而 @path 與 @auto 都是節點標題中的指令.

1. 利用 Leo 編輯器打開 tutorial1.leo, 我們已經學會如何利用 ctrl + i 增加節點, 也學會如何利用 ctrl + r, l, u, d 等四個快捷鍵移動所選擇的節點, 也知道可以利用 ctrl  + s 進行存檔.

接下來我們就先在最外圍的區域以 ctrl + i 增加一個節點, 我們在節點標題輸入"建立外部檔案", 並且在此節點的下一階, 建立另外一個節點, 也就是在最外部建立節點後, 以 ctrl + r 向右移動.

這個附屬於"建立外部檔案"第二階的節點標題, 我們輸入 @path tutorial2, 而這個標題為"@path tutorial2" 的節點內文則保持空白, 然後在"@path tutorial2" 節點的再下一階則再利用 ctrl + i 建立另一個節點, 而且標題輸入"@auto tut2.py", 內文則輸入:

@language python
#coding: utf-8

for 索引 in range(5):
    print("第"+str(索引)+"行執行 Python 程式")

完成上述三個新節點的建立後, 先不要急著存檔, 先到 Y:\examples 目錄中建立一個 tutorial2  目錄, 然後再將目前編修 tutorial1.leo 檔案存在 Y:\exammples 目錄下, 存檔後, 就可以在 log  區看到:

created: Y:\examples\tutorial2\tut2.py
saved: tutorial2.leo

等兩行, 表示已經建立了 tut2.py 並且對 tutorial2.leo 存檔, Leo Editor 為何會這樣做?

2. 先來看標題為 @path tutorial2 的作用.

@path 放在大綱標題, 表示路徑關係, 節點標題為 "@path tutorial2" 表示其下屬節點若有存檔指令 (例如:@auto) 都會是在 tutorial2 目錄之下, 而其下屬節點標題 "@auto tut2.py" 表示要求 Leo 將此節點的內文存成檔案, 而且檔案名稱就是 tut2.py, 由於其上一階層有一個 "@path tutorial2" 節點, 因此 tut2.py 檔案就會存在 tutorial2.leo 所在目錄下的 tutorial2 子目錄, 並且檔案會存為 tut2.py.

3. 如何執行 tut2.py?

雖然可以直接在 Leo Editor 的環境下來執行 tut2.py,  但是 Leo Editor 與 tut2.py 都是 Python3 程式, 比較好的做法是在 Leo Editor 之外來執行此一程式, 實際的操作方法為:

以滑鼠點選 @auto tut2.py  節點標題, 然後以滑鼠右鍵帶出另一個小視窗, 選擇最上頭的 "Edit tut2.py in SciTE.exe", Leo Editor 就會啟動 SciTE 編輯器, 然後開啟 tut2.py, 這時只要在 SciTE 環境, 選擇 Tools-&gt;Go, 就可以執行 tut2.py, 並且在 output 區看到執行結果, 但是 Leo Editor 如何牽動 SciTE 的開啟, 答案就在 start.bat

還記得 start.bat 啟動內容中有:

REM 設定 Leo 所用的編輯器
set LEO_EDITOR=%Disk%:\wscite\SciTE.exe

所以利用 start.bat  啟動時, Leo Editor 就會以 SciTE 作為附屬的編輯器, 而且在 SciTE 設定中, python.properties 已經透過:

if PLAT_WIN
    command.go.*.py=y:\Python33\pythonw -u "$(FileNameExt)"

指名要讓 y:\Python33\pythonw 來執行副檔名為 .py  的檔案, 因此, 一旦 @path 與 @auto 標題指令合力建立 tut2.py 後, 由 Leo 啟動 SciTE, 就可以進行 tut2.py 程式的執行.

4. 接著則是節點內文中 @language  的用法說明:

@language python

表示內文中採用 python 語法來顯示,  @language 為內文指令.

5. 最後, 關閉 tutorial2.leo 檔案, 然後以 SciTE 修改位於 y:\exammples\tutorial2 目錄中的 tut2.py, 把它改為:

#coding: utf-8

for 索引 in range(10):
    print("第"+str(索引)+"行執行 Python 程式")

也就是將原本的 range(5) 改為 range(10), 然後再以 Leo Editor 開啟 tutorial2.leo

標題為 "@auto tut2.py" 的節點內容發生了變化, Leo Editor 不僅納入已經改變的 tut2.py 程式, 而且自動 (@auto) 將程式納入 "tut2 declarations" 節點, 並且將 "@auto tut2.py" 節點的內容改為:

@language python
@tabwidth -4
@others

其中的 @others 表示此節點下屬的所有節點內容都會被納入 tut1.py 程式中 (除了命名節點 (named node) 外,  tutorial3 會談到命名節點).

6. 總結 tutorial2 所呈現的內容, 我們利用 Leo Editor  的 @path 來宣告節點的路徑關係, 並且利用 @auto 來建立外部檔案, 一個重點為:

使用者必須自行建立 tutorial2 子目錄

否則 tut2.py 將不會存檔.

其次在節點內文中, 可以利用 @language python 來辨識 Python 程式碼, 一旦外部的 tut2.py 檔案在 Leo Editor 之外變更後, 使用者再次打開 tutorial2.leo 後, Leo 就會自動導入已經改變的 tut2.py 程式碼, 而且會自動將程式納入階層式的大綱標題與內容.

好了,  終於學會 @path, @auto 與 @language 的基本用法, 這些指令有些用於標題, 有些用於內文, 除了 @language 外,  @tabwidth 與 @others 也都是內文指令, 隨後我們將會加以說明.

tutorial2 可以從 https://sites.google.com/a/mde.tw/service/public/tutorial2.7z?attredirects=0&amp;d=1 下載.</t>
<t tx="mde_leo.20130510215619.7523">Tutorial3 練習檔案可以從 https://sites.google.com/a/mde.tw/service/public/tutorial3.7z?attredirects=0&amp;d=1 下載.

本教學將延續 Tutorial 2, 介紹另一個 Leo Editor 的節點標題指令 @asis.

但是何謂節點標題指令, 其實 Leo Editor 中以 @ 開頭的字串有其特殊用法, 可以導引 Leo 編輯器對標題或內容執行指令, 而這些指令有些是放在節點標題才會有作用, 例如: @auto 與 @asis 都是放在節點標題使用的指令, 而這種指令就稱為"節點標題指令".

相對於放在標題才會有作用的"標題指令", 有些指令是放在節點內文才會有作用, 例如: @language, 這種指令就稱為"內文指令", 先前將 @language python 放在內文的最前頭, 就是告訴 Leo 編輯器, 這個內文要以 Python 程式語法來標示.

Tutorial 2 中的 @auto 所連結的外部檔案, Leo 編輯器不僅會將此外部檔案的內容讀進內文區, 而且若檔案為程式碼, Leo 還會解讀程式碼中的類別與函式, 然後將這些程式物件以樹狀結構呈現, 這些檔案會以外部檔案為主, 假如外部檔案變更, .leo 檔案開啟時就會讀入新的檔案內容, 而在 .leo 檔案編輯時, 改變樹狀結構內容, 儲存 .leo 檔時也會同時更新外部檔案.

Tutorial 3 要介紹的 @asis, 則與 @auto 指令有很大的不同, @asis 對應的外部檔案只在 .leo 存檔時會從 Leo 節點寫成外部檔, 實際的資料會存在.leo 節點中, 外部檔案變更後, 重新打開 .leo 檔, @asis 無法反應外部檔案的變更.

使用者可以在打開 tutorial2.leo 後, 將外部 tut3.txt 刪除, 並不會影響存在節點中的內容, 當節點內容改變, 且儲存 .leo 檔案時, Leo 會將節點內容再存入 tut3.txt 檔案.

另外一點, "tut3 的子節點"以下的節點, 無論是"命名節點"或一般節點, 內容都會被存入 tut3.txt, 而且子節點間不會自動跳行.

接著來複習一下 @auto 大綱標題指令:

Leo 編輯器網站有關 @auto 的說明這樣寫著:

@auto 節點標題指令會自動導入外部檔案, 並且將外部檔案的內容納入節點樹狀架構, 當以 Leo 編輯器建立的外部檔案, 不希望附加 Leo 標註資料時,  @auto 節點標題指令通常為第一選擇. 儘管以 @auto 指令所連結的外部檔案沒有 Leo 標註資料, 當此外部檔案變更後, Leo 仍能配合變更其對應的節點樹狀架構.

@auto 對應檔案是以輸入器 (importers) 進行資料讀取, 各程式類別、方法或函式都會單獨以節點存放, 目前 Leo 可以解讀的節點資料有 C, elisp, HTML, .ini files, Java, Javascript, Pascal, PHP, Python 與 xml. 能夠解讀的 html 標註則有 html, body, head, and div 等, 其他未支援的程式內容則會全部以複製方法導入.

@auto 導入外部檔案時會自動查驗與原導入檔案的差異, 一旦發生內容差異時, Leo 就會發生錯誤或警告訊息並自動插入 @ignore  指令, 以免意外更動外部檔案原本的內容.

另外, @auto 將外部程式檔案以 leoImport.py 解讀為 Leo 編輯器節點的樹狀結構, 對於 Python 程式的解讀性最佳, 原因就在於 Python 程式語法對於縮排有嚴格規定, 因此只要是能夠正確執行的 Python 程式被 @auto 正確解讀的機會最高, 而其他程式語言若編寫架構參差, Tab 與空白混用將會造成 @auto 解讀上的困難, 一旦 Leo Editor 在利用@auto 解讀過程發現內容有誤時, 並不會強制導入樹狀架構, 而是將全部內容讀到節點內文中, 若使用者無法適度修改成可以讓 @auto 解讀的版本, 使用者可以將 @auto 改為 @edit, 讓 Leo Editor 將所有程式碼存在同一節點的方式來管理.

@edit 與 @auto 節點標題指令都不會在外部檔案中加上 Leo 標記, 且在 .leo 檔案中不會儲存外部檔案資料, 而是在開檔時由外部讀進檔案資料, @edit 會將檔案放在同一節點, 而 @auto 則會將外部程式檔案中的類別與函式納入 Leo 的節點架構中.

Leo Editor 除了 @auto 標題指令不會在內容留下 Leo 標記外, 還有 @edit 與 @asis 等兩個標題指令 (這裡避開較少使用的 @nosent), 也不會在所建立的外部檔案中加入 Leo 標記, @edit 與 @auto 不同的地方在於:

@edit 不會像 @auto 解讀外部檔案並將外部檔案, 同時納入 Leo 的樹狀架構, @edit 會將整個外部檔案放在一個節點內容中.

@auto 與  @edit  標題指令都會讀入變更內容的外部檔案, 只不過 @auto  會解讀內容架構並且放到樹狀節點中, 而 @edit 則將外部檔案的全部資料放到一個節點中.

@asis 標題節點指令則與 @auto/@edit 有很大不同:

1. @asis 是一個以 .leo 節點資料內容為主的標題指令, 當外部檔案有變更時, @asis  並無法反應這些變更, 使用者只能從 .leo 檔案中利用節點滑鼠右鍵, 以 Refresh from disk 手動反應外部檔案最新內容.

2. @asis 通常在第一時間, 以 .leo 中的節點資料為主, 在 .leo 檔案存檔時, 才會將節點以及附屬節點的內容寫入對應的外部檔案.

3. @asis 下屬的子節點內容會全部從節點內容寫入 @asis 對應的外部檔案, 而且若節點內容沒有跳行符號, 則全部的內容都會直接黏合在一起, 不會自動跳行.

Tutorial3 練習檔案可以從 https://sites.google.com/a/mde.tw/service/public/tutorial3.7z?attredirects=0&amp;d=1 下載.

以 Leo Editor 開啟 tutorial3.leo 檔案後, 查看一下標題為 "&lt;&lt; 命名節點 &gt;&gt;" 的節點, 這種以 &lt;&lt; &gt;&gt; 標示的節點稱為"named node"

相關檔案說明: http://leoeditor.com/directives.html</t>
<t tx="mde_leo.20130510215619.7524">Tutorlal4: https://sites.google.com/a/mde.tw/service/public/tutorial4.7z?attredirects=0&amp;d=1

介紹 @edit 的使用.

請下載 tutorial4.7z 解開後, 以 Portable Leo Editor 開啟.

@edit 也是以外部檔案為主的"標題指令", 這點與 @auto 相同.

與 @auto 不同的是, @edit 讀進外部檔案後, 不會解讀也不會自動納入節點架構, 而是將所有外部檔案內容放在同一個節點內容中.

因此 @edit  的使用時機與 @auto 相同, 都是先有外部程式檔案後, 再設法以節點標題指令導入 Leo 編輯器中.

另外, 使用者若以滑鼠右鍵按住"@path tutorial4" 節點, 就可以看到"Import files"指令, 這是利用導入檔案的方式來執行 @auto 或 @edit, 可以一次選擇目錄下多個檔案, 並且將這些檔案以 @auto 或 @edit 模式導入 (程式檔會以 @auto 執行, 一般檔案則會以 @edit 執行).

路徑節點中的 "Import files" 指令, 執行 @auto 或 @edit 後, 會以絕對路徑作為節點標題, 其實這並不是很好的做法, 因為一旦 .leo 檔案移動位置後, 這些絕對路徑"可能"不會自動調整, 我們試一下好了.

我們試著以滑鼠右鍵指向"@path tutorial2", 並且要求 "Import files", 然後開啟 tut2.py, 看看 Leo Editor 會不會自動以 @auto 導入 tut2.py

接著再以滑鼠右鍵指向"@path tutorial4", 並且要求 "Import files",  然後開啟 tut4.txt, 看看 Leo Editor 會不會自動以 @edit 導入 tut4.txt

假如都可以順利導入 tut2.py 與 tut4.txt, 就可以看到 Leo Editor 以絕對路徑作為節點標題, 將此一檔案存為 tutorial4-1.leo, 然後將整個 examples 目錄搬到其他地方, 再次開啟 tutorial4-1.leo, 上述操作的絕對路徑標題仍然指向原先的檔案, 而不是相對目錄下的 tut2.py 與 tut4.txt, 因此假如在上一個步驟將絕對目錄標題改為相對目錄, 則移動位置後的節點就會指向相對目錄下的 tut2.py 與 tut4.txt.

好了,  Tutorial4 講完了, 我們現在應該已經會使用 @auto, @asis 與 @edit 來建立 Leo 內容與外部檔案之間的關聯, 而這些關聯就是後續將 Leo Editor 用來作為 IDE 的重要功能.

Tutorial 5 我們將要來看 @file 節點標題指令, 將會有更多命名節點與內文指令的應用.</t>
<t tx="mde_leo.20130510215619.7525">Tutorial5: https://sites.google.com/a/mde.tw/service/public/tutorial5.7z?attredirects=0&amp;d=1

請由上述連結下載 tutorial5.leo, 然後以可攜 Leo 編輯器開啟.

先看一下"@file tut5.py" 節點的內容:

@language python
#coding: utf8
&lt;&lt; comment &gt;&gt;
&lt;&lt; import &gt;&gt;
@others
&lt;&lt; other config &gt;&gt;
&lt;&lt; run &gt;&gt;

@language python 表示這個檔案要以 Python 程式語法解讀.

@others 則代表此一節點的下屬節點中所有節點的內容, 但是不包括"命名節點".

所謂的命名節點, 就是節點標題中帶有 &lt;&lt; 與 &gt;&gt; 符號的節點.

在 @file tut5.py 節點中, 共引用了四個命名節點, 表示要分別將這些節點內容依序放在 tut5.py 檔案中.

命名節點排列的次序就代表這些內容要放入 tut5.py 的順序, 而 @others 則代表後續下一階所有內容的總合, 要放在 @others 所在的位置.

這裡必須要特別注意的一點是, @others 所在的縮排位置非常重要, 因為整個 Leo Editor 中的節點標題與內文都是 Python 程式物件, 因此 @others 所在的位置就是後續程式要置入的對應位置, 假如 @others 向右縮排, 則表示後續的子節點內容,全部要以 @others 所在的縮排位置進行擺放.

我們可以在 @file tut5.py 節點內容動一些手腳, 將 @others 往後跳四個 spaces, 然後存檔, 看看 tut5.py 內容有何改變?

當您以滑鼠右鍵, 點住 @file tut5.py 節點, 然後選擇"Edit tut5.py in SciTE" 功能時, 打開  tut5.py 後, 就可以見到許多 # 開頭的標註記號, 這些標記就是所謂的"Leo 標記" (sentinel), 這是 Leo 用 xml 註記內容之用, 就產生外部檔案的指令而言, 只有 @file 與 @shadow 節點標題指令所產生的外部檔案才看得到.

上面提到, 當 @others 改變位置後, tut5.py 也會將子節點所對應的內容向後移位, 這就是 @others 的特性.

您也可以將 "&lt;&lt; comment &gt;&gt;" 命名節點在 @file tut5.py 節點內文中, 向右移動 4 個空白, 然後存檔, 看看 tut5.py 檔案中有何變化.

沒有錯, 與 "&lt;&lt; comment &gt;&gt;" 命名節點對應的內文也會向右移動, 因此在 Leo Editor 中各指令標示的位置是非常重要的, 可能對於不使用 Python 程式的用戶來說, 程式碼的位置無關緊要, 但是 Python 程式語法天生就是靠縮排來確定各區域的執行範圍, 養成固定縮排寫程式的習慣在 Python 而言是必要的, 能夠執行的Python 程式一定是排列整齊的, 不僅電腦執行沒有問題, 使用者也非常容易看懂, 對於 Python 以外的程式寫法也應該如此, 使用 Leo Editor 就必須注意各指令在內文出現的位置, 否則所產生的外部 Python 程式就無法執行.

總結一下 Tutorial 5 的說明, @file 節點標題指令, 會在外部檔案中加入特定的 Leo 標記, 而且外部檔案不會存在 .leo 檔案中, 而是開啟 .leo 檔案時才讀進對應的節點, 此外節點內文指令 @others 與命名節點擺放的位置會牽動對應內容寫檔時的縮排位置, 在 .leo 檔案開啟時, 修改各對應節點內容, 在存 .leo 檔時會寫入外部檔案, 可見 @file 與@auto, @edit 的資料流都是雙向的, 且都主要將內容存在外部檔案中, 只有 @asis 指令會將節點內容存在 .leo 檔案裡面.

而 @file 在外部檔案寫入 Leo 標記符號的做法, 對使用 Leo Editor 的用戶而言或許沒有問題, 但是當這些充滿 Leo 標記符號的檔案交到沒有用 Leo Editor 開啟資料的用戶, 可能就沒有太大用途, 因此 Leo Editor 還有一種兩全其美的做法, 採用 @shadow 來同時建立有 Leo 標記與沒有 Leo 標記的檔案, 前者可以讓 Leo Editor 開啟時快速確認內容架構, 而後者則可以交給不用 Leo Editor 的用戶, Tutorial 6 就是要談 @shadow 的用法.</t>
<t tx="mde_leo.20130510215619.7526">Tutorial6: https://sites.google.com/a/mde.tw/service/public/tutorial6.7z?attredirects=0&amp;d=1

這個教學要來談 Leo Editor 的 @shadow 節點標題指令的用法.

Tutorial 5 已經說明 @file 的基本用法, 但是 @file 指令所建立的外部檔案帶有許多 Leo 標記符號, 這些標記符號對於 Leo Editor 特定用途, 但是若不使用 Leo Editor 開啟, 這些標記符號可能就會是干擾, 這時您可以考慮改用 @shadow.

Tutorial 6 的節點標題與 Tutorial 5 相同, 各命名節點的內容也都一樣, 只是將 @file 換成 @shadow, 這時 Leo Editor 就會自動建立有標記與沒有標記的外部檔案.

下載 tutorial6.leo 後, 開啟, 就可以看到 @shadow tut6.py 節點標題, Leo Editor 會將 tut6.py 寫進 tutorial6 的子目錄, 請開啟 tutorial6 目錄, 您就會看到除了 tut6.py 檔案外, 還有一個 .leo_shadow 目錄, 其中外部的 tut6.py 沒有標記, 而 .leo_shadow 目錄中的 xtut6.py 就是相同內容, 但是卻有 Leo 標記符號的對應檔案.

好了, 這個說明非常簡單, 您可以試著修改一下 tut6.py  各節點的內容, 然後用 SciTE 開啟執行, 操作方法為, 利用滑鼠右鍵按住 @shadow tut6.py 節點標題, 然後選擇 "Edit tut6.py in SciTE", 接著就是在 SciTE 環境, 選擇 Tools-&gt;Go, 就可以執行這個 tut6.py 程式.</t>
</tnodes>
</leo_file>
