<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="amd_yen.20130306001037.1797" a="E"><vh>@settings</vh>
<v t="amd_yen.20130306001037.1798"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="amd_yen.20130306001037.1799"><vh>@string initial_split_orientation = vertical</vh></v>
</v>
<v t="amd_yen.20130307204656.1443" a="E"><vh>課程規劃與進行</vh>
<v t="amd_yen.20130307204656.9867"><vh>@url Leo 手冊</vh></v>
</v>
<v t="amd_yen.20130308103121.2379"><vh>整體架構規劃</vh></v>
<v t="amd_yen.20130308210411.2383"><vh>自編教材 (點選下列節點, 按下 Ctrl+b 可以建立教材)</vh>
<v t="amd_yen.20130314194325.1514" a="E"><vh>@button generate-current</vh>
<v t="amd_yen.20130308210411.2404"><vh>&lt;&lt; html manual &gt;&gt;</vh></v>
<v t="amd_yen.20130308210411.2405"><vh>&lt;&lt; pdf manual &gt;&gt;</vh></v>
</v>
<v t="amd_yen.20130308210411.2403" a="E"><vh>@button generate-full-userguide</vh>
<v t="amd_yen.20130308210411.2404"></v>
<v t="amd_yen.20130308210411.2405"></v>
</v>
<v t="amd_yen.20130308210411.2397"><vh>@edit document\conf.py</vh></v>
<v t="amd_yen.20130308210411.2398"><vh>@edit document\kmol_toc.html.txt</vh></v>
<v t="amd_yen.20130318140025.2832" a="E"><vh>位於 exts 目錄的中文分詞程式</vh>
<v t="amd_yen.20130318140025.2829"><vh>@edit exts\zh.py</vh></v>
<v t="amd_yen.20130318140025.2830"><vh>@edit exts\chinese_search.py</vh></v>
<v t="amd_yen.20130318140025.2831"><vh>@edit exts\sphinx.search.py</vh></v>
</v>
</v>
<v t="amd_yen.20130312013510.1824"><vh>@button self_and_subtree</vh></v>
<v t="amd_yen.20130308210411.2406" a="E"><vh>KMOL Guide</vh>
<v t="amd_yen.20130308221230.3827"><vh>前言</vh>
<v t="amd_yen.20130312013510.1498"><vh>以下為電子書內容</vh></v>
<v t="amd_yen.20130308221230.3828"
expanded="amd_yen.20130308221230.3829,"><vh>@file frontMatter.txt</vh></v>
</v>
<v t="amd_yen.20130308210411.2384" a="E"><vh>程式語言(二)</vh>
<v t="amd_yen.20130318140025.2833"><vh>有關程式語言</vh></v>
<v t="amd_yen.20130308221230.2437" a="E"><vh>C2 第一週程式</vh>
<v t="amd_yen.20130408141041.1765"><vh>有關 pybean 版次差異</vh></v>
<v t="amd_yen.20130308221230.2438" a="E"><vh>@shadow c2/grouping.py</vh></v>
<v t="amd_yen.20130308221230.2441" a="E"><vh>@shadow c2/generate_stud.py</vh></v>
</v>
<v t="amd_yen.20130308221230.2457" a="E"><vh>C2 第二週程式</vh>
<v t="amd_yen.20130308221230.2458" a="E"><vh>@shadow c2/docutils_ex1.py</vh></v>
<v t="amd_yen.20130308221230.2462"><vh>課程規劃</vh></v>
<v t="amd_yen.20130308221230.2463" a="E"><vh>課程進行</vh>
<v t="amd_yen.20130308221230.2464"><vh>portableKMOL 配置</vh></v>
</v>
<v t="amd_yen.20130308221230.2465" a="E"><vh>@shadow c2/docutils_ex2.py</vh></v>
</v>
<v t="amd_yen.20130317160119.1726"><vh>C2 第四週程式</vh>
<v t="amd_yen.20130317160119.1727"><vh>@shadow c2/pyqt_geardesign.py</vh></v>
</v>
<v t="amd_yen.20130312013510.1501"><vh>網誌內容</vh></v>
<v t="amd_yen.20130312013510.1498"></v>
<v t="amd_yen.20130308210411.2387" a="E"
expanded="amd_yen.20130308210411.2388,amd_yen.20130308214521.2438,amd_yen.20130308214521.2440,amd_yen.20130317094520.1538,amd_yen.20130414200359.2118,amd_yen.20130414200359.2119,amd_yen.20130414200359.2130,amd_yen.20130421114440.2840,amd_yen.20130421114440.2842,amd_yen.20130424175812.2164,amd_yen.20130423211907.2156,"><vh>@file c2.txt</vh></v>
</v>
<v t="amd_yen.20130308210411.2385" a="E"><vh>協同產品設計實習</vh>
<v t="amd_yen.20130309155804.1706"><vh>CD 第三週程式</vh>
<v t="amd_yen.20130309155804.1707" a="E"><vh>@shadow cd/spreadsheet.py</vh></v>
</v>
<v t="amd_yen.20130314194325.1746"><vh>CD 第四週程式</vh>
<v t="amd_yen.20130314194325.1747" a="E"><vh>@shadow cd/gearcontour.py</vh></v>
</v>
<v t="amd_yen.20130418193628.2122"><vh>CD 第八週程式</vh>
<v t="amd_yen.20130418193628.2123" a="E"><vh>@shadow cd/partview/objstl.js</vh></v>
<v t="amd_yen.20130418193628.2126"><vh>@edit cd/partview/RequestAnimationFrame.js</vh></v>
<v t="amd_yen.20130418193628.2127"><vh>@edit cd/partview/index.php</vh></v>
</v>
<v t="amd_yen.20130312013510.1498"></v>
<v t="amd_yen.20130308210411.2392" a="E"
expanded="amd_yen.20130308210411.2393,amd_yen.20130308214521.2427,amd_yen.20130309155804.1709,amd_yen.20130314194325.1511,amd_yen.20130309155804.1711,amd_yen.20130320201815.1570,amd_yen.20130413002743.2095,amd_yen.20130421114440.2135,amd_yen.20130421114440.2136,"><vh>@file cd.txt</vh></v>
</v>
<v t="amd_yen.20130308210411.2386"><vh>網際內容管理</vh>
<v t="amd_yen.20130406103207.2438" a="E"><vh>django 程式開發</vh>
<v t="amd_yen.20130406103207.2442"><vh>@url Tutorial 1</vh></v>
<v t="amd_yen.20130406103207.2285"><vh>@edit wcm/django1.py</vh></v>
<v t="amd_yen.20130406103207.2286"><vh>@button django project</vh></v>
<v t="amd_yen.20130406103207.2435"><vh>@edit wcm/mysite/mysite/settings.py</vh></v>
<v t="amd_yen.20130406103207.2434"><vh>@button sync db</vh></v>
<v t="amd_yen.20130406103207.2287"><vh>@button startapp polls</vh></v>
<v t="amd_yen.20130406103207.2436"><vh>@edit wcm/mysite/polls/models.py</vh></v>
<v t="amd_yen.20130406103207.2437"><vh>@button sql polls</vh></v>
<v t="amd_yen.20130406103207.2434"></v>
<v t="amd_yen.20130406103207.2439"><vh>@url Tutorial 2</vh></v>
<v t="amd_yen.20130406103207.2440"><vh>@edit wcm/mysite/mysite/urls.py</vh></v>
<v t="amd_yen.20130406103207.2441"><vh>啟動伺服器</vh></v>
</v>
<v t="amd_yen.20130312013510.1498"></v>
<v t="amd_yen.20130308210411.2407" a="E"
expanded="amd_yen.20130308210411.2408,amd_yen.20130418193628.2823,"><vh>@file wcm.txt</vh></v>
</v>
<v t="amd_yen.20130308221230.2492" a="E"><vh>綜合資料</vh>
<v t="amd_yen.20130312013510.1498"></v>
<v t="amd_yen.20130308221230.2493" a="E"
expanded="amd_yen.20130308221230.2494,amd_yen.20130308221230.2481,amd_yen.20130312013510.2093,amd_yen.20130308221230.2482,amd_yen.20130308221230.2485,amd_yen.20130311141127.1492,amd_yen.20130309155804.1713,amd_yen.20130322213429.1578,amd_yen.20130409235757.1782,"><vh>@file misc.txt</vh></v>
</v>
</v>
<v t="amd_yen.20130409162552.1785"><vh>可攜 Leo Editor</vh>
<v t="amd_yen.20130409162552.1786"><vh>leo editor tutorial 1</vh></v>
<v t="amd_yen.20130409163608.1839"><vh>leo editor tutorial 2</vh></v>
<v t="amd_yen.20130410133544.4362"><vh>leo editor tutorial 3</vh></v>
<v t="amd_yen.20130410133544.4363"><vh>leo editor tutorial 4</vh></v>
<v t="amd_yen.20130410133544.4364"><vh>leo editor tutorial 5</vh></v>
<v t="amd_yen.20130410133544.4365"><vh>leo editor tutorial 6</vh></v>
</v>
<v t="amd_yen.20130406103207.2444"><vh>機械設計的本質</vh>
<v t="amd_yen.20130410133544.14742" a="E"><vh>電腦輔助機械設計</vh>
<v t="amd_yen.20130410133544.14743"><vh>電腦</vh>
<v t="amd_yen.20130410133544.14744" a="E"><vh>程式</vh>
<v t="amd_yen.20130410133544.14745" a="E"><vh>依自由度分類</vh>
<v t="amd_yen.20130410133544.14746"><vh>套件</vh></v>
<v t="amd_yen.20130410133544.14747"><vh>二次開發</vh></v>
<v t="amd_yen.20130410133544.14748"><vh>自行編寫</vh></v>
</v>
<v t="amd_yen.20130410133544.14749" a="E"><vh>依操作系統分類</vh>
<v t="amd_yen.20130410133544.14750"><vh>Windows</vh></v>
<v t="amd_yen.20130410133544.14751"><vh>Linux</vh></v>
<v t="amd_yen.20130410133544.14752"><vh>iOS</vh></v>
</v>
<v t="amd_yen.20130410133544.14753" a="E"><vh>依功能分類</vh>
<v t="amd_yen.20130410133544.14754"><vh>文書處理</vh></v>
<v t="amd_yen.20130410133544.14755" a="E"><vh>資料處理</vh>
<v t="amd_yen.20130410133544.14756"><vh>格式轉檔</vh></v>
</v>
<v t="amd_yen.20130410133544.14757"><vh>功能模擬</vh></v>
<v t="amd_yen.20130410133544.14758"><vh>自動控制</vh></v>
<v t="amd_yen.20130410133544.14759"><vh>內容管理</vh></v>
</v>
<v t="amd_yen.20130410133544.14760"><vh>依語言分類</vh>
<v t="amd_yen.20130410133544.14761"><vh>Python</vh></v>
<v t="amd_yen.20130410133544.14762"><vh>C</vh></v>
<v t="amd_yen.20130410133544.14763"><vh>C++</vh></v>
<v t="amd_yen.20130410133544.14764"><vh>PHP</vh></v>
<v t="amd_yen.20130410133544.14765"><vh>JavaScript</vh></v>
<v t="amd_yen.20130410133544.14766"><vh>Java</vh></v>
<v t="amd_yen.20130410133544.14767"><vh>Lua</vh></v>
<v t="amd_yen.20130410133544.14768"><vh>Lisp</vh></v>
<v t="amd_yen.20130410133544.14769"><vh>Forth</vh></v>
</v>
<v t="amd_yen.20130410133544.14770" a="E"><vh>依操作模式分類</vh>
<v t="amd_yen.20130410133544.14771"><vh>圖形化人機介面</vh></v>
<v t="amd_yen.20130410133544.14772"><vh>文字介面</vh></v>
<v t="amd_yen.20130410133544.14773"><vh>指令介面</vh></v>
</v>
</v>
<v t="amd_yen.20130410133544.14774"><vh>網路</vh>
<v t="amd_yen.20130410133544.14775"><vh>功能</vh>
<v t="amd_yen.20130410133544.14776"><vh>搜尋資料</vh></v>
<v t="amd_yen.20130410133544.14777"><vh>整合並提供資料</vh></v>
<v t="amd_yen.20130410133544.14778"><vh>自動傳輸資料</vh></v>
</v>
<v t="amd_yen.20130410133544.14779"><vh>使用注意要項</vh>
<v t="amd_yen.20130410133544.14780"><vh>連線查詢</vh></v>
<v t="amd_yen.20130410133544.14781"><vh>代理主機</vh></v>
<v t="amd_yen.20130410133544.14782"><vh>DNS</vh></v>
<v t="amd_yen.20130410133544.14783"><vh>防火牆</vh></v>
<v t="amd_yen.20130410133544.14784"><vh>SSL</vh></v>
<v t="amd_yen.20130410133544.14785"><vh>PGP</vh></v>
</v>
</v>
<v t="amd_yen.20130410133544.14786"><vh>主機</vh>
<v t="amd_yen.20130410133544.14787"><vh>個人電腦</vh></v>
<v t="amd_yen.20130410133544.14788"><vh>伺服電腦</vh>
<v t="amd_yen.20130410133544.14789"><vh>叢集電腦</vh></v>
<v t="amd_yen.20130410133544.14790"><vh>分散式電腦</vh></v>
<v t="amd_yen.20130410133544.14791"><vh>GPU電腦</vh></v>
<v t="amd_yen.20130410133544.14792"><vh>雲端主機</vh></v>
</v>
<v t="amd_yen.20130410133544.14793"><vh>筆記型電腦</vh></v>
<v t="amd_yen.20130410133544.14794"><vh>平板</vh></v>
<v t="amd_yen.20130410133544.14795"><vh>手機</vh></v>
<v t="amd_yen.20130410133544.14796"><vh>嵌入式裝置</vh>
<v t="amd_yen.20130410133544.14797" a="E"><vh>功能分類</vh>
<v t="amd_yen.20130410133544.14798"><vh>感測</vh></v>
<v t="amd_yen.20130410133544.14799"><vh>傳輸</vh></v>
<v t="amd_yen.20130410133544.14800"><vh>遙控</vh></v>
<v t="amd_yen.20130410133544.14801"><vh>運算</vh></v>
</v>
</v>
</v>
</v>
<v t="amd_yen.20130410133544.14802"><vh>輔助</vh>
<v t="amd_yen.20130410133544.14803" a="E"><vh>分類</vh>
<v t="amd_yen.20130410133544.14804" a="E"><vh>依自動化程度</vh>
<v t="amd_yen.20130410133544.14805"><vh>自動完成設計</vh></v>
<v t="amd_yen.20130410133544.14806"><vh>半自動完成設計</vh></v>
<v t="amd_yen.20130410133544.14807"><vh>增進設計效率</vh></v>
</v>
<v t="amd_yen.20130410133544.14808" a="E"><vh>依所採原理</vh>
<v t="amd_yen.20130410133544.14809" a="E"><vh>造型</vh>
<v t="amd_yen.20130410133544.14810" a="E"><vh>平面</vh>
<v t="amd_yen.20130410133544.14811"><vh>2D圖學</vh></v>
</v>
<v t="amd_yen.20130410133544.14812" a="E"><vh>空間</vh>
<v t="amd_yen.20130410133544.14813"><vh>3D圖學</vh></v>
</v>
</v>
<v t="amd_yen.20130410133544.14814"><vh>力學</vh>
<v t="amd_yen.20130410133544.14815"><vh>靜力</vh></v>
<v t="amd_yen.20130410133544.14816"><vh>動力</vh></v>
<v t="amd_yen.20130410133544.14817"><vh>材料</vh></v>
<v t="amd_yen.20130410133544.14818"><vh>熱</vh></v>
<v t="amd_yen.20130410133544.14819"><vh>流體</vh></v>
</v>
</v>
<v t="amd_yen.20130410133544.14820" a="E"><vh>依設計者數量</vh>
<v t="amd_yen.20130410133544.14821"><vh>個人</vh></v>
<v t="amd_yen.20130410133544.14822"><vh>多人協同</vh></v>
</v>
<v t="amd_yen.20130410133544.14823" a="E"><vh>依取得費用</vh>
<v t="amd_yen.20130410133544.14824"><vh>商用付費</vh></v>
<v t="amd_yen.20130410133544.14825"><vh>自由免費</vh></v>
</v>
<v t="amd_yen.20130410133544.14826" a="E"><vh>依程式開放程度</vh>
<v t="amd_yen.20130410133544.14827"><vh>原始碼封閉</vh></v>
<v t="amd_yen.20130410133544.14828"><vh>原始碼公開</vh></v>
<v t="amd_yen.20130410133544.14829"><vh>核心封閉方案開放</vh></v>
</v>
</v>
</v>
<v t="amd_yen.20130410133544.14830"><vh>機械設計</vh>
<v t="amd_yen.20130410133544.14831"><vh>有關設計</vh></v>
<v t="amd_yen.20130410133544.14832" a="E"><vh>分類</vh>
<v t="amd_yen.20130410133544.14833"><vh>依所採原理</vh>
<v t="amd_yen.20130410133544.14834"><vh>造型</vh></v>
<v t="amd_yen.20130410133544.14835"><vh>力學</vh></v>
</v>
<v t="amd_yen.20130410133544.14836"><vh>依元件現存與否</vh>
<v t="amd_yen.20130410133544.14837"><vh>標準元件選用</vh></v>
<v t="amd_yen.20130410133544.14838"><vh>客製化元件設計</vh></v>
</v>
<v t="amd_yen.20130410133544.14839"><vh>依原創設計與否</vh>
<v t="amd_yen.20130410133544.14840"><vh>原創設計</vh>
<v t="amd_yen.20130410133544.14841"><vh>ODM</vh></v>
<v t="amd_yen.20130410133544.14842"><vh>OBM</vh></v>
</v>
<v t="amd_yen.20130410133544.14843"><vh>非原創設計</vh>
<v t="amd_yen.20130410133544.14844"><vh>OEM</vh></v>
</v>
</v>
<v t="amd_yen.20130410133544.14845" a="E"><vh>依工業分類</vh>
<v t="amd_yen.20130410133544.14846"><vh>工具機</vh>
<v t="amd_yen.20130410133544.14847"><vh>傳統加工機</vh>
<v t="amd_yen.20130410133544.14848"><vh>車床</vh></v>
<v t="amd_yen.20130410133544.14849"><vh>銑床</vh></v>
<v t="amd_yen.20130410133544.14850"><vh>鑽床</vh></v>
<v t="amd_yen.20130410133544.14851"><vh>磨床</vh></v>
<v t="amd_yen.20130410133544.14852"><vh>锯床</vh></v>
<v t="amd_yen.20130410133544.14853"><vh>沖壓床</vh></v>
<v t="amd_yen.20130410133544.14854"><vh>剪床</vh></v>
<v t="amd_yen.20130410133544.14855"><vh>NC 工具機</vh></v>
</v>
<v t="amd_yen.20130410133544.14856"><vh>非傳統加工機</vh>
<v t="amd_yen.20130410133544.14857"><vh>放電加工機</vh></v>
<v t="amd_yen.20130410133544.14858"><vh>超音波加工機</vh></v>
<v t="amd_yen.20130410133544.14859"><vh>雷射加工機</vh></v>
</v>
</v>
<v t="amd_yen.20130410133544.14860"><vh>產業機械</vh>
<v t="amd_yen.20130410133544.14861"><vh>紡織與成衣機械</vh></v>
<v t="amd_yen.20130410133544.14862"><vh>包裝機械</vh></v>
<v t="amd_yen.20130410133544.14863"><vh>木工機械</vh></v>
<v t="amd_yen.20130410133544.14864"><vh>化工機械</vh></v>
<v t="amd_yen.20130410133544.14865"><vh>塑橡膠機械</vh></v>
<v t="amd_yen.20130410133544.14866"><vh>造紙印刷機械</vh></v>
<v t="amd_yen.20130410133544.14867"><vh>食品飲料機械</vh></v>
<v t="amd_yen.20130410133544.14868"><vh>農業機械</vh></v>
</v>
<v t="amd_yen.20130410133544.14869"><vh>通用機械</vh>
<v t="amd_yen.20130410133544.14870"><vh>模具</vh></v>
<v t="amd_yen.20130410133544.14871"><vh>壓縮機、鼓風機、風扇</vh></v>
<v t="amd_yen.20130410133544.14872"><vh>機械手臂</vh></v>
<v t="amd_yen.20130410133544.14873"><vh>輸送設備</vh></v>
<v t="amd_yen.20130410133544.14874"><vh>事務機械</vh></v>
<v t="amd_yen.20130410133544.14875"><vh>污染防治設備</vh></v>
</v>
<v t="amd_yen.20130410133544.14876" a="E"><vh>動力機械</vh>
<v t="amd_yen.20130410133544.14877"><vh>內燃機</vh></v>
<v t="amd_yen.20130410133544.14878"><vh>渦輪機</vh></v>
<v t="amd_yen.20130410133544.14879"><vh>鍋爐</vh></v>
<v t="amd_yen.20130410133544.14880"><vh>電動機</vh></v>
</v>
<v t="amd_yen.20130410133544.14881" a="E"><vh>機械元件</vh>
<v t="amd_yen.20130410133544.14882"><vh>軸</vh></v>
<v t="amd_yen.20130410133544.14883"><vh>軸承</vh></v>
<v t="amd_yen.20130410133544.14884"><vh>齒輪</vh></v>
<v t="amd_yen.20130410133544.14885"><vh>連結</vh></v>
<v t="amd_yen.20130410133544.14886"><vh>焊接</vh></v>
<v t="amd_yen.20130410133544.14887"><vh>凸輪</vh></v>
<v t="amd_yen.20130410133544.14888"><vh>液氣壓元件</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="amd_yen.20130406103207.2445" a="E"><vh>何謂設計?</vh>
<v t="amd_yen.20130406103207.2447"><vh>設計衡量</vh></v>
<v t="amd_yen.20130406103207.2449"><vh>設計類型</vh></v>
</v>
<v t="amd_yen.20130406103207.2446" a="E"><vh>何謂機械?</vh>
<v t="amd_yen.20130406103207.2448"><vh>機械內容</vh></v>
</v>
<v t="amd_yen.20130406103207.2450"><vh>電腦輔助設計</vh></v>
<v t="amd_yen.20130406103207.2451"><vh>協同設計</vh></v>
<v t="amd_yen.20130406103207.2768"><vh>GPU 相關</vh></v>
</v>
<v t="amd_yen.20130423211907.2155" a="E"><vh>電腦輔助機械繪圖</vh>
<v t="amd_yen.20130423211907.2156" a="E"><vh>2D PythonCAD</vh>
<v t="amd_yen.20130423211907.2158"><vh>pickle 與 unpickle</vh></v>
</v>
<v t="amd_yen.20130423211907.2157"><vh>3D FreeCAD</vh></v>
</v>
<v t="amd_yen.20130406103207.2760"><vh>C Pointer and Array</vh>
<v t="amd_yen.20130406103207.2761"><vh>PREFACE</vh></v>
<v t="amd_yen.20130406103207.2762"><vh>INTRODUCTION</vh></v>
<v t="amd_yen.20130406103207.2763"><vh>Chapter 1: What is a Pointer?</vh></v>
<v t="amd_yen.20130406103207.2764"><vh>Chapter 2: Pointer Types and Arrays.</vh></v>
<v t="amd_yen.20130406103207.2765"><vh>Chapter 3: Pointers and Strings</vh></v>
<v t="amd_yen.20130406103207.2766"><vh>Chapter 4: More on Strings</vh></v>
<v t="amd_yen.20130406103207.2767"><vh>Chapter 5: Pointers and Structures</vh></v>
</v>
<v t="amd_yen.20130413002743.2100"><vh>Berkeley CS61a 課程演變</vh>
<v t="amd_yen.20130413002743.2101" a="E"><vh>如何學習程式語言</vh>
<v t="amd_yen.20130413002743.2104"><vh>Python 3 安裝</vh></v>
</v>
</v>
<v t="amd_yen.20130413002743.2102" a="E"><vh>機械設計工程系程式課程演變</vh>
<v t="amd_yen.20130413002743.2103"><vh>符號式機構分析</vh></v>
<v t="amd_yen.20130418193628.2121"><vh>PHP 與 Javascript</vh></v>
</v>
<v t="amd_yen.20130325133433.2805"><vh>C2G1</vh>
<v t="amd_yen.20130325133433.2806" a="E"><vh>按鈕</vh>
<v t="amd_yen.20130325133433.2807" a="E"><vh>@button c2g1</vh>
<v t="amd_yen.20130325133433.2808"><vh>&lt;&lt; html manual &gt;&gt;</vh></v>
<v t="amd_yen.20130325133433.2809"><vh>&lt;&lt; pdf manual &gt;&gt;</vh></v>
</v>
</v>
<v t="amd_yen.20130325133433.2810" a="E"><vh>設定檔案</vh>
<v t="amd_yen.20130325133433.2811" a="E"><vh>@path c2g1</vh>
<v t="amd_yen.20130325133433.2812"><vh>@edit conf.py</vh></v>
<v t="amd_yen.20130325133433.2813"><vh>@edit index.html.txt</vh></v>
<v t="amd_yen.20130325133433.2814"><vh>@edit make.bat</vh></v>
</v>
</v>
<v t="amd_yen.20130325133433.2815" a="E"><vh>Latex 後續處理(選項)</vh>
<v t="amd_yen.20130325133433.2816" a="O"><vh>@edit c2g1/_build/latex/index.tex</vh></v>
<v t="amd_yen.20130325133433.2817"><vh>@button latex pdf</vh></v>
</v>
<v t="amd_yen.20130325133433.2818" a="E"><vh>c2g1 report</vh>
<v t="amd_yen.20130325133433.2819" a="E"><vh>選項設定</vh>
<v t="amd_yen.20130325133433.2820" a="E"><vh>@rst c2g1/frontmatter.html</vh>
<v t="amd_yen.20130325133433.2821"><vh>前言</vh></v>
<v t="amd_yen.20130325133433.2822"><vh>動機</vh></v>
</v>
</v>
</v>
<v t="amd_yen.20130325133433.2823"><vh>@auto c2g1/fromoutside.html.txt</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="amd_yen.20130306001037.1797"></t>
<t tx="amd_yen.20130306001037.1798">QSplitter::handle {
    background-color: #CAE1FF; /* lightSteelBlue1 */
}

QStackedWidget {
    /* background-color:lightpink; */
    border-color: red;
    padding: 0px;
    /* border-width: 0px; */
    /* background-color: yellow; */
}

QSplitter {
    border-color: white;
    background-color: white;
    border-style: solid;
}

QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 18px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 17px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 17px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 18px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 17px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 17px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="amd_yen.20130306001037.1799">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="amd_yen.20130307204656.1443">希望能夠比照 Leo Doc 的方式建構, 將每一週的上課內容進行註記, 然後使用者可以利用 Sphinx 與 LaTeX 將內容轉換成 html 與 pdf  檔案格式.

編寫方式採用 @file 與 @rst

希望參考

V:\misc\leo-editor-snapshot-20130223\leo\leoeditor_doc\LeoDocs.leo#Startup

註: 左手按住 Ctrl, 然後右手點選下一個子書籤就會帶出 Leo 的手冊 (假如是在 misc 目錄下工作時), 並且逐步將該內容中產生 html 與 pdf 的架構, 複製到課程相關的資料編輯模式中.

基本資料更新的流程如下:

1. 由網路上下載 portablKMOL, 並且啟動, 系統會自動開啟 Leo Editor 以及其他網際相關伺服器.

(需要有 portableGit, 至於其他相關工具與模組則可最佳化到最小容量, 額外的模組則依照需求再由網路中下載, 以附加的模式增加可攜系統的功能)

2. 以 git clone https://github.com/chiamingyen/mdeCourse.git

在電腦中的某一目錄中, 複製 gihub 有關 mdeCourse 的最新版本.

3. 利用 portablKMOL 中的 Leo Editor 開啟 mdeCourse 中的課程相關 .leo 檔案.

4. 配合課程進行, 修改課程筆記.

5. 下課之前, 以 portableGit 執行

git add .

git commit -m "commit message"

git push

但是此階段需要 .ssh 對應的 private key 資料

或許也可以利用 portableGithub 以登入的模式下, 將上述 clone 目錄中的資料, 執行 commit 與 publish 或 sync 的動作.</t>
<t tx="amd_yen.20130307204656.9867">V:\misc\leo-editor-snapshot-20130223\leo\leoeditor_doc\LeoDocs.leo#Startup</t>
<t tx="amd_yen.20130308103121.2379">2013.02

由於實際上課時, 必須配合各週次進行, 但是每幾週又會組成某一特定架構的介紹或實習, 因此 clone node 在這裡或許就可以派上用途, 例如花三週來說明 sgw 用於協同產品設計實習的群組套件搭建, 因此可以將 sgw 套件搭建流程一分為三, 並且在各週逐一完成某一特定內容的設定與實習, 而在手冊建立時, 則取三週的教學內容, 以 clone node 的方式組成 sgw 套件搭建與應用的主題.

當三週的設定與實習完成後, sgw 的設定與實習教材也能夠同步完成.

其次在上課的當下, 設法利用課程內容, 以程式建立 TCExam 相容的考題, 應該也是一項 Leo 可以發揮的地方, 由各週的上課內容中, 以特定知識或認知為考題的主軸, 然後納入 Leo 的延伸程式, 就能夠同步轉為考試題庫.

2013.03.13

重新架構 mdeCourse, 將先前的課程 github 刪除後重新在 .gitignore 中加入 _build 目錄, 讓每次所建立的 html 與 latex 檔案目錄不會送到 github.

假如配合目前上課內容的規劃, blog.kmol.info 是否仍有存在的必要? 應該可以設法配合 html 目錄, 由 Leo Editor 中的按鍵功能, 啟動將最新的 html 目錄送到某一主機對應內容, 讓學員都能擷取最新的課程相關資料, 也能夠從 github clone 最新的課程內容架構.

由於整體系統採用 Python3, 部分 Sphinx extension 功能還無法使用, html 中的中文搜尋也尚未啟動 (卡在繁體中文分詞的使用, 目前並沒有很好的方案).

PortableKMOL 能否再精簡?以配合導入 Leo Editor 之後的上課模式?

基本的架構:

Local - portableKMOL + local github clone

Remote - github repositories + OpenShift 上的 CMSimple XH

WordPress - 群組網誌

Simple Groupware - 專案管理系統

2013.03.18

以目前的想法, 將 Leo Editor 中的節點內容透過程式直接發布到 Wordpress 與 CMSimple 應該是最佳的做法, 雖然 Sphinx 可以將 rst 轉為 html, 但是中文內容搜尋問題較麻煩, 且採用 Javascript 擷取關鍵字庫的方式搜尋, 並沒有全文搜尋好, 因此現在傾向設法將節點內容轉為 CMSimple 的 content.htm 格式, 然後讓網際內容管理系統與 Leo Editor 中的節點同步.

另外一個考量則是將節點內容送到 Wordpress (透過 xmlrpc.php), 假如能夠在新增網誌內容同時取得遠端網誌存入資料庫的 id, 後續才能透過此對應 id 進行更新或刪除的動作.

為了讓 sphinx-build -b singlehtml 所產生的單一 html 檔案, 能夠轉為 CMSimple 的 content.htm, 必須要動用到 beautiful soup: http://www.crummy.com/software/BeautifulSoup/

產生單一 singlehtml 只要將 make.bat 中, "html" 程序中的 html 換成 singlehtml 就可以完成.

if "%1" == "html" (
    REM 若將 html 改為 singlehtml 則會建立一個單一 html 檔案
    REM %SPHINXBUILD% -b singlehtml %ALLSPHINXOPTS% _build/html
	%SPHINXBUILD% -b html %ALLSPHINXOPTS% _build/html</t>
<t tx="amd_yen.20130308210411.2383">尚未完成的內容為中文的索引與搜尋.

有關 Sphinx 中文搜尋:

由於 Sphinx 的搜尋採 Javascript 進行, 實作時必須要對中文內容進行分詞, 然後再與對應頁面進行連結, 如此就會造成許多問題, 假如在進行關鍵字分詞時, 系統未能納入特定的關鍵字, 則使用者便無法進行搜尋.

最好的方式當然是全文搜尋, 但是必須耗費較多時間, 有關這點必須再加以深入考量.

假如能夠將 Sphinx 所產生的 html 導入 CMSimple XH 的 content.htm 中, 應該就可以解決許多問題, 至於對應的 images, downloads, jscripts 與 plugins 也都必須要加以整合.</t>
<t tx="amd_yen.20130308210411.2384">為何選擇 Python 3

這項主題應該在程式語言(一) 的第一堂課程就已經說明, 但是對於程式語言的初學者, 假如只學過 Python, 可能對於程式語言之間的比較與印象並不會十分深刻, 若以曾經使用過 FORTRAN, Pascal, Basic, Perl, Visual Basic, C/C++, PHP, Java, Forth, Lisp 等程式語言的經驗來說, Python 語言對於機械設計工程專業人員來說, 具有下列優點:

Python 程式容易閱讀, Python 程式語言採用內縮 (每一個內縮單位通常為 4 個空白鍵)來界定區域執行的範圍, 因此能夠正確執行的 Python 程式必須排列整齊, 區段明確, 因此容易閱讀(C/C++, PHP, Java 等程式語言都採用 {} 來界定執行區段, 且允許各種程式碼行段的排列方式, 因此可能造成程式碼不易閱讀).

Python 程式語言內建高階資料結構, list, tuple, dictionary, set, string, bytes, int, float 等格式的交互應用下, 可以在不使用資料庫的情況下, 完成許多方便的數據與資料處理工作.

Python 程式語言採解譯(interpretation)執行, 動態性的資料型別方便程式的架構與編寫, 程式開發流程通常比採用編譯式(compiled)程式語言快上幾倍 (但是必須在程式執行速度上付出代價).

Python 程式語言內建許多常用的程式庫模組(modules), 即使在未安裝其他附屬模組情況下, 就能夠解決許多機械設計相關流程問題.

Python 程式語言自由開放(採接近 BSD 使用授權, 並且開放程式語言解譯系統的 C 原始碼, 除了 CPython, 還有以 Python 寫的 Pypy, 以 Java 寫的 Jython,  以 .Net 技術編寫的 IronPython, 以 Javascript 寫的 Skulpt 解譯系統)且跨操作系統平台 (可以在 Windows, Linux, Mac 系統上使用).

參考資料: https://github.com/bnmnetp/skulpt

Python 程式語言支援許多原本採 C/C++ 編寫程式庫的 CAD 核心碼介面擷取模組 (Open CASCADE), 2D 繪圖套件有 PythonCAD (PyQt), 3D CAD 則有 FreeCAD (PyQt), PLM 則有 OpenPLM (PyQt), 以及支援 mechanics, multibody dynamics 分析用的模擬套件.

參考資料: 

http://www.libremechanics.com/

Mechanics

http://sourceforge.net/projects/libremechanics/files/

Multibody dynamics

http://sourceforge.net/projects/pymbs/files/

Python 程式語言支援許多科學(Scipy)、數值(Numpy)與符號式(Sympy)運算模組, 可以解決許多類似 Matlab 套件的工程運算問題.</t>
<t tx="amd_yen.20130308210411.2385"></t>
<t tx="amd_yen.20130308210411.2386"></t>
<t tx="amd_yen.20130308210411.2403">@language python
import os
pos = c.find_h("KMOL Guide")[0]
c.selectPosition(pos)
c.k.simulateCommand('rst3')
&lt;&lt; html manual &gt;&gt;
&lt;&lt; pdf manual &gt;&gt;
</t>
<t tx="amd_yen.20130308210411.2404">'''
c is the commander of the outline containing the script.
g is Leo's leo.core.leoGlobals module.
p is the presently selected position, the same as c.p.
'''
d = c.scanAllDirectives(p)
# d 為 commander 由目前所在目錄進行指令設定掃描
# d 資料格式為 dictionary
''' 
實際操作下, d 為 
{'tabwidth': -4, 'lineending': None, 'language': 'python', 'encoding': None, 'pluginsList': [], 'pagewidth': 70, 'wrap': True, 'path': 'D:\\github\\mdeCourse\\2013spring', 'delims': ('#', '', '')}
'''
mandir = d.get('path') + "/document"
# 取出 d dictionary 中的 path 對應值 (也就是目前所在絕對目錄), 再加上 html, 因此 mandir 即為目前所在目錄下的 html 子目錄路徑
g.es(mandir) # 列出 html 子目錄路徑
os.chdir(mandir)  # 更換目錄到 html 子目錄
os.system('make html')  # 執行 make html
</t>
<t tx="amd_yen.20130308210411.2405"># you probably need to install several packages 
# to create pdf (e.g. jadetex)
mandir = d.get('path') + "/document"
g.es(mandir)
os.chdir(mandir)
os.system('make latex')
os.chdir('_build/latex')
# 接下來要設法將 .tex 轉為 .pdf
target_name = "KMOLdocumentation"
filename = target_name+".tex"
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
filename = target_name+".xdv"
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xdvipdfmx.exe -vv -E "+filename)

#
#os.system(target_name.replace(".xdv", ".pdf"))
filename = target_name+".pdf"
os.system(filename)
#os.system('../../fixup.pl &lt; Leodocumentation.tex &gt; LeoDoc.tex')
#os.system('make LeoDoc.pdf')</t>
<t tx="amd_yen.20130308210411.2406"></t>
<t tx="amd_yen.20130308221230.2437"></t>
<t tx="amd_yen.20130308221230.2457">程式語言(二)

Python docutils 相關功能的應用, 可以透過網路擷取特定文件檔案 (mark down) 與影像檔, 然後以程式方法將資料轉成 html 文件.

之後這些 mark down 格式文件還可以利用 Python 的 Sphinx 套件轉為 .tex 格式, 並且進一步再轉為 pdf 檔案.

重點:

1. 純文件檔案內容, 以 mark down 方式整理, 可以讓各組員分散建置.

2. 若需要將各組員的資料內容, 整理成為報告或論文格式, 應該要善用網路與程式方法, 比較容易整合.

3. 程式模式下的文書處理, 可以用於網際協同, 相同的資料與內容處理, 也可套用到協同機械設計流程.</t>
<t tx="amd_yen.20130308221230.2462">讓學員自行建構可攜 portableKMOL 的目的在練習網際程式框架的基本組成 (程式開發環境、內容管理系統、全球資訊網伺服器、以及各類相關工具), 學員熟悉此流程後, 可以自行修改框架並且配合需要進行各模組的改版.

1. 利用程式進行文書處理

2. 利用程式進行分析運算與設計檔案轉換

以安裝 Python33 所使用的各模組, 各舉出應用範例, 並以機械設計相關應用為考量

    Python 3.3 版與相關模組安裝:
    
    Python 3.3 本體
    
    http://www.python.org/download/
    
    安裝後 C:\Python33 約佔 33 MB
    
    distribute (Python 的 module  installer, 可利用 easy_install 安裝所需模組)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#distribute
    
    安裝後 C:\Python33 約佔 37 MB
    
    pip (Python 的 module installer, 安裝後可利用 "pip install 模組名稱" 完成模組安裝
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#pip
    
    安裝後 C:\Python33 約佔 38 MB
    
    win32com (Python 與 Windows COM 物件的連結模組, 可以利用 win32com 來連結 SolidWorks, Inventor, Word, Excel 等 Windows 應用程式物件)
    
    http://sourceforge.net/projects/pywin32/files/pywin32/Build%20218/
    
    安裝後 C:\Python33 約佔 64 MB
    
    PIL (Python 的 Image library, 可以處理 2D 影像檔案)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#pil
    
    安裝後 C:\Python33 約佔 67 MB
    
    matplotlib (Python 類似 matlab 的 plot library)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#matplotlib
    
    安裝後 C:\Python33 約佔 91 MB
    
    numpy (Python 的 numerical library, 用於數值分析運算)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy
    
    安裝後 C:\Python33 約佔 138 MB
    
    sympy (Python 的 Symbolic manipulation 模組, 用於符號式運算 (相對於數值分析))
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#sympy
    
    安裝後 C:\Python33 約佔 175 MB
    
    scipy (Python 的 Scientific library)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy
    
    安裝後 C:\Python33 約佔 292 MB
    
    PyQt (Python 連結 Qt (nokia 的開源 GUI 程式庫, 更自由的對應類似版本為 Pyside) 的程式庫, 可用來開發圖形介面單機程式, 例如: Leo editor 就是採用 PyQt 開發)
    
    http://www.riverbankcomputing.com/software/pyqt/download
    
    安裝後 C:\Python33 約佔 374 MB
    
    docutils (Python 的 document utility, 可將 rst 格式檔案轉為 html)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#docutils
    
    安裝後 C:\Python33 約佔 383 MB
    
    Leo editor (以 Python 編寫的 outliner 與 IDE)
    
    http://www.greygreen.org/leo/
    
    安裝後 C:\Python33 約佔 401 MB
    
    以C:\Python33\Scripts\pip install sphinx
    
    安裝後 C:\Python33 約佔 413 MB

單機模式
網際模式

3. 利用程式進行協同設計

網際機械設計流程 - 以 Pyforum + brython 為範例, 可以開發 html5 網際程式
網際內容管理 - django based CMS
網際專案管理 - OpenPLM - http://wiki.openplm.org/trac/wiki/Credits
OpenERP/PLM - http://www.openerpplm.eu/</t>
<t tx="amd_yen.20130308221230.2463">自 C2 開始逐步讓學員涉入 portableKMOL 各模組的建構流程, 以便有能力自行修改內容並且依照需求改版.</t>
<t tx="amd_yen.20130308221230.2464">利用(Python)程式進行文書處理

1. 需要安裝 docutils 模組

2. 也可以利用 Sphinx 模組將 rst 檔案轉為 html 與 tex, 然後再以 MikeTeX 將 tex 轉為 pdf 檔案</t>
<t tx="amd_yen.20130308221230.2492"></t>
<t tx="amd_yen.20130308221230.3827"></t>
<t tx="amd_yen.20130309155804.1706"></t>
<t tx="amd_yen.20130312013510.1498">所謂的電子書內容, 就是 Leo 中據以產生 html 與 pdf 檔案的主要內容, 其中包含程式內容的引用.

為了要能夠維繫各內容始終只有一個版本的精神, 必須要將電子書的內容加以分割, 除了以發布的週次作為區隔外, 各週的主要文字說明與程式也是分離, 程式內容位於各課程的分週程式區, 以 literalinclude 指令導入主文.

而這些主要的文字說明, 因為內置許多 rst 的指令, 若要再同時拿來作為網誌的發布內容, 有以下考量:
    
    是採取 rst 內容經過 button 程式處理, 以分割主文加上程式的內容進行傳遞, 抑或在 rst 轉為 html 後, 同時設法產生網誌版本, 並且以自動讀取特定 local 電腦區域的帳號/密碼後才進行傳遞?
    
    採 rst 轉換的方式, 工程較為浩大, 而 rst 轉 html 後, 則必須同時介入 Sphinx 轉換 html 的流程, 可以採 extension 的導入方式處理, 模式較為正統.
    
    Leo editor 一個內容, 多種用途 (view) 的特性, 在這個範例處理流程中, 將可充分展現.
    
    假如能夠使用 make.bat 中的 make wordpress, 過程中除了將 rst 轉換成 wordpress 的特定格式內容外, 並且會讀取相關發布的帳號密碼, 並且自動完成內容的發布, 應該是最佳處理方案.</t>
<t tx="amd_yen.20130312013510.1501">網誌內容為 clone 特定電子書的部分內容後, 針對網誌的 html 標註加以組合, 然後透過按鈕的程式執行, 將網誌內容直接送到 blog.kmol.info.

這裡有幾個重要必須突破:

電子書的內容必須配合進行分割, 例如: 區分為主文與程式, 然後主文的分段以 &lt;img src="/n/1.png"&gt;&lt;/img&gt; 為開頭, 並且依序進行增量.

&lt;!-- more --&gt; 的置入

&lt;pre&gt;&lt;/pre&gt; 程式碼的置入

[password-protect] [/password-protect] 的置入

若以 button 的指令送出網誌內容, 則連結網誌的管理者密碼該如何進行保全: 不放入 leo 但是卻能讓 button 程式讀取. (或可採用 minibuffer 區域的密碼讀取)</t>
<t tx="amd_yen.20130312013510.1824">#coding: utf-8

# 導入 os 模組
import os
'''
以下經由 urllib 向網路 URL 取得文件內容
'''
# 導入 urllib.request
import urllib.request
# 導入用來處理 rst2html 的 publish_string
from docutils.core import publish_string

# 可以取得目前所在節點與其下屬節點的內容
# 從目前所在節點位置找出節點所屬的課程名稱
mylist = []
for parent in p.self_and_parents_iter():
    mylist.append(parent.h)
# 倒數第 2 個就是課程名稱
課程名稱 = mylist[-2]
g.es("將要上傳的課程名稱:"+課程名稱)
g.es()
網誌內容 = ""
for p in p.self_and_subtree():
    # p.b 為目前所在節點的內文 (body text)
    網誌內容 += p.b
    #g.es(p.b)
'''
g.es("課程內容如下:")
g.es()
g.es(網誌內容)
'''
''' 因為 Leo 中的 rst 節點都是採用 Sphinx 語法與延伸程式, 因此無法僅透過 docutils 將 rst 節點內容轉為 html, 而必須設法利用 Sphinx 處理
'''
# 利用 docutils.core 模組中的 publish_string() 方法, 將 rst 內容轉為 html
超文件內容 = publish_string(
        source=網誌內容,
        writer_name='html',
        settings = None,
        settings_overrides={'output_encoding': 'unicode'}
    )
g.es(超文件內容)</t>
<t tx="amd_yen.20130314194325.1514">@language python
# 此一按鈕的用法為選擇節點然後按下上方的 generate-current button
# 希望能將此 button 改寫為局部產生 html 與 pdf
import os
# 位置為目前所選的節點
pos = c.p
# 將 commander 指定在目前所選的節點位置
c.selectPosition(pos)
# 針對節點位置執行 rst3 指令, 將內容轉為 rst 格式
c.k.simulateCommand('rst3')
# 接著將 rst 格式檔案轉為 html
&lt;&lt; html manual &gt;&gt;
# 將 rst 格式檔案轉為 pdf
&lt;&lt; pdf manual &gt;&gt;</t>
<t tx="amd_yen.20130314194325.1746"></t>
<t tx="amd_yen.20130317160119.1726"></t>
<t tx="amd_yen.20130318140025.2832"></t>
<t tx="amd_yen.20130318140025.2833">機械設計工程師所需要的程式語言

機械設計是一個資訊密集的遞廻流程:

    資訊密集 - 機械設計所做的每一個決策都會產生資料, 這些資料包括用來定義產品的規格, 以及訂定此規格的環境與緣由.
    
        產品規格 (specifications) - 包括產品性能、零組件尺寸、零組件材料、零組件加工流程、替代零組件等.
        訂定規格的環境 (environment) - 包括假設條件 (conditions and models)、如何 (how) 完成性能評估、如何取得優勢 (專利)、如何進行協同、如何管理等 (where, who, when, what).
        訂定規格的緣由 (reasons) - 包括產生各項資訊的前因與後果 (why).
    
    遞廻流程 - 重複因應問題、變更設計、期在產品生命週期流程中求取產品價值最大化.
    
因此程式語言就機械設計工程師運用電腦執行上述工作項目時, 期採最具效率的方式進行:
    
    以電腦管理資訊 - 文書處理、建立網站、登錄日誌
    以電腦評估規格 - 數值運算 (numerical)、科學運算 (science)、建立模型、執行工程設計分析
    以電腦建構環境 - 單機程式、網際程式、協同專案環境
    以電腦因應問題 - on demand 處理問題、以工作流程 (審批流程) 留下決策的細節資料
    
程式語言工作項目:
    
    程式語言基本概念
    
        會否採用程式方法進行數值運算、科學運算、資料處理 (程式語言(一)) - C1_intro
        會否採用程式方法建立單機程式  (程式語言(二)) - C2_app (採用 tkinter 與 PyQt GUI 介面)
        會否採用程式方法建立網際程式  (程式語言(一)) - C1_web (採用 CherryPy, bottle 與 django 網際框架)
        
    會否採用程式方法進行文書處理 (程式語言(二)) - C2_leo
    會否採用程式方法建立網站、登錄日誌  (程式語言(一)) - C1_cms
    會否採用程式方法搭建協同專案環境 (程式語言(二)) - C2_web, C2_cd

程式語言課程規劃內容

C1_intro - 基本程式語法, 程式數值運算與資料處理
C1_cms - 網際內容管理, CMSimple XH
C1_web - 網際程式框架, CherryPy

C2_leo - 文書處理, docutils, Sphinx, Leo Editor, MikTeX
C2_app - 應用程式, tkinter 與 PyQt
C2_web - 網際程式框架, CherryPy, bottle 與 django
C2_cd - 網際協同, c9.io, 免費虛擬主機 (http://www.1freehosting.com/) , Simple Groupware</t>
<t tx="amd_yen.20130325133433.2805">以下示範如何在 KMOL Guide 的架構下, 新增一個節點用來產生第二本協同手冊

一本協同手冊的建立總共有三個部分

- 按鈕

用來執行 make html 與 make latex 以及最後的 xelatex 指令, 可以產生 html 與 pdf 格式的報告內容

按鈕的內容如下:

.. code-block:: python

    @language python
    import os
    pos = c.find_h("c2g1 report")[0]
    c.selectPosition(pos)
    c.k.simulateCommand('rst3')
    &lt;&lt; html manual &gt;&gt;
    &lt;&lt; pdf manual &gt;&gt;

必須要在 c.find_h() 中填入所要處理報告的標題, 這裡的範例標題為 c2g1 report, html 部分則需要修改 mandir = d.get('path') + "/c2g1", 指定處理目錄為 c2g1, pdf 部分除了指定文件原始目錄為 c2g1 外, 還需要告知 target_name = "index", 此一設定必須與 conf.py 中的 master_doc = 'index' 彼此對應.

- 設定檔案

共有三個, 包括 conf.py, toc 與 make.bat, conf.py 為 sphinx 的設定檔案, toc 則指定要加入哪些章節檔案, make.bat 則是實際執行 sphinx 指令的批次檔案.

conf.py 中重要的設定為:

_exts = "../exts"
extensions.append('chinese_search')
source_suffix = '.html.txt'
master_doc = 'index'
latex_documents = [
  ('index', 'index.tex', 'C2G1 使用者手冊',
   'Chiaming Yen', 'manual'),]

- 報告內容

報告內容分為兩類, 一類為單機上的資料, 以 @rst 節點導入後, 可以自動依照 Leo 節點從屬關係產生標題與內文, 第二類的報告內容則為由外部送入的檔案, 可以利用 @auto 節點指令將這些內容加入, 各外部檔案的名稱必須在 index.html.txt 中宣告.</t>
<t tx="amd_yen.20130325133433.2806"></t>
<t tx="amd_yen.20130325133433.2807">@language python
import os
pos = c.find_h("c2g1 report")[0]
c.selectPosition(pos)
c.k.simulateCommand('rst3')
&lt;&lt; html manual &gt;&gt;
&lt;&lt; pdf manual &gt;&gt;
</t>
<t tx="amd_yen.20130325133433.2808">'''
c is the commander of the outline containing the script.
g is Leo's leo.core.leoGlobals module.
p is the presently selected position, the same as c.p.
'''
d = c.scanAllDirectives(p)
# d 為 commander 由目前所在目錄進行指令設定掃描
# d 資料格式為 dictionary
''' 
實際操作下, d 為 
{'tabwidth': -4, 'lineending': None, 'language': 'python', 'encoding': None, 'pluginsList': [], 'pagewidth': 70, 'wrap': True, 'path': 'D:\\github\\mdeCourse\\2013spring', 'delims': ('#', '', '')}
'''
mandir = d.get('path') + "/c2g1"
# 取出 d dictionary 中的 path 對應值 (也就是目前所在絕對目錄), 再加上 html, 因此 mandir 即為目前所在目錄下的 html 子目錄路徑
g.es(mandir) # 列出 html 子目錄路徑
os.chdir(mandir)  # 更換目錄到 html 子目錄
os.system('make html')  # 執行 make html
</t>
<t tx="amd_yen.20130325133433.2809"># you probably need to install several packages 
# to create pdf (e.g. jadetex)
mandir = d.get('path') + "/c2g1"
g.es(mandir)
os.chdir(mandir)
os.system('make latex')
os.chdir('_build/latex')
# 接下來要設法將 .tex 轉為 .pdf
target_name = "index"
filename = target_name+".tex"
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
filename = target_name+".xdv"
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xdvipdfmx.exe -vv -E "+filename)

#
#os.system(target_name.replace(".xdv", ".pdf"))
filename = target_name+".pdf"
os.system(filename)
#os.system('../../fixup.pl &lt; Leodocumentation.tex &gt; LeoDoc.tex')
#os.system('make LeoDoc.pdf')</t>
<t tx="amd_yen.20130325133433.2810"></t>
<t tx="amd_yen.20130325133433.2811"></t>
<t tx="amd_yen.20130325133433.2815"></t>
<t tx="amd_yen.20130325133433.2816">@language latex
% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}

% \pdfpagewidth 195mm
% \pdfpageheight 271mm
% \textwidth 6.0in
% \textheight 8.8in
% \oddsidemargin -0.1in
% \evensidemargin -0.1in

\textwidth 6.8in
\oddsidemargin -0.2in
\evensidemargin -0.3in

\usepackage{pdfpages}
\usepackage[BoldFont,CJKchecksingle]{xeCJK}

    \usepackage{fancyvrb}    % for frame on Verbatim
    \usepackage{fancyhdr}
    \usepackage[T1]{fontspec}    %設定字體用

\usepackage{float}
\usepackage{ccaption}
\usepackage{pifont}
% \usepackage{fancybox}
\usepackage{fontspec,xunicode,xltxtra}

\setsansfont{Times New Roman}
\setmainfont{Times New Roman}
\setmonofont{Times New Roman}
% 新細明體
% 文鼎ＰＬ新宋
% 文鼎ＰＬ明體U20-L
% 文鼎ＰＬ报宋二GBK
\setCJKsansfont[BoldFont={新細明體},ItalicFont={新細明體}]{新細明體}
\setCJKromanfont[BoldFont={新細明體},ItalicFont={新細明體}]{新細明體}
\setCJKmainfont[BoldFont={新細明體},ItalicFont={新細明體}]{新細明體}
\setCJKmonofont[BoldFont={新細明體},ItalicFont={新細明體}]{新細明體}

    \makeatletter
    \def\verbatim@font{\rmfamily\small}    %為了讓 verbatim 註解中能夠加入中文, 採用 roman family 字體
    \makeatother

\XeTeXlinebreaklocale "zh"    %讓中文自動換行
\XeTeXlinebreakskip = 0pt plus 1pt
\renewcommand{\baselinestretch}{1.3} 
\setcounter{tocdepth}{3}
\captiontitlefont{\small\sffamily}
\captiondelim{ - }
\renewcommand\today{\number\year年\number\month月\number\day日}
\makeatletter
\renewcommand*\l@subsection{\@dottedtocline{2}{2.0em}{4.0em}}
\renewcommand*\l@subsubsection{\@dottedtocline{3}{3em}{5em}}
\makeatother
\titleformat{\chapter}[display]
{\bfseries\Huge}
{\filleft \Huge 第 \hspace{2 mm} \thechapter \hspace{4 mm} 章}
{4ex}
{\titlerule
\vspace{1ex}%
\filright}
[\vspace{1ex}%
\titlerule]
%\definecolor{VerbatimBorderColor}{rgb}{0.2,0.2,0.2}
\definecolor{VerbatimColor}{rgb}{0.95,0.95,0.95}


\title{C2G1 使用者手冊}
\date{}
\release{1.0}
\author{Chiaming Yen}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{釋出}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&amp;}
\def\PYGZlt{\char`\&lt;}
\def\PYGZgt{\char`\&gt;}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


\href{http://blog.kmol.info}{KMOL's home page}


\chapter{C2G1 報告}
\label{frontmatter:kmol-s-users-guide}\label{frontmatter::doc}\label{frontmatter:c2g1}
\index{C2G1 報告}\setbox0\vbox{
\begin{minipage}{0.95\linewidth}
\textbf{Contents}

\medskip

\begin{itemize}
\item {} 
{\hyperref[frontmatter:c2g1]{C2G1 報告}}
\begin{itemize}
\item {} 
{\hyperref[frontmatter:id1]{前言}}

\item {} 
{\hyperref[frontmatter:id2]{動機}}

\end{itemize}

\end{itemize}
\end{minipage}}
\begin{center}\setlength{\fboxsep}{5pt}\shadowbox{\box0}\end{center}


\section{前言}
\label{frontmatter:id1}
這是前言內容


\section{動機}
\label{frontmatter:id2}
這是動機內容


\chapter{這是 outside 標題}
\label{fromoutside::doc}\label{fromoutside:outside}
\index{outside 標題}\setbox0\vbox{
\begin{minipage}{0.95\linewidth}
\textbf{Contents}

\medskip

\begin{itemize}
\item {} 
{\hyperref[fromoutside:outside]{這是 outside 標題}}
\begin{itemize}
\item {} 
{\hyperref[fromoutside:id1]{小標題}}

\item {} 
{\hyperref[fromoutside:id2]{小標題2}}

\end{itemize}

\end{itemize}
\end{minipage}}
\begin{center}\setlength{\fboxsep}{5pt}\shadowbox{\box0}\end{center}

以下就是 outside 的內容, 由某一位組員負責編寫

這是外部的檔案, 來自外部的內容

這是第二次從外部更新的檔案


\section{小標題}
\label{fromoutside:id1}
這是小標題之後的內容, 假如希望從網際系統取得組員的 frontouside.html.txt, 可以透過 CMSimple 的 upload 機制.


\section{小標題2}
\label{fromoutside:id2}
這是小標題2之後的內容, 經過 sphinx 處理後的 html 目錄則可以利用 mongoose 或 nginx 派送到網站上, 也可以將 html 目錄中的內容轉送到雲端網站中.

以下嘗試由 literalinclude 導入程式碼:

\begin{Verbatim}[commandchars=\\\{\}]
\# -*- coding: utf-8 -*-
\# 配合程式所使用的 @asis 會將資料存在 .leo 檔案
\# 建立虛擬的班級人員名單
import random
import string
學號碼數 = 4
姓名字數 = 3
姓氏檔案 = "lastname.txt"
名字檔案 = "firstname.txt"
學生人數 = [53, 55]
\# 讀進姓氏檔案與名字檔案
各班學生人數=random.randint(學生人數[0], 學生人數[1])
def makeNumber(學號碼數):
    return ''.join([random.choice(string.digits) for 索引 in range(學號碼數)])

開啟姓氏檔案 = open(姓氏檔案, "r", encoding="utf-8")
姓氏 = 開啟姓氏檔案.readlines()
開啟名字檔案 = open(名字檔案, "r", encoding="utf-8")
學員檔案 = open("虛設學員.txt","w",encoding='utf-8')
名字 = 開啟名字檔案.readlines()
科系碼 = makeNumber(學號碼數)
for 索引 in range(1, 各班學生人數):
    if(len(str(索引)) == 1):
        學號 = "0" + str(索引)
    else:
        學號 = str(索引)
    \# 設法製造缺號
    if random.randint(0, 100) \textgreater{} 3 :
        姓 = 姓氏[0][random.randint(0, len(姓氏[0])-1)]
        名 = 名字[0][random.randint(0, len(名字[0])-1)]
        名 += 名字[0][random.randint(0, len(名字[0])-1)]
        print("90"+科系碼+學號+" "+姓+名)
        學員檔案.write("90"+科系碼+學號+" "+姓+名+"\PYGZbs{}n")

開啟姓氏檔案.close()
開啟名字檔案.close()
學員檔案.close()

'''

以下為 lastname.txt 的內容:

趙錢孫李周吳鄭王馮陳褚衛蔣沈韓楊朱秦尤許何呂施張孔曹嚴華金魏陶薑
戚謝鄒喻柏水竇章雲蘇潘葛奚範彭郎魯韋昌馬苗鳳花方俞任袁柳酆鮑史唐
費廉岑薛雷賀倪湯滕殷羅畢郝鄔安常樂於時傅皮卞齊康伍餘元蔔顧孟平黃
和穆蕭尹姚邵湛汪祁毛禹狄米貝明臧計伏成戴談宋茅龐熊紀舒屈項祝董梁
杜阮藍閔席季麻強賈路婁危江童顏郭梅盛林刁鍾徐邱駱高夏蔡田樊胡淩霍
虞萬支柯昝管盧莫柯房裘繆幹解應宗丁宣賁鄧鬱單杭洪包諸左石崔吉鈕龔
程嵇邢滑裴陸榮翁荀羊于惠甄曲家封芮羿儲靳汲邴糜松井段富巫烏焦巴弓
牧隗山穀車侯宓蓬全郗班仰秋仲伊宮甯仇欒暴甘鈄曆戎祖武符劉景詹束龍
葉幸司韶郜黎薊溥印宿白懷蒲邰從鄂索鹹籍賴卓藺屠蒙池喬陽鬱胥能蒼雙
聞莘党翟譚貢勞逄姬申扶堵冉宰酈雍卻璩桑桂濮牛壽通邊扈燕冀浦尚農溫
別莊晏柴瞿閻充慕連茹習宦艾魚容向古易慎戈廖庾終暨居衡步都耿滿弘匡
國文寇廣祿闕東歐殳沃利蔚越夔隆師鞏厙聶晁勾敖融冷訾辛闞那簡饒空曾
毋沙乜養鞠須豐巢關蒯相查後荊紅

以下為 firstname.txt 的內容:

平燦惠歡佩泰州江揚剛乃屏珊易吟定小其菱幼函琴青博兆菁重立呈然永奕
漢義萍皓力昌妍合仲佳虹慧蓮恭石展軒啟奇秀駿晉冰政綸丹邦大冠貞生思
玄威嘉依音雲英能緯彬妙聖協法瑞恆采心友昀花樺航玫宛順儀寶婷書妮胤
彥修火雨俞孝蕙允城盈家陽琳阿紹誠倫亨星美和予念鳳凱松幸凡雯士達泓
金瑜勇必珍芷岳鈺方琬成霞麟致哲台睿賢珠瑩南克為尹妤春怡亮伯喬夫昕
亞真喜初愛清禮斌吉淳百臻寧以筠諭仕子文雅郁柏秋蓉伸福劭木宗傑丞昭
芝弘宇明月峰東聿登左祥迪蘭佑甫雄俊之卉谷玲禾茹榮堯芬姍少謙琇禎蘋
年姵勳任信旭燕苓豐惟盛發齊介芳容于維侑舜洋璇茂芃伊玉海建季雪柔汝
千富男新昱人添群欣綠馨利宜堅意名右姿智韻典竹巧坤可全潔裕毓孜仁韋
慈志琦宣希云茜辛薇梅樂妏嬌安上仰長承旺珮良鑫桓瑋光貴茵憲品綺芸天
源娟輝君銘夙來昇如泉正廷峻瑤恬靖淑瑄行秉伶康水羽治妹宥夢映霖儒枝
沛香皇一龍興延翰山卿白忠恩亭俐孟均元凌又偉強育辰萱鴻宸亦娥振中紫
倩民隆善玟紋杰旻學若華豪湖帆恒佐桂蓁穎軍德財庭琪世林純岑原尚昆妃
宏
'''
\end{Verbatim}

\href{http://blog.kmol.info}{KMOL's home page}



\renewcommand{\indexname}{索引}
\printindex
\end{document}
</t>
<t tx="amd_yen.20130325133433.2817">@language python

'''
主要用來細部修改 tex 檔案後, 再次產生所需要的 pdf 檔案
'''
</t>
<t tx="amd_yen.20130325133433.2818"></t>
<t tx="amd_yen.20130325133433.2819">@language rest
@tabwidth -4

@ @rst-options
call_docutils=False
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = True
verbose=True
@c
</t>
<t tx="amd_yen.20130325133433.2820">################################################
C2G1 報告
################################################

.. index:: C2G1 報告

.. contents::
    :depth: 3</t>
<t tx="amd_yen.20130325133433.2821">這是前言內容</t>
<t tx="amd_yen.20130325133433.2822">這是動機內容</t>
<t tx="amd_yen.20130406103207.2286">@language python
import os
d = c.scanAllDirectives(p)
# 將目錄指到 wcm
mandir = d.get('path') + "/wcm"
g.es(mandir)
os.chdir(mandir)
# 建立 mysite 專案
project_name = "mysite"
os.system("python V:/IDE/Python33/Scripts/django-admin.py startproject "+project_name)</t>
<t tx="amd_yen.20130406103207.2287">@language python
import os
d = c.scanAllDirectives(p)
# 將目錄指到 wcm
mandir = d.get('path') + "/wcm"
g.es(mandir)
os.chdir(mandir)
# 建立 mysite 專案
project_name = "mysite"
os.chdir(project_name)
os.system("python manage.py startapp polls")
#os.system("python manage.py runserver")
</t>
<t tx="amd_yen.20130406103207.2434">@language python
# 將管理者密碼設為 admin/admin
import os
d = c.scanAllDirectives(p)
# 將目錄指到 wcm
mandir = d.get('path') + "/wcm"
g.es(mandir)
os.chdir(mandir)
# 建立 mysite 專案
project_name = "mysite"
os.chdir(project_name)
os.system("python manage.py syncdb")</t>
<t tx="amd_yen.20130406103207.2437">@language python
import os
d = c.scanAllDirectives(p)
# 將目錄指到 wcm
mandir = d.get('path') + "/wcm"
g.es(mandir)
os.chdir(mandir)
# 建立 mysite 專案
project_name = "mysite"
os.chdir(project_name)
os.system("python manage.py sql polls")</t>
<t tx="amd_yen.20130406103207.2438"></t>
<t tx="amd_yen.20130406103207.2439">https://docs.djangoproject.com/en/1.5/intro/tutorial02/</t>
<t tx="amd_yen.20130406103207.2441">python manage.py runserver 127.0.0.1:8090

在 Leo 中啟動 django 與 關閉 django 的流程, 可以套用類似 pyforum exiting 的方式:

'''
# 退出函式
def exiting(self):
    print("系統即將退出!")
    print("所要終止的 PID 為:"+ str(os.getpid()))
    # 必須要使用 /F forced mode 與 /T tree mode 才能真正 kill pyforum.py 對應的 process
    os.system("taskkill /F /T /PID "+str(os.getpid()))
exiting.exposed = True
'''</t>
<t tx="amd_yen.20130406103207.2442">https://docs.djangoproject.com/en/1.5/intro/tutorial01/</t>
<t tx="amd_yen.20130406103207.2444">機械設計牽涉機械、設計與其過程所涉各項事物的管理與表達.

管理的目的在提升效能, 而表達的目標則在增進溝通, 降低過程中不同團隊成員間產生謬誤與衝突的機會.

機械設計所需的能力:

1. 產生想法與表達想法的能力 - 如何產生構想與創意、如何表達構想與創意等.

2. 評量想法所需的理論知識能力 - 評量所設計產品所需成本、採用何種方法完成某一事物、所能達到的產品品質、推出市場所需的時間、製造所需的技術等.

3. 累積經驗的能力 - 如何整理經驗、如何管理經驗過程中所積壘的資料.

4. 與其他專業團隊成員溝通的能力 - 溝通的本質在於透明與全盤托出事物的核心價值.</t>
<t tx="amd_yen.20130406103207.2445">設計就是設想然後加以評量, 最後將經過設想與評量的結果表示出來.  因此設計牽涉至少三個步驟:

1. 設想 - 所謂設想就是在尚未落實與評價之前, 對於某一事物執行過程的想法, 可以是初步的原始概念, 也可以是根據現況加以修改的想法.

2. 評量 - 就是採用各種可行方法對設想的內容加以評價, 判定想法是否可行, 或者思考或實際驗證採用哪一做法可以得到更好的預期結果.

3. 呈現出結果 - 利用其他人可以充分理解或接受的表示方法, 將設想與評量結果表達出來.

範例:

設計的動機 - 在校園裡的自行車經常會遭竊, 因此希望能夠有一種自行車在不使用時, 能夠降低遭竊的機會.

設想階段 - 根據自行車產品遭竊的流程, 就是因為自行車僅使用簡單的鎖具, 因此保全度不佳, 設計的想法之一就是加強鎖固自行車的設施.

而另一種設計的想法則是, 讓自行車"始終"在使用者的身邊, 可以再不使用時摺疊成可以隨身攜帶的狀況, 因此另外一種設計的想法就是減輕自行車的重量, 縮小摺疊後的體積.

完成基本的設想階段後, 就是評量"加強鎖固自行車的設施" 與 "輕量可摺疊隨身" 的自行車與附件產品的進一步設計構想與細節驗證等.

而最後的設計結果, 就是根據想法與驗證, 將可行方案的執行方式細節完整表達.</t>
<t tx="amd_yen.20130406103207.2446">機械為經過機巧安排的器械, 通常牽涉利用能量的轉換來達成機巧的安排, 固力的機巧安排通常為機構, 而流力的機巧安排則牽涉到熱與流體的能量交換.</t>
<t tx="amd_yen.20130406103207.2447">達成目的的最簡單做法
最經濟的做法 (整體產品生命週期過程中成本最低者)
所需時間最短的做法
產品容易使用與維修 (護) - 符合人體工學與本能操作流程
擁有最長使用壽命
外觀容易為使用者接受 (賞心悅目)
採用先進並符合潮流之技術</t>
<t tx="amd_yen.20130406103207.2448">力學 - 靜力學、動力學、材料力學、熱力學、流體力學

機構 - 機構學、機動學、機器動力學

數學 - 微積分、工程數學、工程分析、變分學

控制 - 電子學、電路學、振動學、自動控制

程式 - 程式語言、網際程式、資料庫程式、專利寫作實務

管理 - 內容管理、產品資料管理、產品生命週期管理、工廠管理

設計 - 電腦輔助設計、協同產品設計、機械元件設計、機械系統設計、系統整合設計

分析 - 電腦輔助工程分析、機械系統分析與模擬

製造 - 工廠實習、機械製圖、機械公差、夾治具設計、工具機實習、模具設計、非傳統加工
</t>
<t tx="amd_yen.20130406103207.2449">創新設計 (原創設計) - 產出前所未有的新穎與高性能設計內容, 重點在於 innovation 創新

概念設計 (重新設計) - 根據構想、方法或工具的激發, 大致安排所需的內容設計, 重點在於 concept 概念

參數設計 - 基本概念已經決定, 但是必須根據所需的產品規格來調整變化產品的設計參數, 以調配出所需的設計元件, 重點在於 parametric 改變與組合

配置設計 - 基本元件參數已經決定, 但是必須從這些基本的元件加以組合, 配置成不同的設計以進行評估及選擇, 重點在於 configuration 配置

元件細部設計 - 配置方法已經決定, 但必須從既有的標準元件中選擇適合規格與性能的設計元件, 重點在於 selection 選擇</t>
<t tx="amd_yen.20130406103207.2450">設計運算 - design computatin

設計繪圖 - design graphics

設計模擬 - design animation

設計資料管理 - design data management (包括文書處理與資料處理或轉換)</t>
<t tx="amd_yen.20130406103207.2451">設計分工以爭取時效 - 將大任務分成許多部份由多人同步開展

專業分工以提升產品品質 - 以全球觀點尋找最適合團隊 (搭配性、技術性、互補性等) 來進行產品某部分專業的設計

區域分工以降低產品成本 - 依照產品材料取得與設計、製造、行銷或回收等成本考量, 由不同地理區域團隊分工執行

策略分工以防止核心技術外流或侵權 - 依照產品技術拆解或專利部署考量, 廠商間進行交叉代工合作</t>
<t tx="amd_yen.20130406103207.2760">C Pointer and Array

註: 以下相關內容僅提供參考, 這裡不保證所提供的中英文內容, 絕對正確或完整, 使用者必須自行擔負各種可能衍生之風險與結果.

C 的介紹 -

http://en.wikiversity.org/wiki/Topic:C

http://www.eskimo.com/~scs/cclass/cclass.html

Learning GNU C

A TUTORIAL ON POINTERS AND ARRAYS IN C

C 程式語言的指標與陣列教學

pointers.pdf

作者: Ted Jensen

Version 0.1

This material is hereby placed in the public domain.
本教材謹置於公共領域

TABLE OF CONTENTS
目錄

Preface
前言

Introduction
簡介

Chapter 1: What is a Pointer?
第一章: 何謂指標?

Chapter 2: Pointer Types and Arrays.
第二章: 指標類別與陣列

Chapter 3:  Pointers and Strings
第三章: 指標與字串

Chapter 4:  More on Strings
第四章: 更多關於字串

Chapter 5:  Pointers and Structures
第五章: 指標與結構

Chapter 6:  More on Strings and Arrays of Strings
第六章: 更多關於字串與字串陣列

Chapter 7:  More on Multi-Dimensional Arrays
第七章: 更多關於多維陣列

Chapter 8:  Pointers to Arrays
第八章: 指向陣列的指標

Chapter 9:  Pointers and Dynamic Allocation of Memory
第九章: 指標與動態記憶配置

Chapter 10: Pointers to Functions
第十章: 指向函式的指標

Epilog
結語</t>
<t tx="amd_yen.20130406103207.2761">PREFACE
前言

本文件旨在向 C 程式語言的初學者介紹指標. 過去幾年, 無論是在 FidoNet 與 UseNet 有關 C 的會議場合, 特別注意到有許多 C 程式語言的初學者, 似乎對於指標的基本用法, 感到有些困難. 因此特別利用較多的範例, 希望以淺顯的說明來解釋指標的用法.

這份文件的第一版本, 如同此一版本, 是被放在公共領域. 當時是由 Bob Stout 將資料放在 PTR-HELP.TXT 的文件檔中, 並納入 SNIPPETS 的收集中加以發行. 之後, 又在原始資料中增添了許多內容並且修正了一些錯誤.

致謝

要感謝許多不為人知的使用者, 將許多問題公佈在 FidoNet 的 C Echo 論壇中,  或是 UseNet comp.lang.c 新聞群組中, 或是在其他網路上的幾個會議區,這些要感謝的人士可能無法一一列出. 其中特別要感謝 Bob Stout 肯將這份資料的第一版本放入他所收集的 SNIPPETS 檔案中.

關於作者:

Teb Jensen 是一位退休的電子工程師, 主要專注於電磁錄音領域中的硬體設計與管理職務. 程式則是自 1968 年以來閒暇時的興趣, 當時正學著如何以打卡的方式讓程式送給電腦主機執行. (那時的主機擁有 64 K 的磁心記憶體)

使用本資料:

這份資料以公共領域授權釋出. 任何人可以採用任何形式, 複製或散佈這份資料. 唯一的要求, 則是若這份資料被用於課程教學, 希望能夠完整呈現, 亦即, 包含所有章節, 包括前言與簡介. 

並且任課教師能夠利用下方的電子郵箱通知我一聲. 之所以如此要求, 主要是希望這份資料能夠對其他人有用, 況且我並不要求金錢回報. 只是希望能夠透過使用這份資料的用戶回饋, 多少確認一下這個目標能夠達成.

此外, 並非一定要是課程教學者可以寫信給我. 感謝任何覺得此份資料有用或提供建設性批評的任何人, 都能告訴我一聲, 我將會透過電子郵件回答相關問題.

Ted Jensen     tjensen@netcom.com
P.O. Box 324     1-415-365-8452
Redwood City, CA 94064
Dec. 1995</t>
<t tx="amd_yen.20130406103207.2762">INTRODUCTION
簡介

若您想要專精於利用 C 程式語言編寫程式碼, 就必須徹底了解如何使用指標. 然而, C 指標對初學者而言, 經常是一項障礙, 尤其對於從 Fortran, Pascal 或 Basic 程式語言轉進的學習者.

這份資料旨在幫助初學者了解指標. 為了能讓這份資料發揮最大功能, 使用者最好能夠實際執行文章中所列出的各個程式. 因此所有的程式碼都採 ANSI 標準, 以便讓任何符合 ANSI 標準的編譯器都能執行這些程式碼. 內文與程式碼之間, 也特別加以區分開來, 以便使用者可以直接利用複製的方式, 取的各段落的程式碼, 套用到其他系統中進行編譯. 如此才能確實了解這裡所提供的資料.</t>
<t tx="amd_yen.20130406103207.2763">Chapter 1: What is a Pointer?

第一章: 何謂指標?

C 語言初學者必須面對的難題之一, 就是指標的用法.

這份教材的目的, 就是針對初學者簡介指標及其應用.

其實初學者會對指標產生疑惑, 大多源自於在學習 C 語言時, 對於變數的概念經常一知半解.

因此這裡就由 C 變數的一般用法說起.

程式中的變數都必須加以命名, 以便存放數值.

而編譯器與連結器在處理變數時, 就會挪出電腦記憶體中的特定區域, 以存放變數的值

這些特定區域的大小, 取決於變數允許存放值的範圍.

例如, 在 32 位元電腦, 一個整數變數的存放範圍, 需要為 4 位元. 而在舊的 16 位元電腦, 整數存放需要 2 位元.

C 程式中的整數變數存放範圍大小, 在各種機器上不一定相同.

並且 C 程式中的整數變數也不只一種, 在許多 C 程式教科數中,可以發現有整數, 長整數, 短整數等. 這裡則假設使用 32 位元系統, 因此整數需要 4 位元的存放空間.

可以採用下列程式碼,在您所使用的系統中, 查探特定整數型別所需要的記憶體空間:

#include &lt;stdio.h&gt;

int main()
{
printf("size of a short is %d\n", sizeof(short));
printf("size of a int is %d\n", sizeof(int));
printf("size of a long is %d\n", sizeof(long));
}

當我們宣告一個變數時, 亦即告知編譯器兩件事, 變數名稱與變數型別. 例如, 可以透過

    int k; 

宣告名稱為 k 的整數型別變數. 當編譯器看到 "int" 的敘述值, 就會在電腦的記憶體中, 保留 4 位元的空間, 以便存放整數變數 k 的值.

此外, 電腦也會設置一個符號表, 註明符號 k 與其在記憶體中用來存放 4 位元資料的相對位址.

因此, 若在變數宣告後, 使用

    k = 2; 

2 這個數值, 就會在程式執行時, 被放在保留給 k 變數的記憶體位址中.

在 C 語言中, 整數 k 變數, 可視為一個物件. 其中有兩個值與物件 k 有關, 也就是存放的數值與存放的位址. 有些參考書中將者兩個數值稱為"右值"與"左值". (2 為右值, 而變數位址為左值)

在某些語言中, 左值只能放在指定"等號"的左邊, 而右值則只能放在右邊. 位置放錯, 例如: 2 = k, 就會出錯.

其實, C 語言中有關左值得定義, 根據 K&amp;R II (page 197): [1], 則有些變動.

"物件為儲存區域的名稱, 而左值則為指向該物件的表示式."

這裡先採引用的定義加以說明, 後續將會進一步針對指標加以說明.

接著, 假如程式碼為:

   int j, k; 

    k = 2; 
    j = 7;    &lt;-- line 1 
    k = j;    &lt;-- line 2 

編譯器會將第一行 (line 1) 的 j 解讀為變數 j 的位址 (也就是左值), 並且將值 7 放到該位址. 在第二行 (line 2), 則會將 j 視為右值 (因為在"指定"運算子的右方), 指的則是存放在 j 記憶體中的 7 這個數值. 因此第二行執行過後, 存放在 j 的 7 這個數值, 就會被放到 k 變數所對應的"左值" (記憶體位址) 中.

在這些範例中, 採用的都是將右值從一個儲存位址, 經由複製將 4 位元的資料複製到另外一個儲存位址. 假如使用 2 位元整數, 則會複製 2 位元資料.

這裡, 就會需要一種變數, 用來存放左值 (記憶體位址). 存放此一變數的值, 隨系統而異, 舊的桌上電腦總共只有 64K 的記憶體, 每存放一個整數位址會佔去 2 位元.

更多位元數的電腦 (例如 64 位元電腦), 則需要更多的位元位址來存放一個整數資料.

實際需要的記憶體大小並不重要, 需要的則是一種方法, 通知編譯器在哪一位址存放哪些資料.

這樣的變數稱為"指標變數" (隨後將說明得更清楚). 在 C 語言中定義指標變數時, 必須在變數名稱前方, 加上一個 * 符號. 而這些指標變數的型別, 隨著要存放在指標位址中的資料型別而定, 例如, 假如宣告:

   int *ptr;

ptr 為變數名稱 (與之前的整數變數名稱 k 相同). 而 "*" 符號則告知編譯器, 此一宣告為指標變數, 亦即保留出足夠的記憶體存放位址. 最前方的 int 則表示, 希望此一指標變數用來存放整數. 而此一指標稱為"指向整數". 需要特別注意的是, 當使用 int k; 時並沒有給 k 初始值, 只有在任何符合 ANSI 規範的編譯器中, 會將宣告在函式外的變數通通以 0 初始.

同樣地, ptr 也沒有初始值, 亦即, 還沒有在上述宣告之後, 在保留的位址空間上, 放入任何值. 這裡若宣告是在任何函式之外, 就會被賦予初值, 並且保證不會指向任何 C 物件或函式. 以這種方式初始的指標, 被稱為 "空"指標 (null pointer).

而空指標並不一定會被放入 "0" 值, 因為這取決於特定系統中的設定. 為了在不同系統中的不同編譯器彼此相容, 就會利用巨集 (macro) 來表示空指標. 此巨集以 NULL 命名. 因此, 若以 NULL 設定指標值, 則可以確定在不同機器上, 這些指標變數一定是空指標.

與整數是否為 0 的判斷式 if(k ==0) 相類似, 可以利用 if(ptr == NULL) 判斷是否 ptr 為空指標.

但是, 回到新變數 ptr 的應用, 假設要將整數變數 k 所對應的位址, 存入 ptr, 就必須使用"位址運算子", 寫成:

    ptr = &amp;k; 

"位址運算子"的作用是用來取 k 的左值 (位址), 即使這時 k 位於等號右邊, 上述程式會將 k 的值複製到指標 ptr 的儲存空間中. 這時, ptr 稱為"指向" k.

接著再討論另外一個運算子.

也就是所謂的"取值運算子" (dereferencing operator), 就是一個 * 符號. 使用方法如下:

    *ptr = 7; 

這行程式會將 7 這個數值,複製到 ptr 變數所指向的位址. 也就是說, 假如 ptr 指向 k (ptr 為 k 存放資料的記憶體位址), 這行程式就會將 k 的值設為 7. 換言之, * 運算子可用來改變 ptr 所指向的值, 而不是指標本身的值. (註:指標本身為位址, 也就是所謂的左變數)

因此, 可以利用:

 printf("%d\n",*ptr); 

將目前存放在 ptr 所指向位址的整數值, 給印到螢幕.

要釐清上述說明, 可以執行下列程式, 並仔細探討程式碼與其輸出.

------------ Program 1.1 --------------------------------- 

/* Program 1.1 from PTRTUT10.TXT   6/10/97 */

#include &lt;stdio.h&gt;

int j, k;
int *ptr;

int main(void)
{
    j = 1;
    k = 2;
    ptr = &amp;k;
    printf("\n");
    printf("j has the value %d and is stored at %p\n", j, (void *)&amp;j);
    printf("k has the value %d and is stored at %p\n", k, (void *)&amp;k);
    printf("ptr has the value %p and is stored at %p\n", ptr, (void *)&amp;ptr);
    printf("The value of the integer pointed to by ptr is %d\n", *ptr);

    return 0;
}

請注意: 我們還沒有談到 C 程式中的 (void *) 表示式. 這裡可以先納入您的測試程式碼中,  隨後將會加以說明.

結論:

    1. 變數宣告必須指定名稱與型別. (例如: int k;)
    2. 指標變數宣告也是指定名稱與型別. (例如: int *ptr;), 其中的 * 告知編譯器, 該名稱為 ptr 的變數, 為一個指標變數, 而其型別為該指標指向的資料型別 (這裡為整數).
    3.  一旦變數已經宣告, 可以透過變數前方的位址運算子, 取得其位址, 例如 &amp;k.
    4. 可以由指標中"取值", 亦即, 以 * 指定到指標所參照的值, 例如: *ptr.
    5. 變數的左值為被用來存放在記憶體中的位址值, 而變數的右值則式被存放在該位址的數值.

參考資料:

"The C Programming Language" 2nd Edition
B. Kernighan and D. Ritchie
Prentice Hall
ISBN 0-13-110362-8 </t>
<t tx="amd_yen.20130406103207.2764">Chapter 2: Pointer Types and Arrays.

第二章: 指標型別與陣列

接著讓我們來看看, 為何需要指定指標指向變數的型別, 例如:

int *ptr;

原因之一是, 宣告之後, 可以透過指向, 寫成:

*ptr = 2;

編譯器就會知道要配置多少記憶體給 ptr 變數, 假如 ptr 宣告為指向整數, 電腦就會複製 4 位元的資料, 其它的浮點與雙浮點變數也是相同. 定義指向變數型別的另外一個用途就是編譯器可以解譯程式碼. 例如, 記憶區中存放 10 個連續的整數資料時, 需要 40 位元的記憶體.

假如整數指標 ptr 為這些整數中的第一個變數, 若該整數位於記憶體位址 100. 當程式寫為:

ptr + 1;

因為編譯器知道 ptr 為一個指標變數 (亦即, 其值為一組位址)並且指向某一整數 (目前位址為 100, 即是該整數所在位址), 當 ptr 加上 4 而不是 1 之後, 該指標將會指向下一個整數, 也就是記憶體 104. 

相同的概念下, 若 ptr 指向短整數, 則應該加上 2  而不是 1. 對於浮點, 雙浮點或使用者自訂的資料型別 - 結構, 也是類似.

儘管這並非我們常見的"加法", 但是在 C 語言中, 可以透過指標算數進行"加法"運算, 隨後將會再予以說明.

同理, 因為 ++ptr 與 ptr++ 與 ptr + 1 等同 (儘管 ptr 增量的時機點並不一樣).

讓指標以 ++ 增量運算子進行增量, 無論是先加或後加, 由 sizeof(type) 中所得到的位址增量, 其型別均為該物件指向變數的型別 (整數為 4 位元).

由於這 10 個整數位於記憶體中連續區塊上, 指標可以被用於整數資料陣列的處理.

例如:

    int my_array[] = {1,23,17,4,-5,100}; 

陣列中帶有 6 個整數. 可以透過 my_array 的索引代表這些整數. 亦即利用 my_array[0] 到 my_array[5] 加以表示, 也可以透過指標加以表示成:

    int *ptr;
    
    ptr = &amp;my_array[0];       /* 將指標指向陣列中的第一個整數*/ 

接著就可以使用陣列索引或取值運算, 列出陣列.

下列程式可以用來展示此一應用:

-----------  Program 2.1  -----------------------------------

/* Program 2.1 from PTRTUT10.HTM   6/13/97 */

#include &lt;stdio.h&gt;

int my_array[] = {1,23,17,4,-5,100};

int *ptr;

int main(void)
{
    int i;
    ptr = &amp;my_array[0];     /* point our pointer to the first
                                      element of the array */
    printf("\n\n");
    for (i = 0; i &lt; 6; i++)
    {
      printf("my_array[%d] = %d   ",i,my_array[i]);   /*&lt;-- A */
      printf("ptr + %d = %d\n",i, *(ptr + i));        /*&lt;-- B */
    }
    return 0;
}

編譯執行上列程式就可以仔細觀察 A 行與 B 行程式分別採用兩種方法列出陣列中的同一內容.

也可以清楚看到 B 行程式如何應用"取值"運算, 亦即, 首先在指標增量後, 在新的指標中取值. 將 B 行程式改為

    printf("ptr + %d = %d\n",i, *ptr++);

之後再執行, 接著改為:

    printf("ptr + %d = %d\n",i, *(++ptr));

再執行, 執行之前先判定結果, 並與實際執行結果進行比較.

在 C 語言, 可以利用 var_name 來替代 &amp;var_name[0], 因此在程式碼中寫成:

    ptr = &amp;my_array[0];

或:

    ptr = my_array;

都會得到相同的結果.

因此許多參考書都寫道: 陣列的變數名稱就是指標. 但是比較好的想法則是: 陣列的變數名稱就是陣列中第一元件的位址. 許多初學者 (包含作者本人), 都會將其視為指標.

但是, 可以寫成:

ptr = my_array;

但是卻不能寫成:

my_array = ptr;

原因就是 ptr 為變數, 但是 my_array 卻是常數, 也就是說, my_array 第一元件的位址, 一旦在 my_array[] 完成宣告後, 就不可以改變.

先前曾討論的左值, 中引用 K&amp;R-2 中所言:

"物件為儲存區域的名稱, 而左值則為指向該物件的表示式."

這就衍生出一個有趣的議題. 因為 my_array 為儲存區域的代表名稱, 為何 my_array 在上面的指定敘述程式中, 卻不能用在左值區域?

為了說明這點, 可以將 my_array 視為"不可改變的左值".

上列範例可以將:

    ptr = &amp;my_array[0];

改為:

    ptr = my_array;

確認兩者會得到相同的結果.

至於 ptr 與 my_array 之間的差異, 有人將陣列變數名稱視為"常數指標".
為了充分了解所謂"常數"的真諦, 重回變數定義時的說明.

當變數宣告時, 用來存值的記憶體就必須加以配置. 這時變數可以透過兩個層面來看.

用在指定運算左邊時, 編譯器會視其為記憶位址, 用來指向右側所設定的值.

若被用在運算右邊時, 變數名稱會被解讀為存在該記憶體中的值.

有了以上的概念, 關注簡單的常數運算:

    int i, k;
    i = 2;

其中 i 為存放 2 常數的變數, 並非直接在資料記憶區塊中指定, 而是直接存入程式記憶區塊. 

當 k = i; 程式碼就會到 &amp;i 位址中抓取要複製到 k 的值, 而 i = 2; 只是將 2 放入程式碼, 而沒有取值的運作. 也就是說, k 與 i 都是物件, 但是 2 則非物件.

同理, 由於 my_array 為常數 (為位址值), 一旦編譯器設好用來存值得區域後, my_array[0] 存值得記憶體位址就已經確定, 因此可以使用:

    ptr = my_array;

將此在程式區段中的常數位址設給 ptr, 其中並沒有牽涉到資料區段的取值操作.

這時就可進一步說明第一章程式 1.1. 中 (void *) 的應用. 由於指標可被用來指向各種資料型別. 除了可以指向整數, 也可以指向字元, 之後還會介紹指向結構與指向指標的指標變數.

由於在不同系統中的指標儲值大小會有差別, 並且指標的記憶體空間會隨著指向物件資料型別差異而有所不同.

因此若將長整數指給短整數資料型別變數時, 就會發生問題, 也可以將某一型別的指標變數指定給其他不同型別指標變數時, 產生問題.

為了克服此一問題, C 語言提供 void 這個空的指標資料型別.

假如將某一指標設定為:

void *vptr;

空指標可以視為通用指標. 由於 C 語言不允許整數型別指標與字元型別指標之間的資料交換或比較. 這時就可以透過空指標作為中介, 在特殊情況下在指標型別間進行資料轉換.

在第一章的 1.1 程式中, 就是使用空指標將整數指標轉成能與 %p 資料相符的格式.

下列各章, 也將透過此一概念進行資料轉換.

這裡列出許多技術資料給初學者, 首次閱讀時或許不很容易理解. 因此需要前後執行幾次程式, 看看結果, 並且仔細查驗這兩個例子中的程式碼與產出結果, 才會有所突破.

接下來, 將討論指標, 字元陣列與字串間的關係.</t>
<t tx="amd_yen.20130406103207.2765">Chapter 3: Pointers and Strings

第三章: 指標與字串

字串的研究不僅對進一步理解指標與陣列的關聯有些幫助,也能用來彰顯某些標準 C 字串函數的使用. 最後也可以理解指標如何將資料傳給函式.

就 C 而言, 字串為字元所組成的陣列, 其他的語言則未必如此.
無論是 BASIC, Pascal 或是 Fortran 與其他幾種程式語言, 字串自有其資料類別.  C 則不然, 字串之於 C 被表為以 0 位元 (寫為'\0').

這裡要以幾行程式碼作為開端, 來加以說明, 如下:

    char my_string[40];

    my_string[0] = 'T';
    my_string[1] = 'e';
    my_string[2] = 'd':
    my_string[3] = '\0';

或許沒有人會用這種方法來建立字串, 以空字元作為結尾. 根據 C 語言的定義, 字串為一組以空字元結尾的字元陣列. 注意這裡的所謂空字元與 "NULL" 不同. 空字元表為以跳脫序 '\0' 表示的"零"字元. 亦即佔了記憶體中的一個位元, 而 NULL 則為用來起始空指標的巨組程式.

NULL 在 C 編譯器中, 以 #define 在標頭檔案中宣告, 而 nul 則完全無法以 #define 宣告.

由於用上述程式來宣告字串非常累人, 因此 C 允許以多種方法來完成一項工作.

首先, 可以寫成

    char my_string[40] = {'T', 'e', 'd', '\0',};    

但是光打字就有些不方便, 因此也可以寫成:

    char my_string[40] = "Ted";

若使用的是雙引號, 而不是先前的單引號, 空字元 ('\0') 會自動被加在字串最後面.

上面的例子, 結果都相同. 編譯器會保留連續的 40 位元區塊來存放 Ted\0 這四個字元.

接著看看下列程式:

------------------program 3.1-------------------------------------

/* Program 3.1 from PTRTUT10.HTM   6/13/97 */

#include &lt;stdio.h&gt;

char strA[80] = "A string to be used for demonstration purposes";
char strB[80];

int main(void)
{

    char *pA;     /* 字元型別的指標變數*/
    char *pB;     /* 另一個字元型別的指標變數 */
    puts(strA);   /* 顯示字串 A */
    pA = strA;    /* 將 pA 指向字串 A*/
    puts(pA);     /* 顯示 pA 指向的內容 */
    pB = strB;    /* 將 pB 指向字串 B */
    putchar('\n');       /* 在螢幕中向下移動一行 */
    while(*pA != '\0')   /* A 行 (詳見內文說明) */
    {
        *pB++ = *pA++;   /* B 行 (詳見內文說明) */
    }
    *pB = '\0';          /* C 行 (詳見內文說明) */
    puts(strB);          /* 將 strB 顯示在螢幕上 */
    return 0;
}

--------- end program 3.1 -------------------------------------

上述程式定義了兩個字元陣列, 各有 80 字元. 由於屬於全域變數, 一開始各字元都填入 '\0'. 然後, strA 前 42 個字元被放入所引用的字串內容.

接著的程式碼, 宣告兩個字元指標並將其字串顯示在螢幕. 將 pA 指標指向 strA, 也就是附註 strA[0] 的位址給變數 pA. 然後利用 puts() 函數顯示 pA 所指向的內容
 puts() 函式的宣告為:

    int puts(const char *s); 

現在先不用管 const, 傳給 puts() 函數的變數為指標. 其實是指標所對應的值. 而指標的值為其所指向的位址. 因此寫成 puts(strA), 表示輸入變數為 strA[0] 的位址.

同理, 當程式寫 puts(pA); 也是以相同的位址當作輸入, 因為已經透過

pA = strA;

將位址傳給 pA

因此程式執行到 while() 指令中的 A 行時, A 行內容為:

當 pA 所指向的字元並非 nul 字元時 (也就是'\0'), 執行其內容:

而 B 行程式則表示: 將 pA 指向的字元複製給 pB 所指向的字元, 接著增量 pA 後可以指向下一字元, 而 pB 則會指向下一個記憶體空間.

完成最後一個字元複製後, pA 會指向空字元, 也會終止迴圈的執行.

其中空字元並沒有複製, 但由於 C 中的字串一定要以空字元結尾, 所以在 C 行程式中再補上空字元.

執行此一程式時, 當使用者透過除錯器看著 strA, strB, pA 與 pB 一步步執行, 將非常具有教育意義.

It is even more educational if instead of simply defining strB[] as has been done above, initialize it also with something like:

更有意思的是, 若不將 strB[] 按上述方法定義時, 而是將其起始值設為:

    strB[80] = 
"12345678901234567890123456789012345678901234567890"

讓其數字個數大於 strA  的長度, 然後一步步看著這些變數設定數值. 大家一定得親自做做看.

接著再回到 puts() 的原型, 運用 "const" 作為某一參數的宣告飾詞時, 主要在告訴使用者, 該函式無法改變其由 s 所指向的字串值, 意即, 程式會將該字串視為常數.

誠然, 上述程式展示了複製字串的一種簡單方式. 一旦確實了解上述程式的用法, 接著將自行編寫可以取代標準 strcpy() 的 C 標準函式, 程式如下:

   char *my_strcpy(char *destination, char *source)
   {
       char *p = destination;
       while (*source != '\0')
       {
           *p++ = *source++;
       }
       *p = '\0';
       return destination;
   }   

在此一程式中, 同樣運用了指標的傳值.

承上述內容, 若將函式寫成可以接受兩個字元指標變數輸入, 也就是位址, 就可以將上述程式改寫為:

    int main(void)
    {
        my_strcpy(strB, strA);
        puts(strB);
    }    

雖然與標準 C 的用法有些不同, 採用了下列原型定義:

    char *my_strcpy(char *destination, const char *source);  

之所以使用 "const" 飾詞, 主要在確定該函式無法變更指向來源指標的數值. 此點可從上述函式的修改得到印證, 其原型變數, 如 "const" 飾詞所示. 接著在函式中, 增加一行試圖更改該變數由來源指標所指向的值, 意即:

    *source = 'X';

試著將該字串的第一個字元, 變更為 X. 前面的 const 飾詞就會讓這一行程式產生錯誤, 執行完後就會更加清楚有關 const 變數的使用.

接著, 繼續探討上述程式的內涵, 第一步, 將 *ptr++ 解讀為由 ptr 指標傳回值後的增量. 主要與運算子的次序有關. 假如寫成 (*ptr)++, 表示增量的部分,  並非指標, 而是該指標所指向值的增量. 也就是說, 在上述程式中, 若對第一個字元 'T' 增量, 其值就會變成 'U'. 使用者可以自行寫程式來印證此一結果.

由於字串只不過就是字元所組合而成的陣列, 並在最後一個字元補上 '\0'.  上面所進行的是用來複製陣列. 這些字元陣列的運算技巧, 也可以應用到整數陣列或浮點數陣列. 但是在這些應用中, 陣列的尾端, 並不會補上 nul 字元, 而可以放進某特定值的內容, 來表示其為終點. 例如, 可以在複製正整數時, 在尾數放入一個負值的整數來標示終點. 或者, 寫一個函式, 可以複製字串以外的陣列及其陣列位址, 就如同下列原型所示:

    void int_copy(int *ptrA, int *ptrB, int nbr);

其中 nbr 為要進行複製的整數值. 試著寫一個可以用來複製整數陣列的 int_copy() 函式, 看看是否能夠正常運作.

如此, 就可以使用函式來處理大陣列. 例如, 有一帶有 5000 個整數的陣列需要處理, 只要將該陣列的位址輸入該函式 (視情形,  可以加上其他相關變數, 如上述程式中的 nbr 變數), 而不需要輸入陣列本身, 意即, 整個陣列值並沒有在堆疊中複製後進行輸入的動作, 而只送出其位址.

此一過程與輸入某一整數給某一函式不同. 輸入整數時, 必須複製該整數, 也就是取得該整數的值, 然後放入某一堆疊當中. 這時, 該函式的處理並不影響原始的整數值, 而若以陣列及指標進行處理, 可以將變數位址輸入, 直接處理原始變數的值.</t>
<t tx="amd_yen.20130406103207.2766">Chapter 4: More on Strings

第四章: 更多關於字串的用法

好的, 在短短的時間裏, 已經介紹了不少東西! 接著再看一次第三章中有關字串複製的部分, 但是採不同的方法. 以下列函式來看:

    char *my_strcpy(char dest[], char source[])
    {
        int i = 0;
        while (source[i] != '\0')
        {
            dest[i] = source[i];
            i++;
        }
        dest[i] = '\0';
        return dest;
    }

之前曾說過, 字串就是字元所組成的陣列. 這裡我們利用陣列表示而非指標表示, 來進行資料的實質複製. 結果會與之前相同, 亦即, 採此一方法的字串複製, 其結果依然正確. 這也衍生出接下來要討論的有趣論點.

由於變數透過值進行傳遞, 可經由前述之字元指標或陣列名稱進行, 其間真正傳遞的則是每一陣列中第一個元素的位址. 亦即, 變數數值的傳遞, 可透過字元指標或陣列名稱來代表此一變數. 也可以說, source[i] 其實與 *(p+i) 的用法一樣.

事實上, 這是正確的, 亦即 a[i] 可以利用 *(a+i) 來替代, 而不會產生任何問題. 換言之, 編譯器針對這兩種情形, 會產生相同的編碼. 因此, 指標算術其實與陣列索引編碼相同. 兩種語法會產生相同結果.

但是這並非說, 指標與陣列是相同的東西, 其實不然. 這裡只是說, 利用陣列來進行特定元素辨識, 可以採用兩種不同的語法, 其一為採用陣列索引, 而另一種方法則是利用指標算術, 會得到相同的結果.

接著, 注意最後的表示式, (a+i) 的部分利用簡單的加號 + 與 C 的語法, 表示式子可以交換, 亦即 (a+i) 與 (i+a) 完全相同. 因此可以將 *(i+a) 簡化為 *(a+i).

但是 *(i+a) 可能來自 i[a]! 綜合上述, 或許會懷疑若:

    char a[20];
    int i;

寫成

    a[3] = 'x';

其實與下列表示式, 其實是一樣的.

    3[a] = 'x';

試試看! 設定一個字元陣列, 內存為整數或長整數等. 對其第三或第四元素, 以傳統方式, 給定特殊值, 接著將值印出加以確認. 然後如前述, 將陣列表示式反轉過來, 一個好編譯器將會毫無疑問的給出相同的結果, 僅只出於好奇, 別無其他用意.

程式範例:

#include &lt;stdio.h&gt;

// 每一個 C 程式都必須要有一個小寫的 main()函式
int main()
{
    // 陣列與指標的應用
    char a[20];
    int i;
    a[3] = 'x';
    printf("%c\n",a[3]);
    printf("%c\n",3[a]);
    printf("%c\n",*(a+3));
    printf("%c\n",*(3+a));
    return 0;
}

接著, 來看前面給的函數, 寫成:

    dest[i] = source[i];

由於已知陣列索引與指標算術會得到相同的結果, 因此也可以寫成:

    *(dest + i) = *(source + i);

但是, 需要對每一個值分別加上 i. 加法, 一般而言, 會比索引增量 (例如採用 ++ 運算符號的 i++) 耗費更多時間. 或許對現在最佳化的編譯器來說, 不一定就是如此, 但是採用指標通常比陣列索引來得快些.

另一個可以加速指標運算的方法, 將:

    while (*source != '\0')

簡化為

    while (*source)

兩種情形都會讓括號中為零 (FALSE).

這裡可實驗看看, 以指標的方法來寫程式. 用來處理字串應該不錯. 可以將下列標準函式改寫成自己的版本:

    strlen();
    strcat();
    strchr();

或者其他在系統中的函式.

接下來的章節, 還會再探討字串及其處理. 接下來先討論一下 structures (結構).</t>
<t tx="amd_yen.20130406103207.2767">Chapter 5: Pointers and Structures

第五章: 指標與結構

也許你已經知道, 可以利用結構的形式來宣告帶有不同資料型別的資料區塊. 例如, 人事檔案可能包含下列結構:

    struct tag {
        char lname[20];        /* 姓 */
        char fname[20];        /* 名 */
        int age;               /* 年齡 */
        float rate;            /* 例如: 每小時 100 元 */
    };
假如在磁片檔案中有許多這樣的資料, 當我們需要一筆筆讀出, 並且分別列出姓名, 以做成資料表格. 其他資料並不需要印出. 具體做法, 可以利用函式呼叫, 透過指向結構的指標作為輸入, 就可以完成處理. 這裡只利用一個結構進行示範, 並且主要在編寫函式, 而非讀檔. 這裡已經假設您知道如何進行讀檔.

複習一下, 我們可以利用點運算子來擷取結構成員, 正如:

--------------- 程式 5.1 ------------------
/* 程式 5.1 from PTRTUT10.HTM     6/13/97 */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
struct tag {
    char lname[20];      /* 姓 */
    char fname[20];      /* 名 */
    int age;             /* 年齡 */
    float rate;          /* 例如: 每小時 100 元 */
};
struct tag my_struct;       /* 宣告 my_struct　結構 */
int main(void)
{
    strcpy(my_struct.lname,"Jensen");
    strcpy(my_struct.fname,"Ted");
    printf("\n%s ",my_struct.fname);
    printf("%s\n",my_struct.lname);
    return 0;
}
-------------- 結束程式 5.1 --------------
或許這裏所使用的結構與一般 C 程式所使用的相比還要小, 為了驗證也可以加入:

    date_of_hire;                  (未顯示資料型別)
    date_of_last_raise;
    last_percent_increase;
    emergency_phone;
    medical_plan;
    Social_S_Nbr;
    等等.....
    
假如員工的數量眾多, 應該會採用函式進行資料處理. 例如, 將結構輸入該函式, 就能利用函式印出員工姓名. 但是在最原始的 C (Kernighan &amp; Ritchie, 第一版), 無法輸入結構, 只能輸入指向結構的指標. 在 ANSI C 中, 已經允許利用結構作為函式輸入. 而這裡為了進行更多有關指標的學習, 並不直接採用結構.

總之, 假如輸入整個結構, 就如同必須在函式呼叫時複製結構內容, 在仍然使用堆疊的系統中, 就等同將整個結構資料送入堆疊中. 針對大型結構時,  可能就會造成問題. 若能只輸入指標, 就可使用最少的堆疊空間.

因此這裡主要在談指標, 因此接著來看如何將指向結構的指標變數輸入函式當中.

以上面的情況為例, 建立一個能夠接受指標變數 (指向結構) 的函式, 其中我們只想要擷取該結構的部分成員. 例如, 只要印出範例結構中的人員姓名.

好, 先前我們已經知道如何宣告指向結構的指標變數 tag. 接著就可以利用 tag 結構, 來宣告指標變數:

    struct tag *st_ptr;
    
並且可以用來指向範例中的結構:

    st_ptr = &amp;my_struct;
    
接下來, 可以利用指標的分割參照, 來指定特定成員. 但是應該如何利用指標的分割參照來指向結構? 假如要利用指標來設定人員的年紀, 可以寫成:

    (*st_ptr).age = 63;
    
仔細看清楚. 此一設定表示, 若將括號中 st_ptr 所指向的內容換成 my_struct, 就會與my_struct.age 相同.

但是, 這樣經常會被用到的表示式, 就被設定為與下列表示式涵義相同:

    st_ptr-&gt;age = 63;
    
了解了之後, 參考下列程式:

------------ 程式 5.2 ---------------------
/* 程式 5.2 from PTRTUT10.HTM   6/13/97 */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
struct tag{                     /* 結構型別 */
    char lname[20];             /* 姓 */
    char fname[20];             /* 名 */
    int age;                    /* 年齡 */
    float rate;                 /* 例如: 每小時 100 元 */
};
struct tag my_struct;           /* 結構定義 */
void show_name(struct tag *p);  /* 函式原型 */
int main(void)
{
    struct tag *st_ptr;         /* 指向結構的指標變數 */
    st_ptr = &amp;my_struct;        /* 將指標指向 my_struct */
    strcpy(my_struct.lname,"Jensen");
    strcpy(my_struct.fname,"Ted");
    printf("\n%s ",my_struct.fname);
    printf("%s\n",my_struct.lname);
    my_struct.age = 63;
    show_name(st_ptr);          /* 輸入該指標 */
    return 0;
}
void show_name(struct tag *p)
{
    printf("\n%s ", p-&gt;fname);  /* p 指向結構 */
    printf("%s ", p-&gt;lname);
    printf("%d\n", p-&gt;age);
}
-------------------- 結束程式 5.2 ----------------
這裡要了解不少東西. 讀者必須實際執行一下上面的程式, 並且利用除錯器一步步觀察  my_struct 與 p 在主函式執行流程中, 才能實際了解函式執行的內容.</t>
<t tx="amd_yen.20130406103207.2768">趨勢發展:

Python 與 CUDA

http://mathema.tician.de/software/pycuda</t>
<t tx="amd_yen.20130408141041.1765">之前使用的 pybean 為 0.1.2, 採用 uuid 作為 id, 但是到了 0.2.1 作者放棄 uuid, 改用一般的 id, 而且截至 2013.04 pybean 仍以 Python 2 為主, 必須修改 .next() 為 next() 才可以在 Python 3 環境中正確執行.

將 pybean 0.1.2 轉為 pybean 0.2.1 必須針對程式修改, 將 uuid.bytes 改為 id

修改後的 0.2.1 pybean.py 程式碼如下:

#coding: utf-8
import sqlite3
from pkg_resources import parse_version

__version__ = "0.2.1"
__author__ = "Mickael Desfrenes"
__email__ = "desfrenes@gmail.com"

# Yen 2013.04.08, 將 Python2 的 .next() 改為 next(), 以便在 Python 3 中使用

class SQLiteWriter(object):

    """
    In frozen mode (the default), the writer will not alter db schema.
    Just add frozen=False to enable column creation (or just add False
    as second parameter):

    query_writer = SQLiteWriter(":memory:", False)
    """
    def __init__(self, db_path=":memory:", frozen=True):
        self.db = sqlite3.connect(db_path)
        self.db.isolation_level = None
        self.db.row_factory = sqlite3.Row
        self.frozen = frozen
        self.cursor = self.db.cursor()
        self.cursor.execute("PRAGMA foreign_keys=ON;")
        self.cursor.execute('PRAGMA encoding = "UTF-8";')
        self.cursor.execute('BEGIN;')
    def __del__(self):
        self.db.close()

    def replace(self, bean):
        keys = []
        values = []
        write_operation = "replace"
        if "id" not in bean.__dict__:
            write_operation = "insert"
            keys.append("id")
            values.append(None)
        self.__create_table(bean.__class__.__name__)
        columns = self.__get_columns(bean.__class__.__name__)
        for key in bean.__dict__:
            keys.append(key)
            if key not in columns:
                self.__create_column(bean.__class__.__name__, key,
                        type(bean.__dict__[key]))
            values.append(bean.__dict__[key])
        sql  = write_operation + " into " + bean.__class__.__name__ + "("
        sql += ",".join(keys) + ") values (" 
        sql += ",".join(["?" for i in keys])  +  ")"
        self.cursor.execute(sql, values)
        if write_operation == "insert":
            bean.id = self.cursor.lastrowid
        return bean.id

    def __create_column(self, table, column, sqltype):
        if self.frozen:
            return
        if sqltype in [float, int, bool]:
            sqltype = "NUMERIC"
        else:
            sqltype = "TEXT"
        sql = "alter table " + table + " add " + column + " " + sqltype    
        self.cursor.execute(sql)

    def __get_columns(self, table):
        columns = []
        if self.frozen:
            return columns
        self.cursor.execute("PRAGMA table_info(" + table  + ")")
        for row in self.cursor:
            columns.append(row["name"])
        return columns

    def __create_table(self, table):
        if self.frozen:
            return
        sql = "create table if not exists " + table + "(id INTEGER PRIMARY KEY AUTOINCREMENT)"
        self.cursor.execute(sql)

    def get_rows(self, table_name, sql = "1", replace = None):
        if replace is None : replace = []
        self.__create_table(table_name)
        sql = "SELECT * FROM " + table_name + " WHERE " + sql
        try:
            self.cursor.execute(sql, replace)
            for row in self.cursor:
                yield row
        except sqlite3.OperationalError:
            return
   
    def get_count(self, table_name, sql="1", replace = None):
        if replace is None : replace = []
        self.__create_table(table_name)
        sql = "SELECT count(*) AS cnt FROM " + table_name + " WHERE " + sql
        try:
            self.cursor.execute(sql, replace)
        except sqlite3.OperationalError:
            return 0
        for row in self.cursor:
            return row["cnt"]

    def delete(self, bean):
        self.__create_table(bean.__class__.__name__)
        sql = "delete from " + bean.__class__.__name__ + " where id=?"
        self.cursor.execute(sql,[bean.id])
    
    def link(self, bean_a, bean_b):
        self.replace(bean_a)
        self.replace(bean_b)
        table_a = bean_a.__class__.__name__
        table_b = bean_b.__class__.__name__
        assoc_table = self.__create_assoc_table(table_a, table_b)
        sql = "replace into " + assoc_table + "(" + table_a + "_id," + table_b
        sql += "_id) values(?,?)"
        self.cursor.execute(sql,
                [bean_a.id, bean_b.id])
    
    def unlink(self, bean_a, bean_b):
        table_a = bean_a.__class__.__name__
        table_b = bean_b.__class__.__name__
        assoc_table = self.__create_assoc_table(table_a, table_b)
        sql = "delete from " + assoc_table + " where " + table_a
        sql += "_id=? and " + table_b + "_id=?"
        self.cursor.execute(sql,
                [bean_a.id, bean_b.id])
    
    def get_linked_rows(self, bean, table_name):
        bean_table = bean.__class__.__name__
        assoc_table = self.__create_assoc_table(bean_table, table_name)
        sql = "select t.* from " + table_name + " t inner join " + assoc_table 
        sql += " a on a." + table_name + "_id = t.id where a."
        sql += bean_table + "_id=?"
        self.cursor.execute(sql,[bean.id])
        for row in self.cursor:
            yield row

    def __create_assoc_table(self, table_a, table_b):
        assoc_table = "_".join(sorted([table_a, table_b]))
        if not self.frozen:
            sql = "create table if not exists " + assoc_table + "("
            sql+= table_a + "_id NOT NULL REFERENCES " + table_a + "(id) ON DELETE cascade,"
            sql+= table_b + "_id NOT NULL REFERENCES " + table_b + "(id) ON DELETE cascade,"
            sql+= " PRIMARY KEY (" + table_a + "_id," + table_b + "_id));"
            self.cursor.execute(sql)
            # no real support for foreign keys until sqlite3 v3.6.19
            # so here's the hack
            if cmp(parse_version(sqlite3.sqlite_version),parse_version("3.6.19")) &lt; 0:
                sql = "create trigger if not exists fk_" + table_a + "_" + assoc_table
                sql+= " before delete on " + table_a
                sql+= " for each row begin delete from " + assoc_table + " where " + table_a + "_id = OLD.id;end;"
                self.cursor.execute(sql)
                sql = "create trigger if not exists fk_" + table_b + "_" + assoc_table
                sql+= " before delete on " + table_b
                sql+= " for each row begin delete from " + assoc_table + " where " + table_b + "_id = OLD.id;end;"
                self.cursor.execute(sql)
        return assoc_table

    def delete_all(self, table_name, sql = "1", replace = None):
        if replace is None : replace = []
        self.__create_table(table_name)
        sql = "DELETE FROM " + table_name + " WHERE " + sql
        try:
            self.cursor.execute(sql, replace)
            return True
        except sqlite3.OperationalError:
            return False

    def commit(self):
        self.db.commit()



class Store(object):
    """
    A SQL writer should be passed to the constructor:

    beans_save = Store(SQLiteWriter(":memory"), frozen=False)
    """
    def __init__(self, SQLWriter):
        self.writer = SQLWriter 
    
    def new(self, table_name):
        new_object = type(table_name,(object,),{})()
        return new_object

    def save(self, bean):
        self.writer.replace(bean)
    
    def load(self, table_name, id):
        for row in self.writer.get_rows(table_name, "id=?", [id]):
            return self.row_to_object(table_name, row)

    def count(self, table_name, sql = "1", replace=None):
        return self.writer.get_count(table_name, sql, replace if replace is not None else [])

    def find(self, table_name, sql = "1", replace=None):
        for row in self.writer.get_rows(table_name, sql, replace if replace is not None else []):
            yield self.row_to_object(table_name, row)

    def find_one(self, table_name, sql = "1", replace=None):
        try:
            return next(self.find(table_name, sql, replace))
        except StopIteration:
            return None

    def delete(self, bean):
        self.writer.delete(bean)
    
    def link(self, bean_a, bean_b):
        self.writer.link(bean_a, bean_b)
    
    def unlink(self, bean_a, bean_b):
        self.writer.unlink(bean_a, bean_b)
    
    def get_linked(self, bean, table_name):
        for row in self.writer.get_linked_rows(bean, table_name):
            yield self.row_to_object(table_name, row)

    def delete_all(self, table_name, sql = "1", replace=None):
        return self.writer.delete_all(table_name, sql, replace if replace is not None else [])

    def row_to_object(self, table_name, row):
        new_object = type(table_name,(object,),{})()
        for key in row.keys():
            new_object.__dict__[key] = row[key]
        return new_object

    def commit(self):
        self.writer.commit()
</t>
<t tx="amd_yen.20130409162552.1785">為了推廣 Leo 編輯器的使用, 將要先設法打造一套可以在 Win32 環境中使用的基本 Leo 編輯器可攜套件, 步驟如下:

1. 從 http://www.python.org/download/ 下載 Python 3.3.1, 安裝時 Doc 與 test scripts 不安裝, 容量大約 26 MB.

2. 接著從 http://www.lfd.uci.edu/~gohlke/pythonlibs/#distribute 下載 distribute-0.6.36.win32-py3.3.‌exe, 安裝後約佔 30MB.

3. 接著從 http://www.lfd.uci.edu/~gohlke/pythonlibs/#pip 下載 pip-1.3.1.win32-py3.3.‌exe, 安裝後約佔 32MB.

4. 接著從 http://sourceforge.net/projects/pywin32/files/pywin32/Build%20218/ 下載 pywin32-218.win32-py3.3.exe, 安裝後約佔 58MB.

5. 接著從 http://www.riverbankcomputing.com/software/pyqt/download 下載 PyQt4-4.10-gpl-Py3.3-Qt5.0.1-x32-2.exe, Doc 與 Examples 不安裝, 安裝後約佔 166MB.

註: 因為安裝 PyQt4/Qt5 必須要從 http://www.microsoft.com/en-us/download/search.aspx?q=directx 更新 directx, 對於沒有更新的電腦就無法讓 Leo Editor 擷取到最新的 directx dll, 因為這不是 Leo 編輯器的問題, 而是 PyQt4 連結 Qt5 dll 所造成的問題, 目前還不知道 PyQt5 是否可以在未更新 directx 的情況下讓 2014 年即將退役的 Windows XP 正常使用 Qt5 的 dll, 因此依賴 PyQt 的 Leo Editor 根本無法主動修改, 只有兩條路可以走, 就是在 PyQt4 配合 Qt5  的情況下, 更新 Windows 的 directx, 或者是回到 PyQt4 與 Qt4 的搭配, 等待 PyQt5 與 Qt5 的版本到來, 然後再看是否能在未更新 dirextx 或更新 directx 的操作系統中彼此相容.

這裡我們選擇在 PyQt4/Qt4 的模式下來啟動 Leo 編輯器, 也就從  http://www.riverbankcomputing.com/software/pyqt/download 下載 PyQt4-4.10-gpl-Py3.3-Qt4.8.4-x32.exe, 而非 PyQt4-4.10-gpl-Py3.3-Qt5.0.1-x32-2.exe.

6. 接著從 http://www.lfd.uci.edu/~gohlke/pythonlibs/#docutils 下載 docutils-0.10.win32-py3.3.‌exe, 安裝後約佔 172MB.

7. 接著從 http://www.greygreen.org/leo/ 下載 leo-editor-snapshot-20130408.zip, 解開後將 leo 目錄放到 C:\Python33\Lib\site-packages\, 整個 C:\Python33 約為 190MB.

 安裝至此, 雖然 Leo Editor 已經可以在單機啟動, 但是我們卻希望將 Leo 編輯器放到隨身碟上工作, 因此將 C:\Python33 整個目錄複製到 C:\leoeditor\data\ 目錄中, 然後將上面 7 個步驟的安裝, 利用系統移除程式進行反安裝, 最後當然就是刪除 C:\Python33.

接下來, 希望除了 Leo 編輯器外, 還要有一個可以解譯 Python3 與簡單 C 程式的搭配用文字編輯器, 可以從 http://www.scintilla.org/SciTEDownload.html 下載 http://prdownloads.sourceforge.net/scintilla/wscite330.zip?download, 解開後將 wscite 目錄, 放入 C:\leoeditor\data 目錄中.

接下來, 則從 http://download.savannah.gnu.org/releases/tinycc/ 下載 tcc-0.9.26-win32-bin.zip, 解開後將 tcc 目錄,  放入 C:\leoeditor\data 目錄中.

截至目前, 我們在 C:\leoeditor\data 目錄中共有 Python33, wsite 與 tcc 等三個目錄, Python33 是從正式安裝 C:\Python33 複製得來, wscite 目錄則將用來編輯文件或解譯 Python3 與 C 程式, 而 tcc 目錄中則有完整的 TinyC 0.9.26 版本程式, 接下來則是要讓此一 Leo Editor 能夠正常啟動的設定工作, 而這些設定所需要的檔案, 可以利用 wscite 目錄中的 SciTE.exe 編輯取得.

以下則為此一可攜 Leo Editor 系統的設定步驟:

1. 開啟 wcite/SciTE.exe, 選擇 Options-&gt;Open Global Options File, 找到 code.page=0, 然後改為 code.page=65001, 表示要將原先設為系統編碼 (在 Windows XP 中為 Big-5) 改為 65001 編碼, 也就是改為 UTF-8 編碼, 另外再新增一個 output.code.page=0 設定, 表示輸出編碼則選用系統編碼.

2. 接著選擇 Options-&gt;Open cpp.properties 檔案, 將 C 程式的編譯指定給 tcc 處理:
#ccopts=-pedantic -Os
cc=y:/tcc/tcc.exe -run
ccc=y:/tcc/tcc.exe -run
command.go.*.c=$(cc) $(FileNameExt)
#command.go.*.c=./$(FileName)
 
修改之後, 就可以直接在 SciTE 中編輯一個 .c 的小程式, 然後選擇 Tools-&gt;Go 就可以在輸出區看到執行結果.
 
3. 接著選擇 Options-&gt;Open python.properties 檔案, 將 Python 程式的解譯指定給 y:\Python33\pythonw.exe 處理:
 
if PLAT_WIN
command.go.*.py=y:\Python33\pythonw -u "$(FileNameExt)"
 
修改之後, 就可以編輯一個 .py 程式, 然後選擇 Tools-&gt;Go 執行.

4. 接著再編輯 start.bat, stop.bat 與 README.md 等三個檔案, 內容如下:

start.bat 內容:
@echo off
REM 設定 y 硬碟代號與 data 目錄對應
set Disk=y
subst %Disk%: "data"
REM 將後續的指令執行, 以 %Disk% 為主
%Disk%:
REM 設定 PYTHONPATH
set PYTHONPATH=%Disk%:\Python33
REM 設定 Leo 所用的編輯器
set LEO_EDITOR=%Disk%:\wscite\SciTE.exe
REM 指令搜尋路徑設定
set path1=%PATH%;%Disk%:\commands;%Disk%:\Python33;%Disk%:\Python33\Lib\site-packages\;
set path2=%Disk%:\Python33\Lib\site-packages\pywin32_system32;%Disk%:\Python33\Scripts;
path=%path1%;%path2%
REM 啟動 SciTE 編輯器
start %Disk%:\wscite\SciTE.exe
REM 以最小畫面開啟兩個指令視窗備用
start cmd.exe /MIN
start cmd.exe /MIN
REM 啟動 Leo 編輯器
%Disk%:\Python33\python.exe %Disk%:\commands\launchLeo.py
EXIT
 
stop.bat 內容:
 
@echo off
set Disk=y
REM 關閉 python
taskkill /IM python.exe /F
path=%PATH%;
subst %Disk%: /D
REM 關閉 cmd 指令視窗
taskkill /IM cmd.exe /F
EXIT
 
README.md 內容:
 
portable leoeditor
===================
 
Portable Leo Editor for win32 system.
 
Files structure:
 
Directories:
 
data/wsite - SciTE editor
data/Python33 - Python 3.3.1 interpreter
data/tcc - TinyC compiler
data/commands - all the commands
data/examples - example files
README.md
start.bat
stop.bat
 
5. 最後, 啟動 start.bat, 就可以自動開啟 SciTE 與 Leo Editor, 開始進入 Leo 編輯器的探索之旅, 關閉系統則執行 stop.bat.
 
6. 下載可攜 Leo Editor - 共有兩個檔案: portable_leoeditor_20130409.7z.001 與 portable_leoeditor_20130409.7z.002, 在 Windows 環境下, 利用 7zip 解開後就可以執行.
 
https://sites.google.com/a/mde.tw/service/public/portable_leoeditor_20130409.7z.001?attredirects=0&amp;d=1
 
https://sites.google.com/a/mde.tw/service/public/portable_leoeditor_20130409.7z.002?attredirects=0&amp;d=1
</t>
<t tx="amd_yen.20130409162552.1786">1. 下載可攜 Leo Editor - 共有兩個檔案: portable_leoeditor_20130409.7z.001 與 portable_leoeditor_20130409.7z.002, 在 Windows 環境下, 利用 7zip 解開後就可以執行.

https://sites.google.com/a/mde.tw/service/public/portable_leoeditor_20130409.7z.001?attredirects=0&amp;d=1

https://sites.google.com/a/mde.tw/service/public/portable_leoeditor_20130409.7z.002?attredirects=0&amp;d=1

2. 假如您不想要使用上述的可攜版本, 可以參考 http://main.kmol.info/?Python_Leo_editor 中的說明, 自行打造, 在建立此一可攜 Leo Editor 系統的同時, 有一個重要的 PyQt 設定步驟, 先前忘了說明, 也就是 leoeditor\data\Python33 目錄下的 qt.conf 設定檔案, 內容必須與可攜系統中的 Python33 搭配, 也就是必須改為:

[Paths]
Prefix = y:/Python33/Lib/site-packages/PyQt4
Binaries = y:/Python33/Lib/site-packages/PyQt4

其中指定了 PyQt4 的安裝目錄, 假如沒能正確設定, Leo Editor 開啟後, 特定的小圖像將會無法顯示.

3. 當使用者執行 start.bat 後, 系統會將 leoeditor 目錄中的 data 目錄與 Y: 硬碟對應, Y:\ 硬碟中的檔案其實就是 leoeditor/data 目錄, 兩個目錄為同步對應.

假設將上述兩個壓縮檔案下載後, 直接解開到 C:\Documents and Settings\amd\My Documents\Downloads\leoeditor, 然後就可以點擊其中的 start.bat, 將會分別開啟兩個 cmd.exe 視窗, SciTE 編輯器與 Leo Editor, 這時進入 Y: 硬碟, 就可以看到 commands, exammples, Python33, tcc 與 wscite 等五個目錄, 其中 Python33 為可攜的 Python 3.3.1, tcc 為 TinyC 編譯程式, scite 則為 SciTE 編輯器.

啟動 Leo Editor 後, 使用者可以利用 http://leoeditor.com/ 中的說明, 逐步了解如何使用 Leo 編輯器, 以下為幾個使用上的關鍵點:

1. Leo Editor 的啟動設定分為系統設定與使用者設定, 系統設定可以從下拉式功能表 Help-&gt;Open leoSettings.leo 中開啟看到內容, 其中最重要的設定之一就是畫面相關字型大小的設定, 也就是標題為 @data qt-gui-plugin-style-sheet 的內容設定.

由於 Leo Editor 是一個大綱編輯器, 當使用者利用下拉式功能表 File-&gt;New 一個檔案後, 視窗正中央會出現三個不同顏色的視窗, 淺黃色的視窗稱為大綱標題視窗, 淡綠色則為 Log 視窗, 而淡紅色的則為與大綱標題對應的內容視窗, 新開一個大綱檔案後, 會有一個 NewHeadline 的標題 (稱為 outline head), 而其對應內容區 (稱為 outline body) 則為空內容.

當使用者從 Help-&gt;Open leoSettings.leo 開啟系統設定後, 可以利用 ctrl+f 啟動螢幕下方淡藍色的 Minibuffer 區, 當使用者利用 ctrl 按鍵加上 f 表示要輸入搜尋關鍵字, Minibuffer 區就會自動出現 Search, 並且等待使用者輸入關鍵字, 這時若在 Search: 之後輸入 style-sheet, 然後按下 Enter,  Leo Editor 就會自動停留到標題為 @data qt-gui-plugin-style-sheet 的節點 (稱為 node), 而 @data qt-gui-plugin-style-sheet 標題節點的內容就視用來設定 Leo Editor 的各項顯示, 其中包括目前畫面各區域的字元大小設定.

QTreeWidget 設定為節點標題字型設定, QTextEdit 為 log 區字型設定, QTextEdit#richTextEdit 則為節點內文字型設定, QLabel 則為 Minibuffer 區的字型設定.

一勞永逸的做法可以將 leoSettings.leo 中 @data qt-gui-plugin-style-sheet 節點內容 12px 全部改為 18px, 重新開啟 Leo Editor 後, 就會依照新的設定顯示, 但是在 Leo 4.11 20130408 版本使用的結果顯示, 若隨後開啟的 .leo  檔案中有 @data qt-gui-plugin-style-sheet 節點內容, 則 Leo 會全部以新設定來顯示畫面中的內容.

而更具彈性的做法則是在各別 .leo 檔案中設定 @data qt-gui-plugin-style-sheet 節點內容, 一旦開啟此 .leo 檔案, 系統就會以此設定來顯示畫面中的各區域內容.

2. 開始建立大綱標題與內容

利用 File-&gt;New 開啟一個新的 .leo 檔案, 然後利用 ctrl + i 插入一個大綱標題, 其他的操作為:

ctrl + i 插入 (insert) 大綱節點

ctrl + r 將所選擇的大綱節點往右邊 (right) 移動

ctrl + l 將所選擇的大綱節點往左邊 (left) 移動

ctrl + u 將所選擇的大綱節點往上方 (up) 移動

ctrl + d 將所選擇的大綱節點往下邊 (down) 移動

ctrl + s 存檔

使用者可以從 https://sites.google.com/a/mde.tw/service/public/tutorial1.leo?attredirects=0&amp;d=1 下載 tutorial1.leo 檔案.

3. 下載 tutorial1.leo 開啟後, 就可以利用滑鼠點按 newHeadline 兩次, 編輯節點標題, 移到下方的淡紅色對應內文區, 就可以輸入與 newHeadline 對應的大綱內容.

在這個簡單的 Leo Editor 使用說明裏, 我們說明了如何下載或建立可攜的 Leo Editor 編輯器系統, 啟動後, 開啟 tutorial1.leo 就可以讓 Leo Editor 使用 @data qt-gui-plugin-style-sheet 節點中的設定 ,假如這時再以 Help-&gt;Open leoSettings.leo 檔案, Leo Editor 又會以 leoSettings.leo 中的小字型 (12px) 設定來顯示畫面中的各區內容.

另外, File-&gt;Recent Files 下, 使用者可以選擇先前已經開啟的 .leo 檔案或清除 Recent Files 紀錄, clear 應該是暫時清除 Recent Files 顯示, 而 clean 應該就是將存在系統中的紀錄刪除 (實際測試好像看不出 clear 與 clean 的差別).

好了, 你已經完成了最基本的 Leo Editor 操作, 接下來就是如何利用 Leo Editor 與外部檔案進行互動.</t>
<t tx="amd_yen.20130409163608.1839">首先, 我們為了要方便啟動 Leo Editor, 可以在 commands 目錄下建立一個 start_leo.bat, 內容為:

y:\Python33\python.exe y:\commands\launchLeo.py

使用者只要在 cmd 對應視窗中, 執行 start_leo, 就可以開啟 Leo Editor.

在這個教學流程中, 我們將會使用幾個 Leo Editor 特定的 @language, @path 以及 @auto 指令, 其中 @language 用於節點內文, 而 @path 與 @auto 都是節點標題中的指令.

1. 利用 Leo 編輯器打開 tutorial1.leo, 我們已經學會如何利用 ctrl + i 增加節點, 也學會如何利用 ctrl + r, l, u, d 等四個快捷鍵移動所選擇的節點, 也知道可以利用 ctrl  + s 進行存檔.

接下來我們就先在最外圍的區域以 ctrl + i 增加一個節點, 我們在節點標題輸入"建立外部檔案", 並且在此節點的下一階, 建立另外一個節點, 也就是在最外部建立節點後, 以 ctrl + r 向右移動.

這個附屬於"建立外部檔案"第二階的節點標題, 我們輸入 @path tutorial2, 而這個標題為"@path tutorial2" 的節點內文則保持空白, 然後在"@path tutorial2" 節點的再下一階則再利用 ctrl + i 建立另一個節點, 而且標題輸入"@auto tut2.py", 內文則輸入:

@language python
#coding: utf-8

for 索引 in range(5):
    print("第"+str(索引)+"行執行 Python 程式")

完成上述三個新節點的建立後, 先不要急著存檔, 先到 Y:\examples 目錄中建立一個 tutorial2  目錄, 然後再將目前編修 tutorial1.leo 檔案存在 Y:\exammples 目錄下, 存檔後, 就可以在 log  區看到:

created: Y:\examples\tutorial2\tut2.py
saved: tutorial2.leo

等兩行, 表示已經建立了 tut2.py 並且對 tutorial2.leo 存檔, Leo Editor 為何會這樣做?

2. 先來看標題為 @path tutorial2 的作用.

@path 放在大綱標題, 表示路徑關係, 節點標題為 "@path tutorial2" 表示其下屬節點若有存檔指令 (例如:@auto) 都會是在 tutorial2 目錄之下, 而其下屬節點標題 "@auto tut2.py" 表示要求 Leo 將此節點的內文存成檔案, 而且檔案名稱就是 tut2.py, 由於其上一階層有一個 "@path tutorial2" 節點, 因此 tut2.py 檔案就會存在 tutorial2.leo 所在目錄下的 tutorial2 子目錄, 並且檔案會存為 tut2.py.

3. 如何執行 tut2.py?

雖然可以直接在 Leo Editor 的環境下來執行 tut2.py,  但是 Leo Editor 與 tut2.py 都是 Python3 程式, 比較好的做法是在 Leo Editor 之外來執行此一程式, 實際的操作方法為:

以滑鼠點選 @auto tut2.py  節點標題, 然後以滑鼠右鍵帶出另一個小視窗, 選擇最上頭的 "Edit tut2.py in SciTE.exe", Leo Editor 就會啟動 SciTE 編輯器, 然後開啟 tut2.py, 這時只要在 SciTE 環境, 選擇 Tools-&gt;Go, 就可以執行 tut2.py, 並且在 output 區看到執行結果, 但是 Leo Editor 如何牽動 SciTE 的開啟, 答案就在 start.bat

還記得 start.bat 啟動內容中有:

REM 設定 Leo 所用的編輯器
set LEO_EDITOR=%Disk%:\wscite\SciTE.exe

所以利用 start.bat  啟動時, Leo Editor 就會以 SciTE 作為附屬的編輯器, 而且在 SciTE 設定中, python.properties 已經透過:

if PLAT_WIN
    command.go.*.py=y:\Python33\pythonw -u "$(FileNameExt)"

指名要讓 y:\Python33\pythonw 來執行副檔名為 .py  的檔案, 因此, 一旦 @path 與 @auto 標題指令合力建立 tut2.py 後, 由 Leo 啟動 SciTE, 就可以進行 tut2.py 程式的執行.

4. 接著則是節點內文中 @language  的用法說明:

@language python

表示內文中採用 python 語法來顯示,  @language 為內文指令.

5. 最後, 關閉 tutorial2.leo 檔案, 然後以 SciTE 修改位於 y:\exammples\tutorial2 目錄中的 tut2.py, 把它改為:

#coding: utf-8

for 索引 in range(10):
    print("第"+str(索引)+"行執行 Python 程式")

也就是將原本的 range(5) 改為 range(10), 然後再以 Leo Editor 開啟 tutorial2.leo

標題為 "@auto tut2.py" 的節點內容發生了變化, Leo Editor 不僅納入已經改變的 tut2.py 程式, 而且自動 (@auto) 將程式納入 "tut2 declarations" 節點, 並且將 "@auto tut2.py" 節點的內容改為:

@language python
@tabwidth -4
@others

其中的 @others 表示此節點下屬的所有節點內容都會被納入 tut1.py 程式中 (除了命名節點 (named node) 外,  tutorial3 會談到命名節點).

6. 總結 tutorial2 所呈現的內容, 我們利用 Leo Editor  的 @path 來宣告節點的路徑關係, 並且利用 @auto 來建立外部檔案, 一個重點為:

使用者必須自行建立 tutorial2 子目錄

否則 tut2.py 將不會存檔.

其次在節點內文中, 可以利用 @language python 來辨識 Python 程式碼, 一旦外部的 tut2.py 檔案在 Leo Editor 之外變更後, 使用者再次打開 tutorial2.leo 後, Leo 就會自動導入已經改變的 tut2.py 程式碼, 而且會自動將程式納入階層式的大綱標題與內容.

好了,  終於學會 @path, @auto 與 @language 的基本用法, 這些指令有些用於標題, 有些用於內文, 除了 @language 外,  @tabwidth 與 @others 也都是內文指令, 隨後我們將會加以說明.

tutorial2 可以從 https://sites.google.com/a/mde.tw/service/public/tutorial2.7z?attredirects=0&amp;d=1 下載.</t>
<t tx="amd_yen.20130410133544.14742"></t>
<t tx="amd_yen.20130410133544.14743"></t>
<t tx="amd_yen.20130410133544.14744"></t>
<t tx="amd_yen.20130410133544.14745"></t>
<t tx="amd_yen.20130410133544.14746">指已經存在的商用或自由軟體套件, 可用來輔助操作者進行機械設計</t>
<t tx="amd_yen.20130410133544.14747">指由操作者編寫程式, 用來延伸既有套件的功能, 以擴增設計效益.</t>
<t tx="amd_yen.20130410133544.14748">指整體架構完全由設計者自行編寫建構的程式工具或套件系統</t>
<t tx="amd_yen.20130410133544.14749"></t>
<t tx="amd_yen.20130410133544.14750"></t>
<t tx="amd_yen.20130410133544.14751"></t>
<t tx="amd_yen.20130410133544.14752"></t>
<t tx="amd_yen.20130410133544.14753"></t>
<t tx="amd_yen.20130410133544.14754"></t>
<t tx="amd_yen.20130410133544.14755"></t>
<t tx="amd_yen.20130410133544.14756"></t>
<t tx="amd_yen.20130410133544.14757"></t>
<t tx="amd_yen.20130410133544.14758"></t>
<t tx="amd_yen.20130410133544.14759"></t>
<t tx="amd_yen.20130410133544.14760"></t>
<t tx="amd_yen.20130410133544.14761"></t>
<t tx="amd_yen.20130410133544.14762"></t>
<t tx="amd_yen.20130410133544.14763"></t>
<t tx="amd_yen.20130410133544.14764"></t>
<t tx="amd_yen.20130410133544.14765"></t>
<t tx="amd_yen.20130410133544.14766"></t>
<t tx="amd_yen.20130410133544.14767"></t>
<t tx="amd_yen.20130410133544.14768"></t>
<t tx="amd_yen.20130410133544.14769"></t>
<t tx="amd_yen.20130410133544.14770"></t>
<t tx="amd_yen.20130410133544.14771"></t>
<t tx="amd_yen.20130410133544.14772"></t>
<t tx="amd_yen.20130410133544.14773"></t>
<t tx="amd_yen.20130410133544.14774"></t>
<t tx="amd_yen.20130410133544.14775"></t>
<t tx="amd_yen.20130410133544.14776">指使用者利用電腦與網路搜尋與設計內容相關的資料

取用他人所提供的相關設計資料</t>
<t tx="amd_yen.20130410133544.14777">指由設計者利用網路, 搭建自我團隊可運用之程式, 以達到增進設計效益的目的.

經由各種方法接收基本資料, 經過處理或運算成為其他可引用的設計資料</t>
<t tx="amd_yen.20130410133544.14778">指在設計者的搭建下, 由機器對機器, 經由網路, 自動傳輸所需的設計相關資料.

例如, 分散機械設計系統與自動資料備份系統</t>
<t tx="amd_yen.20130410133544.14779"></t>
<t tx="amd_yen.20130410133544.14780"></t>
<t tx="amd_yen.20130410133544.14781"></t>
<t tx="amd_yen.20130410133544.14782"></t>
<t tx="amd_yen.20130410133544.14783"></t>
<t tx="amd_yen.20130410133544.14784"></t>
<t tx="amd_yen.20130410133544.14785"></t>
<t tx="amd_yen.20130410133544.14786"></t>
<t tx="amd_yen.20130410133544.14787"></t>
<t tx="amd_yen.20130410133544.14788">專門用來提供資料給使用者的電腦</t>
<t tx="amd_yen.20130410133544.14789">以近距離組合的方式組成一可共享運算資源的電腦</t>
<t tx="amd_yen.20130410133544.14790">電腦主機分散在不同位置而組成一個可彼此共享運算資源的組合

與叢集電腦相比, 以較長距離組合的方式組成一可共享運算資源的電腦</t>
<t tx="amd_yen.20130410133544.14791">具有非常多核心運算單元的電腦</t>
<t tx="amd_yen.20130410133544.14792">特指可採用虛擬模式, 及時依照使用負載而彈性配置運算與資料儲存單元的電腦組合.</t>
<t tx="amd_yen.20130410133544.14793">輕便且使用者可隨身攜帶, 具有螢幕與鍵盤滑鼠等配置的電腦</t>
<t tx="amd_yen.20130410133544.14794">輕便且使用者可隨身攜帶, 並且只具有螢幕的電腦</t>
<t tx="amd_yen.20130410133544.14795">主要功能用於個人通訊, 但仍提供基本電腦功能之裝置.</t>
<t tx="amd_yen.20130410133544.14796">本身具有運算單元主體的小型電子裝置.</t>
<t tx="amd_yen.20130410133544.14797"></t>
<t tx="amd_yen.20130410133544.14798">經由物理性質的改變而感知之電子裝置</t>
<t tx="amd_yen.20130410133544.14799">傳遞數據或資料的電子裝置</t>
<t tx="amd_yen.20130410133544.14800">無需實體連線, 即可藉以操作控制某一裝置的資訊傳遞元件</t>
<t tx="amd_yen.20130410133544.14801">提供資料運算或分析的小型電子裝置</t>
<t tx="amd_yen.20130410133544.14802">指該項事物並非主體, 而是從體.</t>
<t tx="amd_yen.20130410133544.14803"></t>
<t tx="amd_yen.20130410133544.14804">指從電腦與使用者之間的互動模式自動化與否進行分類</t>
<t tx="amd_yen.20130410133544.14805">指設計者只需將設計需求告知電腦套件或程式, 由電腦設法找出可行設計方案或最佳設計方案</t>
<t tx="amd_yen.20130410133544.14806">指由操作者與電腦程式或套件, 以對談互動的模式進行機械設計</t>
<t tx="amd_yen.20130410133544.14807">利用電腦(網路)程式, 設法增進電腦或其操作者更高的設計效率.</t>
<t tx="amd_yen.20130410133544.14808">指依照採用不同的設計原理來加以輔助的角度進行分類</t>
<t tx="amd_yen.20130410133544.14809"></t>
<t tx="amd_yen.20130410133544.14810"></t>
<t tx="amd_yen.20130410133544.14811"></t>
<t tx="amd_yen.20130410133544.14812"></t>
<t tx="amd_yen.20130410133544.14813"></t>
<t tx="amd_yen.20130410133544.14814"></t>
<t tx="amd_yen.20130410133544.14815"></t>
<t tx="amd_yen.20130410133544.14816"></t>
<t tx="amd_yen.20130410133544.14817"></t>
<t tx="amd_yen.20130410133544.14818"></t>
<t tx="amd_yen.20130410133544.14819"></t>
<t tx="amd_yen.20130410133544.14820"></t>
<t tx="amd_yen.20130410133544.14821"></t>
<t tx="amd_yen.20130410133544.14822"></t>
<t tx="amd_yen.20130410133544.14823"></t>
<t tx="amd_yen.20130410133544.14824"></t>
<t tx="amd_yen.20130410133544.14825"></t>
<t tx="amd_yen.20130410133544.14826"></t>
<t tx="amd_yen.20130410133544.14827"></t>
<t tx="amd_yen.20130410133544.14828"></t>
<t tx="amd_yen.20130410133544.14829"></t>
<t tx="amd_yen.20130410133544.14830">指從事與力學相關的工程設計, 且其產品元件或組成會隨時間而改變其屬性的設計.

</t>
<t tx="amd_yen.20130410133544.14831">設計

是一種溝通與協同的創造性活動

設計的本質是講道理, 定計畫, 勤執行, 做紀錄, 忙修改的求同步重複遞迴行動

也就是

    講道理 - 要有所本
    定計畫 - 要有條理
    勤執行 - 要說到做到
    做紀錄 - 要鉅細靡遺
    忙修改 - 要修補漏洞
    求同步 - 要積極進取
    重複遞迴 - 可收斂的設計才是成功的設計
</t>
<t tx="amd_yen.20130410133544.14832"></t>
<t tx="amd_yen.20130410133544.14833"></t>
<t tx="amd_yen.20130410133544.14834"></t>
<t tx="amd_yen.20130410133544.14835"></t>
<t tx="amd_yen.20130410133544.14836"></t>
<t tx="amd_yen.20130410133544.14837">指採用既有之通用設計與規格之機械元件進行設計</t>
<t tx="amd_yen.20130410133544.14838">指完全由設計者量身打造, 可專屬使用之機械元件, 通常由專屬機械元件所組成之設計產品可包含相關的產品專利與特有設計工具或技術</t>
<t tx="amd_yen.20130410133544.14839"></t>
<t tx="amd_yen.20130410133544.14840"></t>
<t tx="amd_yen.20130410133544.14841"></t>
<t tx="amd_yen.20130410133544.14842"></t>
<t tx="amd_yen.20130410133544.14843"></t>
<t tx="amd_yen.20130410133544.14844"></t>
<t tx="amd_yen.20130410133544.14845"></t>
<t tx="amd_yen.20130410133544.14846"></t>
<t tx="amd_yen.20130410133544.14847"></t>
<t tx="amd_yen.20130410133544.14848"></t>
<t tx="amd_yen.20130410133544.14849"></t>
<t tx="amd_yen.20130410133544.14850"></t>
<t tx="amd_yen.20130410133544.14851"></t>
<t tx="amd_yen.20130410133544.14852"></t>
<t tx="amd_yen.20130410133544.14853"></t>
<t tx="amd_yen.20130410133544.14854"></t>
<t tx="amd_yen.20130410133544.14855"></t>
<t tx="amd_yen.20130410133544.14856"></t>
<t tx="amd_yen.20130410133544.14857"></t>
<t tx="amd_yen.20130410133544.14858"></t>
<t tx="amd_yen.20130410133544.14859"></t>
<t tx="amd_yen.20130410133544.14860"></t>
<t tx="amd_yen.20130410133544.14861"></t>
<t tx="amd_yen.20130410133544.14862"></t>
<t tx="amd_yen.20130410133544.14863"></t>
<t tx="amd_yen.20130410133544.14864"></t>
<t tx="amd_yen.20130410133544.14865"></t>
<t tx="amd_yen.20130410133544.14866"></t>
<t tx="amd_yen.20130410133544.14867"></t>
<t tx="amd_yen.20130410133544.14868"></t>
<t tx="amd_yen.20130410133544.14869"></t>
<t tx="amd_yen.20130410133544.14870"></t>
<t tx="amd_yen.20130410133544.14871"></t>
<t tx="amd_yen.20130410133544.14872"></t>
<t tx="amd_yen.20130410133544.14873"></t>
<t tx="amd_yen.20130410133544.14874"></t>
<t tx="amd_yen.20130410133544.14875"></t>
<t tx="amd_yen.20130410133544.14876"></t>
<t tx="amd_yen.20130410133544.14877"></t>
<t tx="amd_yen.20130410133544.14878"></t>
<t tx="amd_yen.20130410133544.14879"></t>
<t tx="amd_yen.20130410133544.14880"></t>
<t tx="amd_yen.20130410133544.14881"></t>
<t tx="amd_yen.20130410133544.14882"></t>
<t tx="amd_yen.20130410133544.14883"></t>
<t tx="amd_yen.20130410133544.14884"></t>
<t tx="amd_yen.20130410133544.14885"></t>
<t tx="amd_yen.20130410133544.14886"></t>
<t tx="amd_yen.20130410133544.14887"></t>
<t tx="amd_yen.20130410133544.14888"></t>
<t tx="amd_yen.20130410133544.4362">Tutorial3 練習檔案可以從 https://sites.google.com/a/mde.tw/service/public/tutorial3.7z?attredirects=0&amp;d=1 下載.

本教學將延續 Tutorial 2, 介紹另一個 Leo Editor 的節點標題指令 @asis.

但是何謂節點標題指令, 其實 Leo Editor 中以 @ 開頭的字串有其特殊用法, 可以導引 Leo 編輯器對標題或內容執行指令, 而這些指令有些是放在節點標題才會有作用, 例如: @auto 與 @asis 都是放在節點標題使用的指令, 而這種指令就稱為"節點標題指令".

相對於放在標題才會有作用的"標題指令", 有些指令是放在節點內文才會有作用, 例如: @language, 這種指令就稱為"內文指令", 先前將 @language python 放在內文的最前頭, 就是告訴 Leo 編輯器, 這個內文要以 Python 程式語法來標示.

Tutorial 2 中的 @auto 所連結的外部檔案, Leo 編輯器不僅會將此外部檔案的內容讀進內文區, 而且若檔案為程式碼, Leo 還會解讀程式碼中的類別與函式, 然後將這些程式物件以樹狀結構呈現, 這些檔案會以外部檔案為主, 假如外部檔案變更, .leo 檔案開啟時就會讀入新的檔案內容, 而在 .leo 檔案編輯時, 改變樹狀結構內容, 儲存 .leo 檔時也會同時更新外部檔案.

Tutorial 3 要介紹的 @asis, 則與 @auto 指令有很大的不同, @asis 對應的外部檔案只在 .leo 存檔時會從 Leo 節點寫成外部檔, 實際的資料會存在.leo 節點中, 外部檔案變更後, 重新打開 .leo 檔, @asis 無法反應外部檔案的變更.

使用者可以在打開 tutorial2.leo 後, 將外部 tut3.txt 刪除, 並不會影響存在節點中的內容, 當節點內容改變, 且儲存 .leo 檔案時, Leo 會將節點內容再存入 tut3.txt 檔案.

另外一點, "tut3 的子節點"以下的節點, 無論是"命名節點"或一般節點, 內容都會被存入 tut3.txt, 而且子節點間不會自動跳行.

接著來複習一下 @auto 大綱標題指令:

Leo 編輯器網站有關 @auto 的說明這樣寫著:

@auto 節點標題指令會自動導入外部檔案, 並且將外部檔案的內容納入節點樹狀架構, 當以 Leo 編輯器建立的外部檔案, 不希望附加 Leo 標註資料時,  @auto 節點標題指令通常為第一選擇. 儘管以 @auto 指令所連結的外部檔案沒有 Leo 標註資料, 當此外部檔案變更後, Leo 仍能配合變更其對應的節點樹狀架構.

@auto 對應檔案是以輸入器 (importers) 進行資料讀取, 各程式類別、方法或函式都會單獨以節點存放, 目前 Leo 可以解讀的節點資料有 C, elisp, HTML, .ini files, Java, Javascript, Pascal, PHP, Python 與 xml. 能夠解讀的 html 標註則有 html, body, head, and div 等, 其他未支援的程式內容則會全部以複製方法導入.

@auto 導入外部檔案時會自動查驗與原導入檔案的差異, 一旦發生內容差異時, Leo 就會發生錯誤或警告訊息並自動插入 @ignore  指令, 以免意外更動外部檔案原本的內容.

另外, @auto 將外部程式檔案以 leoImport.py 解讀為 Leo 編輯器節點的樹狀結構, 對於 Python 程式的解讀性最佳, 原因就在於 Python 程式語法對於縮排有嚴格規定, 因此只要是能夠正確執行的 Python 程式被 @auto 正確解讀的機會最高, 而其他程式語言若編寫架構參差, Tab 與空白混用將會造成 @auto 解讀上的困難, 一旦 Leo Editor 在利用@auto 解讀過程發現內容有誤時, 並不會強制導入樹狀架構, 而是將全部內容讀到節點內文中, 若使用者無法適度修改成可以讓 @auto 解讀的版本, 使用者可以將 @auto 改為 @edit, 讓 Leo Editor 將所有程式碼存在同一節點的方式來管理.

@edit 與 @auto 節點標題指令都不會在外部檔案中加上 Leo 標記, 且在 .leo 檔案中不會儲存外部檔案資料, 而是在開檔時由外部讀進檔案資料, @edit 會將檔案放在同一節點, 而 @auto 則會將外部程式檔案中的類別與函式納入 Leo 的節點架構中.

Leo Editor 除了 @auto 標題指令不會在內容留下 Leo 標記外, 還有 @edit 與 @asis 等兩個標題指令 (這裡避開較少使用的 @nosent), 也不會在所建立的外部檔案中加入 Leo 標記, @edit 與 @auto 不同的地方在於:

@edit 不會像 @auto 解讀外部檔案並將外部檔案, 同時納入 Leo 的樹狀架構, @edit 會將整個外部檔案放在一個節點內容中.

@auto 與  @edit  標題指令都會讀入變更內容的外部檔案, 只不過 @auto  會解讀內容架構並且放到樹狀節點中, 而 @edit 則將外部檔案的全部資料放到一個節點中.

@asis 標題節點指令則與 @auto/@edit 有很大不同:

1. @asis 是一個以 .leo 節點資料內容為主的標題指令, 當外部檔案有變更時, @asis  並無法反應這些變更, 使用者只能從 .leo 檔案中利用節點滑鼠右鍵, 以 Refresh from disk 手動反應外部檔案最新內容.

2. @asis 通常在第一時間, 以 .leo 中的節點資料為主, 在 .leo 檔案存檔時, 才會將節點以及附屬節點的內容寫入對應的外部檔案.

3. @asis 下屬的子節點內容會全部從節點內容寫入 @asis 對應的外部檔案, 而且若節點內容沒有跳行符號, 則全部的內容都會直接黏合在一起, 不會自動跳行.

Tutorial3 練習檔案可以從 https://sites.google.com/a/mde.tw/service/public/tutorial3.7z?attredirects=0&amp;d=1 下載.

以 Leo Editor 開啟 tutorial3.leo 檔案後, 查看一下標題為 "&lt;&lt; 命名節點 &gt;&gt;" 的節點, 這種以 &lt;&lt; &gt;&gt; 標示的節點稱為"named node"

相關檔案說明: http://leoeditor.com/directives.html</t>
<t tx="amd_yen.20130410133544.4363">Tutorlal4: https://sites.google.com/a/mde.tw/service/public/tutorial4.7z?attredirects=0&amp;d=1

介紹 @edit 的使用.

請下載 tutorial4.7z 解開後, 以 Portable Leo Editor 開啟.

@edit 也是以外部檔案為主的"標題指令", 這點與 @auto 相同.

與 @auto 不同的是, @edit 讀進外部檔案後, 不會解讀也不會自動納入節點架構, 而是將所有外部檔案內容放在同一個節點內容中.

因此 @edit  的使用時機與 @auto 相同, 都是先有外部程式檔案後, 再設法以節點標題指令導入 Leo 編輯器中.

另外, 使用者若以滑鼠右鍵按住"@path tutorial4" 節點, 就可以看到"Import files"指令, 這是利用導入檔案的方式來執行 @auto 或 @edit, 可以一次選擇目錄下多個檔案, 並且將這些檔案以 @auto 或 @edit 模式導入 (程式檔會以 @auto 執行, 一般檔案則會以 @edit 執行).

路徑節點中的 "Import files" 指令, 執行 @auto 或 @edit 後, 會以絕對路徑作為節點標題, 其實這並不是很好的做法, 因為一旦 .leo 檔案移動位置後, 這些絕對路徑"可能"不會自動調整, 我們試一下好了.

我們試著以滑鼠右鍵指向"@path tutorial2", 並且要求 "Import files", 然後開啟 tut2.py, 看看 Leo Editor 會不會自動以 @auto 導入 tut2.py

接著再以滑鼠右鍵指向"@path tutorial4", 並且要求 "Import files",  然後開啟 tut4.txt, 看看 Leo Editor 會不會自動以 @edit 導入 tut4.txt

假如都可以順利導入 tut2.py 與 tut4.txt, 就可以看到 Leo Editor 以絕對路徑作為節點標題, 將此一檔案存為 tutorial4-1.leo, 然後將整個 examples 目錄搬到其他地方, 再次開啟 tutorial4-1.leo, 上述操作的絕對路徑標題仍然指向原先的檔案, 而不是相對目錄下的 tut2.py 與 tut4.txt, 因此假如在上一個步驟將絕對目錄標題改為相對目錄, 則移動位置後的節點就會指向相對目錄下的 tut2.py 與 tut4.txt.

好了,  Tutorial4 講完了, 我們現在應該已經會使用 @auto, @asis 與 @edit 來建立 Leo 內容與外部檔案之間的關聯, 而這些關聯就是後續將 Leo Editor 用來作為 IDE 的重要功能.

Tutorial 5 我們將要來看 @file 節點標題指令, 將會有更多命名節點與內文指令的應用.</t>
<t tx="amd_yen.20130410133544.4364">Tutorial5: https://sites.google.com/a/mde.tw/service/public/tutorial5.7z?attredirects=0&amp;d=1

請由上述連結下載 tutorial5.leo, 然後以可攜 Leo 編輯器開啟.

先看一下"@file tut5.py" 節點的內容:

@language python
#coding: utf8
&lt;&lt; comment &gt;&gt;
&lt;&lt; import &gt;&gt;
@others
&lt;&lt; other config &gt;&gt;
&lt;&lt; run &gt;&gt;

@language python 表示這個檔案要以 Python 程式語法解讀.

@others 則代表此一節點的下屬節點中所有節點的內容, 但是不包括"命名節點".

所謂的命名節點, 就是節點標題中帶有 &lt;&lt; 與 &gt;&gt; 符號的節點.

在 @file tut5.py 節點中, 共引用了四個命名節點, 表示要分別將這些節點內容依序放在 tut5.py 檔案中.

命名節點排列的次序就代表這些內容要放入 tut5.py 的順序, 而 @others 則代表後續下一階所有內容的總合, 要放在 @others 所在的位置.

這裡必須要特別注意的一點是, @others 所在的縮排位置非常重要, 因為整個 Leo Editor 中的節點標題與內文都是 Python 程式物件, 因此 @others 所在的位置就是後續程式要置入的對應位置, 假如 @others 向右縮排, 則表示後續的子節點內容,全部要以 @others 所在的縮排位置進行擺放.

我們可以在 @file tut5.py 節點內容動一些手腳, 將 @others 往後跳四個 spaces, 然後存檔, 看看 tut5.py 內容有何改變?

當您以滑鼠右鍵, 點住 @file tut5.py 節點, 然後選擇"Edit tut5.py in SciTE" 功能時, 打開  tut5.py 後, 就可以見到許多 # 開頭的標註記號, 這些標記就是所謂的"Leo 標記" (sentinel), 這是 Leo 用 xml 註記內容之用, 就產生外部檔案的指令而言, 只有 @file 與 @shadow 節點標題指令所產生的外部檔案才看得到.

上面提到, 當 @others 改變位置後, tut5.py 也會將子節點所對應的內容向後移位, 這就是 @others 的特性.

您也可以將 "&lt;&lt; comment &gt;&gt;" 命名節點在 @file tut5.py 節點內文中, 向右移動 4 個空白, 然後存檔, 看看 tut5.py 檔案中有何變化.

沒有錯, 與 "&lt;&lt; comment &gt;&gt;" 命名節點對應的內文也會向右移動, 因此在 Leo Editor 中各指令標示的位置是非常重要的, 可能對於不使用 Python 程式的用戶來說, 程式碼的位置無關緊要, 但是 Python 程式語法天生就是靠縮排來確定各區域的執行範圍, 養成固定縮排寫程式的習慣在 Python 而言是必要的, 能夠執行的Python 程式一定是排列整齊的, 不僅電腦執行沒有問題, 使用者也非常容易看懂, 對於 Python 以外的程式寫法也應該如此, 使用 Leo Editor 就必須注意各指令在內文出現的位置, 否則所產生的外部 Python 程式就無法執行.

總結一下 Tutorial 5 的說明, @file 節點標題指令, 會在外部檔案中加入特定的 Leo 標記, 而且外部檔案不會存在 .leo 檔案中, 而是開啟 .leo 檔案時才讀進對應的節點, 此外節點內文指令 @others 與命名節點擺放的位置會牽動對應內容寫檔時的縮排位置, 在 .leo 檔案開啟時, 修改各對應節點內容, 在存 .leo 檔時會寫入外部檔案, 可見 @file 與@auto, @edit 的資料流都是雙向的, 且都主要將內容存在外部檔案中, 只有 @asis 指令會將節點內容存在 .leo 檔案裡面.

而 @file 在外部檔案寫入 Leo 標記符號的做法, 對使用 Leo Editor 的用戶而言或許沒有問題, 但是當這些充滿 Leo 標記符號的檔案交到沒有用 Leo Editor 開啟資料的用戶, 可能就沒有太大用途, 因此 Leo Editor 還有一種兩全其美的做法, 採用 @shadow 來同時建立有 Leo 標記與沒有 Leo 標記的檔案, 前者可以讓 Leo Editor 開啟時快速確認內容架構, 而後者則可以交給不用 Leo Editor 的用戶, Tutorial 6 就是要談 @shadow 的用法.</t>
<t tx="amd_yen.20130410133544.4365">Tutorial6: https://sites.google.com/a/mde.tw/service/public/tutorial6.7z?attredirects=0&amp;d=1

這個教學要來談 Leo Editor 的 @shadow 節點標題指令的用法.

Tutorial 5 已經說明 @file 的基本用法, 但是 @file 指令所建立的外部檔案帶有許多 Leo 標記符號, 這些標記符號對於 Leo Editor 特定用途, 但是若不使用 Leo Editor 開啟, 這些標記符號可能就會是干擾, 這時您可以考慮改用 @shadow.

Tutorial 6 的節點標題與 Tutorial 5 相同, 各命名節點的內容也都一樣, 只是將 @file 換成 @shadow, 這時 Leo Editor 就會自動建立有標記與沒有標記的外部檔案.

下載 tutorial6.leo 後, 開啟, 就可以看到 @shadow tut6.py 節點標題, Leo Editor 會將 tut6.py 寫進 tutorial6 的子目錄, 請開啟 tutorial6 目錄, 您就會看到除了 tut6.py 檔案外, 還有一個 .leo_shadow 目錄, 其中外部的 tut6.py 沒有標記, 而 .leo_shadow 目錄中的 xtut6.py 就是相同內容, 但是卻有 Leo 標記符號的對應檔案.

好了, 這個說明非常簡單, 您可以試著修改一下 tut6.py  各節點的內容, 然後用 SciTE 開啟執行, 操作方法為, 利用滑鼠右鍵按住 @shadow tut6.py 節點標題, 然後選擇 "Edit tut6.py in SciTE", 接著就是在 SciTE 環境, 選擇 Tools-&gt;Go, 就可以執行這個 tut6.py 程式.</t>
<t tx="amd_yen.20130413002743.2100">http://www-inst.eecs.berkeley.edu/~cs61a/sp11/0.pdf

強調要有數學背景, 最好要有一些程式語言經驗, 然後教導 Schema, 線上課本採用 http://mitpress.mit.edu/sicp/, 任課講師為 UCBLogo 作者

一年之後, 就開始採用 Python 3 進行教學.

http://www-inst.eecs.berkeley.edu/~cs61a/sp12/

並且依照 http://mitpress.mit.edu/sicp/ 教材的編撰精神, 以 Python 3 程式語法編寫了線上教材

http://www-inst.eecs.berkeley.edu/~cs61a/sp12/book/, 並採用 http://creativecommons.org/licenses/by-sa/3.0/ 授權.

到了 http://www-inst.eecs.berkeley.edu/~cs61a/fa12/, 任職於 Google 的 John Denero (也是上述 Python 3 的作者之一)接手開課, 並導入 Philip Guo 所開發的 Python online tutor, 至此, Python online tutor 已經可以利用 cgi 介面執行伺服器上的 Python 3 解譯系統.

http://www-inst.eecs.berkeley.edu/~cs61a/sp13/ 仍然延續 Python 3 教學, 但是講師換成 2012 年剛完成 Ph.D. 學位的 Amir Kamil.
</t>
<t tx="amd_yen.20130413002743.2101">無論是學習程式語言或者是教導程式語言, 其實都不容易, 因為程式語言的目的在於與電腦硬體進行溝通, 假如使用者能夠充分了解電腦硬體的架構與運作原理, 就能有效強化運用程式語言的能力.

寫電腦程式並非電腦系、資訊工程或資訊管理科系所專有, 任何人西運用電腦快速的運算與資料處理能力的使用者, 都應該要能夠寫基本的電腦程式來解決自己所面臨的問題.

以機械設計工程領域的產品開發人員而言, 無論是使用電腦輔助設計或分析套件, 經常必須要透過該套件的延伸程式介面, 來編寫客製化程式, 才能有效解決所面臨的特殊問題.

機械設計流程中所衍生的許多數位資料, 也都必須仰賴產品資料管理與產品生命週期管理系統 (PLM), 才能在多人協同的環境中有效管理並運用各版次的設計資料.

學習程式語言必須要先認清楚學習的動機, 先來看看電腦程式與網路結合下所能到完成的工作.

根據: http://www.opensourceshakespeare.org/views/plays/plays.php 的資料, 莎士比亞的劇作共有 37 部, 全文可以由 http://cae.mde.tw/downloads/shakespeare.txt 下載, 假如我們要求電腦程式解讀這 37 本劇作, 然後找出來其中所用的單字, 包含 5 個與超過 5 個字母的單字中, 順拼與逆拼都是單字的特殊單字共有幾個?

假如用人來進行上述工作, 這真是不可能的任務, 但是電腦程式正好適合用來處理如此繁雜的工作.

.. code-block:: python

    # 本程式取材自: http://www-inst.eecs.berkeley.edu/~cs61a/sp12/book/
    #coding= utf-8
    # 從 urllib.request 模組導入 urlopen 函式
    # 參考資料: http://docs.python.org/3.0/library/urllib.request.html
    from urllib.request import urlopen
     
    # 從網路連結, 取得莎士比亞全文(37 個劇本)資料
    莎士比亞全文 = urlopen('http://cae.mde.tw/downloads/shakespeare.txt')
    # 列出全文物件
    #print(莎士比亞全文)
     
    # 參考資料: http://docs.python.org/3.0/library/stdtypes.html#set
    莎翁劇中全部單字 = set(莎士比亞全文.read().decode().split())
    # 列出全部單字物件
    #print(words)
     
    # 列出 5 個(含)字母以上的單字中, 正拼與反拼都出現在單字集中的單字
    print({單字 for 單字 in 莎翁劇中全部單字 if len(單字) &gt;= 5 and 單字[::-1] in 莎翁劇中全部單字})
     
    '''
    {'rever', 'knits', 'repel', 'level', 'drawer', 'repaid', 'stink', 'redder', 'stops', 'spots', 'asses', 'leets', 'refer', 'steel', 'devil', 'speed', 'keels', 'leper', 'sleek', 'reward', 'minim', 'sessa', 'deeps', 'madam', 'lived', 'diaper'}
    '''
    
也就是說, 符合條件的單字共有 26 個.

再來看下一個比較簡單的範例:

.. code-block:: python

    from math import *
    print(max(6.8,7.8))
    print(max(6.8,7.8,10.2))
    print(max([6.8,7.8,10.2]))
    
這個程式的第一行, from math import *, 在導入 math 模組中的所有函式, 其中包含 max() 函式, 而此一函式可以輸入多個數值, 也可以輸入數列, 都能夠在這些輸入的數值中, 找到最大的數值, 然後利用 print() 函式將結果印出來.

因為程式語言就是在與電腦進行溝通, 假如將上述程式碼改為:

.. code-block:: python

    import math
    print(math.max(6.8,7.8))
    print(math.max(6.8,7.8,10.2))
    print(math.max([6.8,7.8,10.2]))
    
就可以知道與電腦溝通的模式並非固定不變的, 假如導入的寫法不是 from math import *, 而是 import math, 後續的 max() 函式呼叫, 就必須冠上 math, 而成為 math.max()

只要明白這個道理, 同樣在 math 模組中定義的 min(), sin(), cos() 等數學函式的用法也就能夠完全掌握, 這樣的程式學習就稱為 pattern matching, 也就是類似範式的套用, 尤其對於非電腦專業的工程師而言, 只要掌握程式語言在該專業領域應用的範式就能更容易解決可能面臨的問題, 因為大多類似的問題不僅已經被解決, 而且有許多程式碼已經被公開在任何人都可以擷取的網站上, 只要了解程式語言的基本使用原理與架構, 接下來就可以設法找到可用的問題解決範式來加以套用.</t>
<t tx="amd_yen.20130413002743.2102">在十年前的五專時期, 程式語言大多以 C/C++ 教學為主, 尤其是以較為簡單的 C 程式語言教學為主, 在 Windows 95 操作系統上更以 Borland Turbo C/C++ 的教學為主, 到了 Windows NT 以及 Windows 2000 時期則逐步轉換為 Visual C/C++ 環境的教學為主, 進入 Windows XP 時期, 則轉而利用 Code::Block 與 NetBeans 等開放 IDE + MinGW C/C++ 編譯環境為主.

2010 年則以 C+PHP 程式教學為主, 自 2011 年起則全面改採 Python3 進行教學, 主要考量在於 Python3 無論在單機環境或網際環境, 甚或工程或科學運算領域上的應用, 遠比 Java 更容易入手, 且提供更多的整合工具, 尤其是在最近逐步興起的開放 MCAD (Mechanical Computer Aided Design) 與 PLM 領域也大多採 Python 程式架構, 此波趨勢甚至影響到全球各電腦資工科系的基礎教學轉變, 10 年前原先採用 Java 作為導入程式語言的課程, 過去 5 年大多轉向 Python 教學, 尤其自 2009 年起 Javascript 加上 HTML5 已經全面取代 Java applet 曾經獨攬網際平台的光環, 甚而在 2013 年的現在, Node.js 已經被許多團隊用來取代原先用 Java 在 Server 端的地位.

程式語言的應用階次比較 C++ &gt; Java &gt; C &gt; Python, 主要原因在於 Python 為解譯式程式語言, 上手比較容易, 當需要較高速的運算條件時則可以透過 Python 結合 C/C++ 程式, 或者透過 PyCuda 等模組使用 GPU 進行多核平行運算, 或結合 PyZMQ 執行分散運算.

假如再以手機與平板裝置興起的角度來看, 解譯式的 Python 加上 Javascript 更能符合短生命週期與快速變遷的程式環境需求.

因此目前的程式語言、電腦輔助設計、協同產品設計相關教學, 採用 Python 3 + Javascript + PHP + C/C++ 足以勝任大多數的程式環境需求.</t>
<t tx="amd_yen.20130413002743.2103">#coding: utf-8
from sympy
 import *
x, y, z, t = symbols('x y z t')
k, m, n = symbols('k m n', integer=True)
f, g, h = symbols('f g h', cls=Function)
# d:f 表示由 d 到 f
d, e, f = symbols('d:f')
# 表示 g0 與 g1
print(var('g:2'))
print(diff(x**2/2, x))
print(limit(sin(x)/x, x, 0))
print((1/cos(x)).series(x, 0, 10))
print(Rational(2)**50/Rational(10)**50)
R = Rational
print(R(1, 2))
print(pi.evalf())
print((pi*E).evalf())
# oo is infinity (兩個小寫的ㄡ)
print(oo &gt; 9999999)
print(integrate(1/x, x))
print(x+y*2-3*x-5*y)
# 多項式展開
print(((x+y)**2).expand())
# 取代, x=1 代入多項式
print((((x+y)**3).subs(x, 1)).expand())
# 因式分解
print(apart(1/((x+2)*(x+1)), x))
# 合併
print(together(1/x+1/y+1/z))
# 微分
print(diff(sin(2*x), x))
# 複數
print(exp(I*x).expand(complex=True))
# 三角函數
print(cos(x+y).expand(trig=True))
print(sin(x+y).expand(trig=True))</t>
<t tx="amd_yen.20130413002743.2104">下載, 解開, 執行

這裡利用 Python、SciTE、TinyC 與 Leo Editor 建立一個可攜的程式環境.

</t>
<t tx="amd_yen.20130418193628.2121">以下為 CMSimple plugin 以 Javascript 編寫動態四連桿模擬.

&lt;?php

function yen4barMain(){
$output = &lt;&lt;&lt;EOF
&lt;script&gt;
var Point = function Point(x,y){
    this.x=x;
    this.y=y;
}
// 附加 drawMe() 方法, 以繪製出點位置
Point.prototype.drawMe = function drawMe(g,r){
    this.g = g;
    this.r = r;
    this.g.save();
    this.g.moveTo(this.x,this.y);
    this.g.beginPath();
    // draw a radius=4 circle
    this.g.arc(this.x, this.y, this.r, 0, 2 * Math.PI, true);
    this.g.moveTo(this.x,this.y);
    this.g.lineTo(this.x+this.r, this.y);
    this.g.moveTo(this.x, this.y);
    this.g.lineTo(this.x-this.r, this.y);
    this.g.moveTo(this.x, this.y);
    this.g.lineTo(this.x, this.y+this.r);
    this.g.moveTo(this.x, this.y);
    this.g.lineTo(this.x, this.y-this.r);
    this.g.restore();
    this.g.stroke();
}
// 加入 Eq 方法
Point.prototype.Eq = function Eq(pt){
    this.x = pt.x;
    this.y = pt.y;
}
// 加入 setPoint 方法
Point.prototype.setPoint = function setPoint(px,py){
    this.x = px;
    this.y = py;
}
// 加上 distance(pt) 方法, 計算點到 pt 的距離
Point.prototype.distance = function distance(pt){
    this.pt = pt;
    return Math.sqrt(Math.pow(this.x-this.pt.x,2)+Math.pow(this.y-this.pt.y,2));
}
// Line 函式物件
var Line = function Line(p1,p2){
    this.p1 = p1;
    this.p2 = p2;
    this.Tail = this.p1;
    this.Head = this.p2;
    this.length = Math.sqrt(Math.pow(this.p2.x-this.p1.x, 2)+Math.pow(this.p2.y-this.p1.y,2));
}
// setPP 方法 for Line
Line.prototype.setPP = function setPP(p1,p2){
    this.p1 = p1;
    this.p2 = p2;
    this.Tail = this.p1;
    this.Head = this.p2;
    this.length = Math.sqrt(Math.pow(this.p2.x-this.p1.x, 2)+Math.pow(this.p2.y-this.p1.y,2));
}
// setRT 方法 for Line, 應該已經確定 Tail 點, 然後以 r, t 作為設定 Head 的參考
Line.prototype.setRT = function setRT(r,t){
    this.r = r;
    this.t = t;
    var x = this.r * Math.cos(this.t);
    var y = this.r * Math.sin(this.t);
    this.Tail.Eq(this.p1);
    this.Head.setPoint(this.Tail.x + x,this.Tail.y + y);
}
// getR 方法 for Line
Line.prototype.getR = function getR(){
    // x 分量與 y 分量
    var x = this.p1.x - this.p2.x;
    var y = this.p1.y - this.p2.y;
    return Math.sqrt(x * x + y * y);
}
// 根據定義 atan2(y,x), 表示 (x,y) 與 正 x 軸之間的夾角, 介於 PI 與 -PI 間
Line.prototype.getT = function getT(){
    var x = this.p2.x - this.p1.x;
    var y = this.p2.y - this.p1.y;
    if (Math.abs(x) &lt; 1E-100) {
        return y &lt; 0.0 ? -Math.PI/2 : Math.PI/2;
    }else{
        return Math.atan2(y, x);
    }
}
// setTail 方法 for Line
Line.prototype.setTail = function setTail(pt){
    this.pt = pt;
    this.Tail.Eq(pt);
    this.Head.setPoint(this.pt.x + this.x, this.pt.y + this.y);
}
// getHead 方法 for Line
Line.prototype.getHead = function getHead(){
    return this.Head;
}
Line.prototype.getTail = function getTail(){
    return this.Tail;
}
Line.prototype.drawMe = function drawMe(g){
    this.g = g;
    this.g.beginPath();
    this.g.moveTo(this.p1.x,this.p1.y);
    this.g.lineTo(this.p2.x,this.p2.y);
    this.g.stroke();
}
// 轉換函式
function degToRad(x) {
    return x / 180 * Math.PI;
}
function radToDeg(x) {
    return x / Math.PI * 180;
}
//
// 建立一個物件繼承函式
// We need a utility function to do the inheritance
function inherit(superClass, subClass) {
    for(var i in superClass.prototype) {
        subClass.prototype[i] = superClass.prototype[i]
    }
}
// 建立 Link function 物件
var Link = function Link(p1,p2){
    this.p1 = p1;
    this.p2 = p2;
    this.length = Math.sqrt(Math.pow(this.p2.x-this.p1.x, 2)+Math.pow(this.p2.y-this.p1.y,2));
}
// 讓 Link 繼承 Line 的方法與屬性
inherit(Line,Link);
//
//
//
// 建立 Link 特有的 drawMe 方法
Link.prototype.drawMe = function drawMe(g){
    this.g = g;
    var hole = 5;
    var radius = 10;
    var length = this.getR();
    // 儲存先前的繪圖狀態
    this.g.save();
    this.g.translate(this.p1.x,this.p1.y);
    // 這裡的轉角必須配合最初的 Link 是畫在 x 軸上或是 y 軸上來進行座標轉換, 目前是以畫在 y 軸上進行座標軸旋轉, 並且確定 Math.atan2(y,x)
    // 以下 alert 用來 debug
    //alert("角度為"+ radToDeg(this.getT()));
    //alert("座標軸轉角為"+radToDeg(-(Math.PI/2-this.getT())));
    this.g.rotate(-(Math.PI/2-this.getT()));
    // 必須配合畫在 y 軸上的 Link, 進行座標轉換, 也可以改為畫在 x 軸上...
    this.g.moveTo(0,0);
    this.g.beginPath();
    this.g.arc(0, 0, hole, 0, 2*Math.PI, true);
    this.g.stroke();
    //
    this.g.moveTo(0,length);
    this.g.beginPath();
    this.g.arc(0,length, hole, 0, 2*Math.PI, true);
    this.g.stroke();
    //
    this.g.moveTo(0,0);
    this.g.beginPath();
    this.g.arc(0,0, radius, 0, Math.PI, true);
    this.g.moveTo(0+radius,0);
    this.g.lineTo(0+radius,0+length);
    this.g.stroke();
    this.g.moveTo(0,0+length);
    //
    this.g.beginPath();
    this.g.arc(0, 0+length, radius, Math.PI, 0, true);
    this.g.moveTo(0-radius,0+length);
    this.g.lineTo(0-radius,0);
    this.g.stroke();
    //
    this.g.restore();
}
//
//
//
//
//
// ap1 角為 p1 點所在的角度, lenp1 長度則為 ap1 角度對應的邊長
// ap2 角為 p2 點所在的角度, lenp2 長度則為 ap2 角度對應的邊長
// ap3 角為 p3 點所在的角度, lenp3 長度則為 ap3 角度對應的邊長
var Triangle = function Triangle(p1,p2,p3){
    // 先將輸入變數轉為函式物件性質
    this.p1 = p1;
    this.p2 = p2;
    this.p3 = p3;
}
//
Triangle.prototype.getLenp3 = function getLenp3(){
    var p1 = this.p1;
    var ret = p1.distance(this.p2);
    return ret;
}
//
Triangle.prototype.getLenp1 = function getLenp1(){
    var p2 = this.p2;
    var ret = p2.distance(this.p3);
    return ret;
}
//
Triangle.prototype.getLenp2 = function getLenp2(){
    var p1 = this.p1;
    var ret = p1.distance(this.p3);
    return ret;
}
    
// 角度
Triangle.prototype.getAp1 = function getAp1(){
    var ret = Math.acos(((this.getLenp2() * this.getLenp2() + this.getLenp3() * this.getLenp3()) - this.getLenp1() * this.getLenp1()) / (2* this.getLenp2() * this.getLenp3()));
    return ret;
}
//
Triangle.prototype.getAp2 = function getAp2(){
    var ret =Math.acos(((this.getLenp1() * this.getLenp1() + this.getLenp3() * this.getLenp3()) - this.getLenp2() * this.getLenp2()) / (2* this.getLenp1() * this.getLenp3()));
    return ret;
}
//
Triangle.prototype.getAp3 = function getAp3(){
    var ret = Math.acos(((this.getLenp1() * this.getLenp1() + this.getLenp2() * this.getLenp2()) - this.getLenp3() * this.getLenp3()) / (2* this.getLenp1() * this.getLenp2()));
    return ret;
}
//
Triangle.prototype.drawMe = function drawMe(g){
    this.g = g;
    var r = 5;
    // 繪出三個頂點
    this.p1.drawMe(this.g,r);
    this.p2.drawMe(this.g,r);
    this.p3.drawMe(this.g,r);
    var line1 = new Line(this.p1,this.p2);
    var line2 = new Line(this.p1,this.p3);
    var line3 = new Line(this.p2,this.p3);
    // 繪出三邊線
    line1.drawMe(this.g);
    line2.drawMe(this.g);
    line3.drawMe(this.g);
}
// ends Triangle function
// 透過三個邊長定義三角形
Triangle.prototype.setSSS = function setSSS(lenp3,lenp1,lenp2){
    this.lenp3 = lenp3;
    this.lenp1 = lenp1;
    this.lenp2 = lenp2;
    this.ap1 = Math.acos(((this.lenp2 * this.lenp2 + this.lenp3 * this.lenp3) - this.lenp1 * this.lenp1) / (2* this.lenp2 * this.lenp3));
    this.ap2 = Math.acos(((this.lenp1 * this.lenp1 + this.lenp3 * this.lenp3) - this.lenp2 * this.lenp2) / (2* this.lenp1 * this.lenp3));
    this.ap3 = Math.acos(((this.lenp1 * this.lenp1 + this.lenp2 * this.lenp2) - this.lenp3 * this.lenp3) / (2* this.lenp1 * this.lenp2));
}
// ends setSSS
// 透過兩個邊長與夾角定義三角形
Triangle.prototype.setSAS = function setSAS(lenp3,ap2,lenp1){
    this.lenp3 = lenp3;
    this.ap2 = ap2;
    this.lenp1 = lenp1;
    this.lenp2 = Math.sqrt((this.lenp3 * this.lenp3 + this.lenp1 * this.lenp1) - 2* this.lenp3 * this.lenp1 * Math.cos(this.ap2));
    //等於 SSS(AB, BC, CA);
}
// ends setSAS
//
Triangle.prototype.setSaSS = function setSaSS(lenp2,lenp3,lenp1){
    this.lenp2 = lenp2;
    this.lenp3 = lenp3;
    this.lenp1 = lenp1;
    var ret;
    if(this.lenp1 &gt; (this.lenp2 + this.lenp3)){
    // &lt;CAB 夾角為 180 度, 三點共線且 A 介於 BC 之間
        ret = Math.PI;
    } else {
        // &lt;CAB 夾角為 0, 三點共線且 A 不在 BC 之間
        if((this.lenp1 &lt; (this.lenp2 - this.lenp3)) || (this.lenp1 &lt; (this.lenp3 - this.lenp2))){
        ret = 0.0;
        } else {
        // 透過餘絃定理求出夾角 &lt;CAB 
            ret = Math.acos(((this.lenp2 * this.lenp2 + this.lenp3 * this.lenp3) - this.lenp1 * this.lenp1) / (2 * this.lenp2 * this.lenp3));
        }
    }
    return ret;
}
// 取得三角形的三個邊長值
Triangle.prototype.getSSS = function getSSS(){
    var temp = new Array(2);
    temp[0] = this.getLenp1();
    temp[1] = this.getLenp2();
    temp[2] = this.getLenp3();
    return temp;
}
// 取得三角形的三個角度值
Triangle.prototype.getAAA = function getAAA(){
    var temp = new Array(2);
    temp[0] = this.getAp1();
    temp[1] = this.getAp2();
    temp[2] = this.getAp3();
    return temp;
}
// 取得三角形的三個角度與三個邊長
Triangle.prototype.getASASAS = function getASASAS(){
    var temp = new Array(5);
    temp[0] = this.getAp1();
    temp[1] = this.getLenp1();
    temp[2] = this.getAp2();
    temp[3] = this.getLenp2();
    temp[4] = this.getAp3();
    temp[5] = this.getLenp3();
    return temp;
}
Triangle.prototype.setPPSS = function setPPSS(p1,p3,lenp1,lenp3){
var temp = new Array(1);
this.p1 = p1;
this.p3 = p3;
this.lenp1 = lenp1;
this.lenp3 = lenp3;
this.lenp2 = this.p1.distance(this.p3);
// bp3 is the angle beside p3 point, cp3 is the angle for line23, p2 is the output
var ap3,bp3,cp3,p2;
var line31 = new Line(p3,p1);
ap3 = Math.acos(((this.lenp1 * this.lenp1 + this.lenp2 * this.lenp2) - this.lenp3 * this.lenp3) / (2 * this.lenp1 * this.lenp2));
bp3 = line31.getT();
cp3 = bp3 - ap3;
temp[0] = p3.x + this.lenp1*Math.cos(cp3); // p2.x
temp[1] = p3.y + this.lenp1*Math.sin(cp3); // p2.y
return temp;
}
//
//
//
//
// 執行繪圖流程, 注意 x, y 為 global variables
function draw(){
    // 清除畫布
    context.clearRect(0, 0, canvas.width, canvas.height)
    // 畫圖
    line1.drawMe(context);
    line2.drawMe(context);
    line3.drawMe(context);
    // 畫出三角形
    //triangle1.drawMe(context);
    //triangle2.drawMe(context);
    // 旋轉角度進行增量
    theta += dx;
    // 根據旋轉角度計算 p2 點的新位置
    p2.x = p1.x + line1.length*Math.cos(theta*degree);
    p2.y = p1.y - line1.length*Math.sin(theta*degree);
    temp = triangle2.setPPSS(p2,p4,link3_len,link2_len);
    p3.x = temp[0];
    p3.y = temp[1];
}
// ends function draw()
//
//
//
//
// 以上為相關函式物件的定義區
// 全域變數
// 幾何位置輸入變數
var x=10,y=10,r=10;
// 畫布與繪圖內容
var canvas,context;
// 其他輸入變數
var theta = 0;
var degree = Math.PI/180;
var dx = 2;
var dy = 4;
var p1 = new Point(150,100);
var p2 = new Point(150,200);
var p3 = new Point(300,300);
var p4 = new Point(350,100);
var line1 = new Link(p1,p2);
var line2 = new Link(p2,p3);
var line3 = new Link(p3,p4);
var line4 = new Link(p1,p4);
var line5 = new Link(p2,p4);
var link2_len = p2.distance(p3);
var link3_len = p3.distance(p4);
var triangle1 = new Triangle(p1,p2,p4);
var triangle2 = new Triangle(p2,p3,p4);
var temp = new Array(1);
//
//
//
//
// 視窗載入時執行內容
window.onload=function(){
    // 繪圖畫布設定
    canvas = document.getElementById("canvas");
    context = canvas.getContext("2d");
    // 座標轉換, 移動 canvas.height 並且 y 座標變號, 也就是將原點座標移到畫面左下角
    context.translate(0,canvas.height);
    context.scale(1,-1);
    // 座標轉換結束, 之後的繪圖都將在此一座標戲中進行繪製
    /*
    context.translate(dx,dy) &lt;==&gt; context.transform( 1,  0,  0,  1, dx, dy)
    context.rotate(θ)        &lt;==&gt; context.transform( c, -s,  s,  c,  0,  0)
    context.scale(sx,sy)     &lt;==&gt; context.transform(sx,  0,  0, sy,  0,  0)
    */
    //////////
    //////////
    // 以間隔 10 micro seconds 重複呼叫 draw()
    window.setInterval(draw, 10);
}
//
//
//
//
&lt;/script&gt;
&lt;p&gt;
	&lt;canvas height="600" id="canvas" style="border:1px solid black;" width="600"&gt;&lt;/canvas&gt;&lt;/p&gt;
EOF;
return $output;
}</t>
<t tx="amd_yen.20130418193628.2122"></t>
<t tx="amd_yen.20130423211907.2155"></t>
<t tx="amd_yen.20130423211907.2156">PythonCAD 自 2010 年起正以 PyQT GUI 全面改寫(R38)中, 主要特色在於:

    自行打造一個小型的 2D 繪圖 kernel
    
    使用 SQLite 資料庫系統
    
    支援 Scriptable 程式介面

使用者可以透過此一完全以 Python 程式語言打造的 2D 來了解電腦輔助機械設計製圖的初步架構, 進而建立其他客製化的 2D 繪圖應用模組.

截至 2013.04, Python R38 仍然僅支援 Python 2, 若要將程式碼改為 Python 3 相容, 需要進行以下修改:
    
    IDE\Python33\Lib\site-packages\PyQt4\pyrcc4.exe 將 PythonCAD\Interface\cadwindow.qrc 轉為 cadwindow_rc.py 過程必須將 icons 目錄複製為 Interface\images, 然後重新建立 cadwindow_rc.py (pyrcc4 -py3 cadwindow.qrc -o cadwindow_rc.py), 才可建立 Python 3 相容的 cadwindow_rc.py
    
    必須利用 IDE\Python33\tools\scripts\2to3.py -w PythonCAD 將原先 Python 2 的程式碼轉為 Python 3 相容的程式碼
    
    實際執行 pythoncad_qt.py 時還必須修改 .toBool() 為 bool(), 以及其他類似的 Python 2 轉為 Python 3 的程式語法差異
    
    此外, C:\Documents and Settings\用戶名稱\PythonCAD 目錄中的 PythonCAD_Local.pdr SQLite 資料庫檔案為啟動 PythonCAD 時會自動導入的資料檔案, 由於 Python 2 與 Python 3 有不同版本的 pickle.dumps() 與 pickle.loads() 用法 (Python 2 支援 protocol 2, 而 Python 3 支援 protocol 3), 因此必須全面改寫繪圖檔案的 file io 格式, 才能夠全面將 Python 2 的 PythonCAD 轉為 Python 3.
    
以下為 .pdr 檔案格式中 pycadent, 也就是 PythonCAD entity 資料表格的欄位設計:

CREATE TABLE pycadent(
                    pycad_id INTEGER PRIMARY KEY,
                    pycad_entity_id INTEGER,
                    pycad_object_type TEXT,
                    pycad_object_definition TEXT,
                    pycad_object_style TEXT,
                    pycad_security_id INTEGER,
                    pycad_undo_id INTEGER,
                    pycad_entity_state TEXT,
                    pycad_index NUMERIC,
                    pycad_visible INTEGER,
                    pycad_undo_visible INTEGER,
                    pycad_locked INTEGER,
                    pycad_bbox_xmin REAL,
                    pycad_bbox_ymin REAL,
                    pycad_bbox_xmax REAL,
                    pycad_bbox_ymax REAL, pycad_property TEXT)
                    
為了將 PythonCAD 改為 Python 3 相容, 必須修改上述資料庫欄位設計, 將 pycad_object_definition TEXT, 改為 pycad_object_definition BLOB, 並且將 pycad_object_style TEXT, 改為 pycad_object_style BLOB, 主要原因在於 Python 3 的 pickle 版本為 3, 而 Python 2 pickle 版本則為 2, 所有在 Python 3 經過 pickle.dumps() 處理過的資料其格式為 bytes, 而且 pickle.loads() 中的輸入資料格式必須為 bytes.
</t>
<t tx="amd_yen.20130423211907.2157"></t>
<t tx="amd_yen.20130423211907.2158">根據 http://docs.python.org/3/library/pickle.html#what-can-be-pickled-and-unpickled 的說明:

The following types can be pickled:

    None, True, and False
    integers, floating point numbers, complex numbers
    strings, bytes, bytearrays
    tuples, lists, sets, and dictionaries containing only picklable objects
    functions defined at the top level of a module
    built-in functions defined at the top level of a module
    classes that are defined at the top level of a module
    instances of such classes whose __dict__ or the result of calling __getstate__() is picklable (see section Pickling Class Instances for details).
</t>
</tnodes>
</leo_file>
