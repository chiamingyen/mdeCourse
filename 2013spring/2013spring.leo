<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="amd_yen.20130306001037.1797" a="E"><vh>@settings</vh>
<v t="amd_yen.20130306001037.1798"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="amd_yen.20130306001037.1799"><vh>@string initial_split_orientation = vertical</vh></v>
</v>
<v t="amd_yen.20130307204656.1443" a="E"><vh>課程規劃與進行</vh>
<v t="amd_yen.20130307204656.9867"><vh>@url Leo 手冊</vh></v>
</v>
<v t="amd_yen.20130308103121.2379"><vh>整體架構規劃</vh></v>
<v t="amd_yen.20130308210411.2383"><vh>自編教材 (點選下列節點, 按下 Ctrl+b 可以建立教材)</vh>
<v t="amd_yen.20130314194325.1514" a="E"><vh>@button generate-current</vh>
<v t="amd_yen.20130308210411.2404"><vh>&lt;&lt; html manual &gt;&gt;</vh></v>
<v t="amd_yen.20130308210411.2405"><vh>&lt;&lt; pdf manual &gt;&gt;</vh></v>
</v>
<v t="amd_yen.20130308210411.2403" a="E"><vh>@button generate-full-userguide</vh>
<v t="amd_yen.20130308210411.2404"></v>
<v t="amd_yen.20130308210411.2405"></v>
</v>
<v t="amd_yen.20130308210411.2397"><vh>@edit document\conf.py</vh></v>
<v t="amd_yen.20130308210411.2398"><vh>@edit document\kmol_toc.html.txt</vh></v>
<v t="amd_yen.20130318140025.2832" a="E"><vh>位於 exts 目錄的中文分詞程式</vh>
<v t="amd_yen.20130318140025.2829"><vh>@edit exts\zh.py</vh></v>
<v t="amd_yen.20130318140025.2830"><vh>@edit exts\chinese_search.py</vh></v>
<v t="amd_yen.20130318140025.2831"><vh>@edit exts\sphinx.search.py</vh></v>
</v>
</v>
<v t="amd_yen.20130312013510.1824"><vh>@button self_and_subtree</vh></v>
<v t="amd_yen.20130308210411.2406" a="E"><vh>KMOL Guide</vh>
<v t="amd_yen.20130308221230.3827" a="E"><vh>前言</vh>
<v t="amd_yen.20130312013510.1498"><vh>以下為電子書內容</vh></v>
<v t="amd_yen.20130308221230.3828"
expanded="amd_yen.20130308221230.3829,"><vh>@file frontMatter.txt</vh></v>
</v>
<v t="amd_yen.20130308210411.2384" a="E"><vh>程式語言(二)</vh>
<v t="amd_yen.20130318140025.2833"><vh>有關程式語言</vh></v>
<v t="amd_yen.20130308221230.2437"><vh>C2 第一週程式</vh>
<v t="amd_yen.20130308221230.2438" a="E"><vh>@shadow c2/grouping.py</vh></v>
<v t="amd_yen.20130308221230.2441" a="E"><vh>@shadow c2/generate_stud.py</vh></v>
</v>
<v t="amd_yen.20130308221230.2457"><vh>C2 第二週程式</vh>
<v t="amd_yen.20130308221230.2458" a="E"><vh>@shadow c2/docutils_ex1.py</vh></v>
<v t="amd_yen.20130308221230.2462"><vh>課程規劃</vh></v>
<v t="amd_yen.20130308221230.2463" a="E"><vh>課程進行</vh>
<v t="amd_yen.20130308221230.2464"><vh>portableKMOL 配置</vh></v>
</v>
<v t="amd_yen.20130308221230.2465" a="E"><vh>@shadow c2/docutils_ex2.py</vh></v>
</v>
<v t="amd_yen.20130317160119.1726"><vh>C2 第四週程式</vh>
<v t="amd_yen.20130317160119.1727"><vh>@shadow c2/pyqt_geardesign.py</vh></v>
</v>
<v t="amd_yen.20130312013510.1501"><vh>網誌內容</vh></v>
<v t="amd_yen.20130312013510.1498"></v>
<v t="amd_yen.20130308210411.2387" a="E"
expanded="amd_yen.20130308210411.2388,amd_yen.20130308214521.2438,amd_yen.20130308214521.2440,amd_yen.20130317094520.1538,"><vh>@file c2.txt</vh></v>
</v>
<v t="amd_yen.20130308210411.2385" a="E"><vh>協同產品設計實習</vh>
<v t="amd_yen.20130309155804.1706" a="E"><vh>CD 第三週程式</vh>
<v t="amd_yen.20130309155804.1707" a="E"><vh>@shadow cd/spreadsheet.py</vh></v>
</v>
<v t="amd_yen.20130314194325.1746" a="E"><vh>CD 第四週程式</vh>
<v t="amd_yen.20130314194325.1747" a="E"><vh>@shadow cd/gearcontour.py</vh></v>
</v>
<v t="amd_yen.20130312013510.1498"></v>
<v t="amd_yen.20130308210411.2392" a="E"
expanded="amd_yen.20130308210411.2393,amd_yen.20130308214521.2427,amd_yen.20130309155804.1709,amd_yen.20130310161901.1489,amd_yen.20130314194325.1511,amd_yen.20130309155804.1711,amd_yen.20130320201815.1570,"><vh>@file cd.txt</vh></v>
</v>
<v t="amd_yen.20130308210411.2386" a="E"><vh>網際內容管理</vh>
<v t="amd_yen.20130406103207.2438"><vh>django 程式開發</vh>
<v t="amd_yen.20130406103207.2442"><vh>@url Tutorial 1</vh></v>
<v t="amd_yen.20130406103207.2285"><vh>@edit wcm/django1.py</vh></v>
<v t="amd_yen.20130406103207.2286"><vh>@button django project</vh></v>
<v t="amd_yen.20130406103207.2435"><vh>@edit wcm/mysite/mysite/settings.py</vh></v>
<v t="amd_yen.20130406103207.2434"><vh>@button sync db</vh></v>
<v t="amd_yen.20130406103207.2287"><vh>@button startapp polls</vh></v>
<v t="amd_yen.20130406103207.2436"><vh>@edit wcm/mysite/polls/models.py</vh></v>
<v t="amd_yen.20130406103207.2437"><vh>@button sql polls</vh></v>
<v t="amd_yen.20130406103207.2434"></v>
<v t="amd_yen.20130406103207.2439"><vh>@url Tutorial 2</vh></v>
<v t="amd_yen.20130406103207.2440"><vh>@edit wcm/mysite/mysite/urls.py</vh></v>
<v t="amd_yen.20130406103207.2441"><vh>啟動伺服器</vh></v>
</v>
<v t="amd_yen.20130312013510.1498"></v>
<v t="amd_yen.20130308210411.2407" a="E"
expanded="amd_yen.20130308210411.2408,amd_yen.20130330144838.2031,"><vh>@file wcm.txt</vh></v>
</v>
<v t="amd_yen.20130308221230.2492" a="E"><vh>綜合資料</vh>
<v t="amd_yen.20130312013510.1498"></v>
<v t="amd_yen.20130308221230.2493" a="E"
expanded="amd_yen.20130308221230.2494,amd_yen.20130308221230.2481,amd_yen.20130308221230.2482,amd_yen.20130308221230.2485,amd_yen.20130311141127.1492,amd_yen.20130309155804.1713,amd_yen.20130322213429.1578,amd_yen.20130321213622.1575,"><vh>@file misc.txt</vh></v>
</v>
</v>
<v t="amd_yen.20130406103207.2444" a="E"><vh>機械設計的本質</vh>
<v t="amd_yen.20130406103207.2445" a="E"><vh>何謂設計?</vh>
<v t="amd_yen.20130406103207.2447"><vh>設計衡量</vh></v>
<v t="amd_yen.20130406103207.2449"><vh>設計類型</vh></v>
</v>
<v t="amd_yen.20130406103207.2446" a="E"><vh>何謂機械?</vh>
<v t="amd_yen.20130406103207.2448"><vh>機械內容</vh></v>
</v>
<v t="amd_yen.20130406103207.2450"><vh>電腦輔助設計</vh></v>
<v t="amd_yen.20130406103207.2451"><vh>協同設計</vh></v>
<v t="amd_yen.20130406103207.2768"><vh>GPU 相關</vh></v>
</v>
<v t="amd_yen.20130406103207.2760"><vh>C Pointer and Array</vh>
<v t="amd_yen.20130406103207.2761"><vh>PREFACE</vh></v>
<v t="amd_yen.20130406103207.2762"><vh>INTRODUCTION</vh></v>
<v t="amd_yen.20130406103207.2763"><vh>Chapter 1: What is a Pointer?</vh></v>
<v t="amd_yen.20130406103207.2764"><vh>Chapter 2: Pointer Types and Arrays.</vh></v>
<v t="amd_yen.20130406103207.2765"><vh>Chapter 3: Pointers and Strings</vh></v>
<v t="amd_yen.20130406103207.2766"><vh>Chapter 4: More on Strings</vh></v>
<v t="amd_yen.20130406103207.2767"><vh>Chapter 5: Pointers and Structures</vh></v>
</v>
<v t="amd_yen.20130325133433.2805"><vh>C2G1</vh>
<v t="amd_yen.20130325133433.2806" a="E"><vh>按鈕</vh>
<v t="amd_yen.20130325133433.2807" a="E"><vh>@button c2g1</vh>
<v t="amd_yen.20130325133433.2808"><vh>&lt;&lt; html manual &gt;&gt;</vh></v>
<v t="amd_yen.20130325133433.2809"><vh>&lt;&lt; pdf manual &gt;&gt;</vh></v>
</v>
</v>
<v t="amd_yen.20130325133433.2810" a="E"><vh>設定檔案</vh>
<v t="amd_yen.20130325133433.2811" a="E"><vh>@path c2g1</vh>
<v t="amd_yen.20130325133433.2812"><vh>@edit conf.py</vh></v>
<v t="amd_yen.20130325133433.2813"><vh>@edit index.html.txt</vh></v>
<v t="amd_yen.20130325133433.2814"><vh>@edit make.bat</vh></v>
</v>
</v>
<v t="amd_yen.20130325133433.2815" a="E"><vh>Latex 後續處理(選項)</vh>
<v t="amd_yen.20130325133433.2816" a="O"><vh>@edit c2g1/_build/latex/index.tex</vh></v>
<v t="amd_yen.20130325133433.2817"><vh>@button latex pdf</vh></v>
</v>
<v t="amd_yen.20130325133433.2818" a="E"><vh>c2g1 report</vh>
<v t="amd_yen.20130325133433.2819" a="E"><vh>選項設定</vh>
<v t="amd_yen.20130325133433.2820" a="E"><vh>@rst c2g1/frontmatter.html</vh>
<v t="amd_yen.20130325133433.2821"><vh>前言</vh></v>
<v t="amd_yen.20130325133433.2822"><vh>動機</vh></v>
</v>
</v>
</v>
<v t="amd_yen.20130325133433.2823"><vh>@auto c2g1/fromoutside.html.txt</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="amd_yen.20130306001037.1797"></t>
<t tx="amd_yen.20130306001037.1798">QSplitter::handle {
    background-color: #CAE1FF; /* lightSteelBlue1 */
}

QStackedWidget {
    /* background-color:lightpink; */
    border-color: red;
    padding: 0px;
    /* border-width: 0px; */
    /* background-color: yellow; */
}

QSplitter {
    border-color: white;
    background-color: white;
    border-style: solid;
}

QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 18px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 17px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 17px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 18px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 17px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 17px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="amd_yen.20130306001037.1799">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="amd_yen.20130307204656.1443">希望能夠比照 Leo Doc 的方式建構, 將每一週的上課內容進行註記, 然後使用者可以利用 Sphinx 與 LaTeX 將內容轉換成 html 與 pdf  檔案格式.

編寫方式採用 @file 與 @rst

希望參考

V:\misc\leo-editor-snapshot-20130223\leo\leoeditor_doc\LeoDocs.leo#Startup

註: 左手按住 Ctrl, 然後右手點選下一個子書籤就會帶出 Leo 的手冊 (假如是在 misc 目錄下工作時), 並且逐步將該內容中產生 html 與 pdf 的架構, 複製到課程相關的資料編輯模式中.

基本資料更新的流程如下:

1. 由網路上下載 portablKMOL, 並且啟動, 系統會自動開啟 Leo Editor 以及其他網際相關伺服器.

(需要有 portableGit, 至於其他相關工具與模組則可最佳化到最小容量, 額外的模組則依照需求再由網路中下載, 以附加的模式增加可攜系統的功能)

2. 以 git clone https://github.com/chiamingyen/mdeCourse.git

在電腦中的某一目錄中, 複製 gihub 有關 mdeCourse 的最新版本.

3. 利用 portablKMOL 中的 Leo Editor 開啟 mdeCourse 中的課程相關 .leo 檔案.

4. 配合課程進行, 修改課程筆記.

5. 下課之前, 以 portableGit 執行

git add .

git commit -m "commit message"

git push

但是此階段需要 .ssh 對應的 private key 資料

或許也可以利用 portableGithub 以登入的模式下, 將上述 clone 目錄中的資料, 執行 commit 與 publish 或 sync 的動作.</t>
<t tx="amd_yen.20130307204656.9867">V:\misc\leo-editor-snapshot-20130223\leo\leoeditor_doc\LeoDocs.leo#Startup</t>
<t tx="amd_yen.20130308103121.2379">2013.02

由於實際上課時, 必須配合各週次進行, 但是每幾週又會組成某一特定架構的介紹或實習, 因此 clone node 在這裡或許就可以派上用途, 例如花三週來說明 sgw 用於協同產品設計實習的群組套件搭建, 因此可以將 sgw 套件搭建流程一分為三, 並且在各週逐一完成某一特定內容的設定與實習, 而在手冊建立時, 則取三週的教學內容, 以 clone node 的方式組成 sgw 套件搭建與應用的主題.

當三週的設定與實習完成後, sgw 的設定與實習教材也能夠同步完成.

其次在上課的當下, 設法利用課程內容, 以程式建立 TCExam 相容的考題, 應該也是一項 Leo 可以發揮的地方, 由各週的上課內容中, 以特定知識或認知為考題的主軸, 然後納入 Leo 的延伸程式, 就能夠同步轉為考試題庫.

2013.03.13

重新架構 mdeCourse, 將先前的課程 github 刪除後重新在 .gitignore 中加入 _build 目錄, 讓每次所建立的 html 與 latex 檔案目錄不會送到 github.

假如配合目前上課內容的規劃, blog.kmol.info 是否仍有存在的必要? 應該可以設法配合 html 目錄, 由 Leo Editor 中的按鍵功能, 啟動將最新的 html 目錄送到某一主機對應內容, 讓學員都能擷取最新的課程相關資料, 也能夠從 github clone 最新的課程內容架構.

由於整體系統採用 Python3, 部分 Sphinx extension 功能還無法使用, html 中的中文搜尋也尚未啟動 (卡在繁體中文分詞的使用, 目前並沒有很好的方案).

PortableKMOL 能否再精簡?以配合導入 Leo Editor 之後的上課模式?

基本的架構:

Local - portableKMOL + local github clone

Remote - github repositories + OpenShift 上的 CMSimple XH

WordPress - 群組網誌

Simple Groupware - 專案管理系統

2013.03.18

以目前的想法, 將 Leo Editor 中的節點內容透過程式直接發布到 Wordpress 與 CMSimple 應該是最佳的做法, 雖然 Sphinx 可以將 rst 轉為 html, 但是中文內容搜尋問題較麻煩, 且採用 Javascript 擷取關鍵字庫的方式搜尋, 並沒有全文搜尋好, 因此現在傾向設法將節點內容轉為 CMSimple 的 content.htm 格式, 然後讓網際內容管理系統與 Leo Editor 中的節點同步.

另外一個考量則是將節點內容送到 Wordpress (透過 xmlrpc.php), 假如能夠在新增網誌內容同時取得遠端網誌存入資料庫的 id, 後續才能透過此對應 id 進行更新或刪除的動作.

為了讓 sphinx-build -b singlehtml 所產生的單一 html 檔案, 能夠轉為 CMSimple 的 content.htm, 必須要動用到 beautiful soup: http://www.crummy.com/software/BeautifulSoup/

產生單一 singlehtml 只要將 make.bat 中, "html" 程序中的 html 換成 singlehtml 就可以完成.

if "%1" == "html" (
    REM 若將 html 改為 singlehtml 則會建立一個單一 html 檔案
    REM %SPHINXBUILD% -b singlehtml %ALLSPHINXOPTS% _build/html
	%SPHINXBUILD% -b html %ALLSPHINXOPTS% _build/html</t>
<t tx="amd_yen.20130308210411.2383">尚未完成的內容為中文的索引與搜尋.

有關 Sphinx 中文搜尋:

由於 Sphinx 的搜尋採 Javascript 進行, 實作時必須要對中文內容進行分詞, 然後再與對應頁面進行連結, 如此就會造成許多問題, 假如在進行關鍵字分詞時, 系統未能納入特定的關鍵字, 則使用者便無法進行搜尋.

最好的方式當然是全文搜尋, 但是必須耗費較多時間, 有關這點必須再加以深入考量.

假如能夠將 Sphinx 所產生的 html 導入 CMSimple XH 的 content.htm 中, 應該就可以解決許多問題, 至於對應的 images, downloads, jscripts 與 plugins 也都必須要加以整合.</t>
<t tx="amd_yen.20130308210411.2384"></t>
<t tx="amd_yen.20130308210411.2385"></t>
<t tx="amd_yen.20130308210411.2386"></t>
<t tx="amd_yen.20130308210411.2403">@language python
import os
pos = c.find_h("KMOL Guide")[0]
c.selectPosition(pos)
c.k.simulateCommand('rst3')
&lt;&lt; html manual &gt;&gt;
&lt;&lt; pdf manual &gt;&gt;
</t>
<t tx="amd_yen.20130308210411.2404">'''
c is the commander of the outline containing the script.
g is Leo's leo.core.leoGlobals module.
p is the presently selected position, the same as c.p.
'''
d = c.scanAllDirectives(p)
# d 為 commander 由目前所在目錄進行指令設定掃描
# d 資料格式為 dictionary
''' 
實際操作下, d 為 
{'tabwidth': -4, 'lineending': None, 'language': 'python', 'encoding': None, 'pluginsList': [], 'pagewidth': 70, 'wrap': True, 'path': 'D:\\github\\mdeCourse\\2013spring', 'delims': ('#', '', '')}
'''
mandir = d.get('path') + "/document"
# 取出 d dictionary 中的 path 對應值 (也就是目前所在絕對目錄), 再加上 html, 因此 mandir 即為目前所在目錄下的 html 子目錄路徑
g.es(mandir) # 列出 html 子目錄路徑
os.chdir(mandir)  # 更換目錄到 html 子目錄
os.system('make html')  # 執行 make html
</t>
<t tx="amd_yen.20130308210411.2405"># you probably need to install several packages 
# to create pdf (e.g. jadetex)
mandir = d.get('path') + "/document"
g.es(mandir)
os.chdir(mandir)
os.system('make latex')
os.chdir('_build/latex')
# 接下來要設法將 .tex 轉為 .pdf
target_name = "KMOLdocumentation"
filename = target_name+".tex"
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
filename = target_name+".xdv"
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xdvipdfmx.exe -vv -E "+filename)

#
#os.system(target_name.replace(".xdv", ".pdf"))
filename = target_name+".pdf"
os.system(filename)
#os.system('../../fixup.pl &lt; Leodocumentation.tex &gt; LeoDoc.tex')
#os.system('make LeoDoc.pdf')</t>
<t tx="amd_yen.20130308210411.2406"></t>
<t tx="amd_yen.20130308221230.2437"></t>
<t tx="amd_yen.20130308221230.2457">程式語言(二)

Python docutils 相關功能的應用, 可以透過網路擷取特定文件檔案 (mark down) 與影像檔, 然後以程式方法將資料轉成 html 文件.

之後這些 mark down 格式文件還可以利用 Python 的 Sphinx 套件轉為 .tex 格式, 並且進一步再轉為 pdf 檔案.

重點:

1. 純文件檔案內容, 以 mark down 方式整理, 可以讓各組員分散建置.

2. 若需要將各組員的資料內容, 整理成為報告或論文格式, 應該要善用網路與程式方法, 比較容易整合.

3. 程式模式下的文書處理, 可以用於網際協同, 相同的資料與內容處理, 也可套用到協同機械設計流程.</t>
<t tx="amd_yen.20130308221230.2462">讓學員自行建構可攜 portableKMOL 的目的在練習網際程式框架的基本組成 (程式開發環境、內容管理系統、全球資訊網伺服器、以及各類相關工具), 學員熟悉此流程後, 可以自行修改框架並且配合需要進行各模組的改版.

1. 利用程式進行文書處理

2. 利用程式進行分析運算與設計檔案轉換

以安裝 Python33 所使用的各模組, 各舉出應用範例, 並以機械設計相關應用為考量

    Python 3.3 版與相關模組安裝:
    
    Python 3.3 本體
    
    http://www.python.org/download/
    
    安裝後 C:\Python33 約佔 33 MB
    
    distribute (Python 的 module  installer, 可利用 easy_install 安裝所需模組)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#distribute
    
    安裝後 C:\Python33 約佔 37 MB
    
    pip (Python 的 module installer, 安裝後可利用 "pip install 模組名稱" 完成模組安裝
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#pip
    
    安裝後 C:\Python33 約佔 38 MB
    
    win32com (Python 與 Windows COM 物件的連結模組, 可以利用 win32com 來連結 SolidWorks, Inventor, Word, Excel 等 Windows 應用程式物件)
    
    http://sourceforge.net/projects/pywin32/files/pywin32/Build%20218/
    
    安裝後 C:\Python33 約佔 64 MB
    
    PIL (Python 的 Image library, 可以處理 2D 影像檔案)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#pil
    
    安裝後 C:\Python33 約佔 67 MB
    
    matplotlib (Python 類似 matlab 的 plot library)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#matplotlib
    
    安裝後 C:\Python33 約佔 91 MB
    
    numpy (Python 的 numerical library, 用於數值分析運算)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy
    
    安裝後 C:\Python33 約佔 138 MB
    
    sympy (Python 的 Symbolic manipulation 模組, 用於符號式運算 (相對於數值分析))
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#sympy
    
    安裝後 C:\Python33 約佔 175 MB
    
    scipy (Python 的 Scientific library)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy
    
    安裝後 C:\Python33 約佔 292 MB
    
    PyQt (Python 連結 Qt (nokia 的開源 GUI 程式庫, 更自由的對應類似版本為 Pyside) 的程式庫, 可用來開發圖形介面單機程式, 例如: Leo editor 就是採用 PyQt 開發)
    
    http://www.riverbankcomputing.com/software/pyqt/download
    
    安裝後 C:\Python33 約佔 374 MB
    
    docutils (Python 的 document utility, 可將 rst 格式檔案轉為 html)
    
    http://www.lfd.uci.edu/~gohlke/pythonlibs/#docutils
    
    安裝後 C:\Python33 約佔 383 MB
    
    Leo editor (以 Python 編寫的 outliner 與 IDE)
    
    http://www.greygreen.org/leo/
    
    安裝後 C:\Python33 約佔 401 MB
    
    以C:\Python33\Scripts\pip install sphinx
    
    安裝後 C:\Python33 約佔 413 MB

單機模式
網際模式

3. 利用程式進行協同設計

網際機械設計流程 - 以 Pyforum + brython 為範例, 可以開發 html5 網際程式
網際內容管理 - django based CMS
網際專案管理 - OpenPLM - http://wiki.openplm.org/trac/wiki/Credits
OpenERP/PLM - http://www.openerpplm.eu/</t>
<t tx="amd_yen.20130308221230.2463">自 C2 開始逐步讓學員涉入 portableKMOL 各模組的建構流程, 以便有能力自行修改內容並且依照需求改版.</t>
<t tx="amd_yen.20130308221230.2464">利用(Python)程式進行文書處理

1. 需要安裝 docutils 模組

2. 也可以利用 Sphinx 模組將 rst 檔案轉為 html 與 tex, 然後再以 MikeTeX 將 tex 轉為 pdf 檔案</t>
<t tx="amd_yen.20130308221230.2492"></t>
<t tx="amd_yen.20130308221230.3827"></t>
<t tx="amd_yen.20130309155804.1706"></t>
<t tx="amd_yen.20130312013510.1498">所謂的電子書內容, 就是 Leo 中據以產生 html 與 pdf 檔案的主要內容, 其中包含程式內容的引用.

為了要能夠維繫各內容始終只有一個版本的精神, 必須要將電子書的內容加以分割, 除了以發布的週次作為區隔外, 各週的主要文字說明與程式也是分離, 程式內容位於各課程的分週程式區, 以 literalinclude 指令導入主文.

而這些主要的文字說明, 因為內置許多 rst 的指令, 若要再同時拿來作為網誌的發布內容, 有以下考量:
    
    是採取 rst 內容經過 button 程式處理, 以分割主文加上程式的內容進行傳遞, 抑或在 rst 轉為 html 後, 同時設法產生網誌版本, 並且以自動讀取特定 local 電腦區域的帳號/密碼後才進行傳遞?
    
    採 rst 轉換的方式, 工程較為浩大, 而 rst 轉 html 後, 則必須同時介入 Sphinx 轉換 html 的流程, 可以採 extension 的導入方式處理, 模式較為正統.
    
    Leo editor 一個內容, 多種用途 (view) 的特性, 在這個範例處理流程中, 將可充分展現.
    
    假如能夠使用 make.bat 中的 make wordpress, 過程中除了將 rst 轉換成 wordpress 的特定格式內容外, 並且會讀取相關發布的帳號密碼, 並且自動完成內容的發布, 應該是最佳處理方案.</t>
<t tx="amd_yen.20130312013510.1501">網誌內容為 clone 特定電子書的部分內容後, 針對網誌的 html 標註加以組合, 然後透過按鈕的程式執行, 將網誌內容直接送到 blog.kmol.info.

這裡有幾個重要必須突破:

電子書的內容必須配合進行分割, 例如: 區分為主文與程式, 然後主文的分段以 &lt;img src="/n/1.png"&gt;&lt;/img&gt; 為開頭, 並且依序進行增量.

&lt;!-- more --&gt; 的置入

&lt;pre&gt;&lt;/pre&gt; 程式碼的置入

[password-protect] [/password-protect] 的置入

若以 button 的指令送出網誌內容, 則連結網誌的管理者密碼該如何進行保全: 不放入 leo 但是卻能讓 button 程式讀取. (或可採用 minibuffer 區域的密碼讀取)</t>
<t tx="amd_yen.20130312013510.1824">#coding: utf-8

# 導入 os 模組
import os
'''
以下經由 urllib 向網路 URL 取得文件內容
'''
# 導入 urllib.request
import urllib.request
# 導入用來處理 rst2html 的 publish_string
from docutils.core import publish_string

# 可以取得目前所在節點與其下屬節點的內容
# 從目前所在節點位置找出節點所屬的課程名稱
mylist = []
for parent in p.self_and_parents_iter():
    mylist.append(parent.h)
# 倒數第 2 個就是課程名稱
課程名稱 = mylist[-2]
g.es("將要上傳的課程名稱:"+課程名稱)
g.es()
網誌內容 = ""
for p in p.self_and_subtree():
    # p.b 為目前所在節點的內文 (body text)
    網誌內容 += p.b
    #g.es(p.b)
'''
g.es("課程內容如下:")
g.es()
g.es(網誌內容)
'''
''' 因為 Leo 中的 rst 節點都是採用 Sphinx 語法與延伸程式, 因此無法僅透過 docutils 將 rst 節點內容轉為 html, 而必須設法利用 Sphinx 處理
'''
# 利用 docutils.core 模組中的 publish_string() 方法, 將 rst 內容轉為 html
超文件內容 = publish_string(
        source=網誌內容,
        writer_name='html',
        settings = None,
        settings_overrides={'output_encoding': 'unicode'}
    )
g.es(超文件內容)</t>
<t tx="amd_yen.20130314194325.1514">@language python
# 此一按鈕的用法為選擇節點然後按下上方的 generate-current button
# 希望能將此 button 改寫為局部產生 html 與 pdf
import os
# 位置為目前所選的節點
pos = c.p
# 將 commander 指定在目前所選的節點位置
c.selectPosition(pos)
# 針對節點位置執行 rst3 指令, 將內容轉為 rst 格式
c.k.simulateCommand('rst3')
# 接著將 rst 格式檔案轉為 html
&lt;&lt; html manual &gt;&gt;
# 將 rst 格式檔案轉為 pdf
&lt;&lt; pdf manual &gt;&gt;</t>
<t tx="amd_yen.20130314194325.1746"></t>
<t tx="amd_yen.20130317160119.1726"></t>
<t tx="amd_yen.20130318140025.2832"></t>
<t tx="amd_yen.20130318140025.2833">機械設計工程師所需要的程式語言

機械設計是一個資訊密集的遞廻流程:

    資訊密集 - 機械設計所做的每一個決策都會產生資料, 這些資料包括用來定義產品的規格, 以及訂定此規格的環境與緣由.
    
        產品規格 (specifications) - 包括產品性能、零組件尺寸、零組件材料、零組件加工流程、替代零組件等.
        訂定規格的環境 (environment) - 包括假設條件 (conditions and models)、如何 (how) 完成性能評估、如何取得優勢 (專利)、如何進行協同、如何管理等 (where, who, when, what).
        訂定規格的緣由 (reasons) - 包括產生各項資訊的前因與後果 (why).
    
    遞廻流程 - 重複因應問題、變更設計、期在產品生命週期流程中求取產品價值最大化.
    
因此程式語言就機械設計工程師運用電腦執行上述工作項目時, 期採最具效率的方式進行:
    
    以電腦管理資訊 - 文書處理、建立網站、登錄日誌
    以電腦評估規格 - 數值運算 (numerical)、科學運算 (science)、建立模型、執行工程設計分析
    以電腦建構環境 - 單機程式、網際程式、協同專案環境
    以電腦因應問題 - on demand 處理問題、以工作流程 (審批流程) 留下決策的細節資料
    
程式語言工作項目:
    
    程式語言基本概念
    
        會否採用程式方法進行數值運算、科學運算、資料處理 (程式語言(一)) - C1_intro
        會否採用程式方法建立單機程式  (程式語言(二)) - C2_app
        會否採用程式方法建立網際程式  (程式語言(一)) - C1_web
        
    會否採用程式方法進行文書處理 (程式語言(二)) - C2_leo
    會否採用程式方法建立網站、登錄日誌  (程式語言(一)) - C1_cms
    會否採用程式方法搭建協同專案環境 (程式語言(二)) - C2_web, C2_cd

程式語言課程規劃內容

C1_intro - 基本程式語法, 程式數值運算與資料處理
C1_cms - 網際內容管理, CMSimple XH
C1_web - 網際程式框架, CherryPy

C2_leo - 文書處理, docutils, Sphinx, Leo Editor, MikTeX
C2_app - 應用程式, PyQt
C2_web - 網際程式框架, CherryPy
C2_cd - 網際協同, c9.io, Simple Groupware</t>
<t tx="amd_yen.20130325133433.2805">以下示範如何在 KMOL Guide 的架構下, 新增一個節點用來產生第二本協同手冊

一本協同手冊的建立總共有三個部分

- 按鈕

用來執行 make html 與 make latex 以及最後的 xelatex 指令, 可以產生 html 與 pdf 格式的報告內容

按鈕的內容如下:

.. code-block:: python

    @language python
    import os
    pos = c.find_h("c2g1 report")[0]
    c.selectPosition(pos)
    c.k.simulateCommand('rst3')
    &lt;&lt; html manual &gt;&gt;
    &lt;&lt; pdf manual &gt;&gt;

必須要在 c.find_h() 中填入所要處理報告的標題, 這裡的範例標題為 c2g1 report, html 部分則需要修改 mandir = d.get('path') + "/c2g1", 指定處理目錄為 c2g1, pdf 部分除了指定文件原始目錄為 c2g1 外, 還需要告知 target_name = "index", 此一設定必須與 conf.py 中的 master_doc = 'index' 彼此對應.

- 設定檔案

共有三個, 包括 conf.py, toc 與 make.bat, conf.py 為 sphinx 的設定檔案, toc 則指定要加入哪些章節檔案, make.bat 則是實際執行 sphinx 指令的批次檔案.

conf.py 中重要的設定為:

_exts = "../exts"
extensions.append('chinese_search')
source_suffix = '.html.txt'
master_doc = 'index'
latex_documents = [
  ('index', 'index.tex', 'C2G1 使用者手冊',
   'Chiaming Yen', 'manual'),]

- 報告內容

報告內容分為兩類, 一類為單機上的資料, 以 @rst 節點導入後, 可以自動依照 Leo 節點從屬關係產生標題與內文, 第二類的報告內容則為由外部送入的檔案, 可以利用 @auto 節點指令將這些內容加入, 各外部檔案的名稱必須在 index.html.txt 中宣告.</t>
<t tx="amd_yen.20130325133433.2806"></t>
<t tx="amd_yen.20130325133433.2807">@language python
import os
pos = c.find_h("c2g1 report")[0]
c.selectPosition(pos)
c.k.simulateCommand('rst3')
&lt;&lt; html manual &gt;&gt;
&lt;&lt; pdf manual &gt;&gt;
</t>
<t tx="amd_yen.20130325133433.2808">'''
c is the commander of the outline containing the script.
g is Leo's leo.core.leoGlobals module.
p is the presently selected position, the same as c.p.
'''
d = c.scanAllDirectives(p)
# d 為 commander 由目前所在目錄進行指令設定掃描
# d 資料格式為 dictionary
''' 
實際操作下, d 為 
{'tabwidth': -4, 'lineending': None, 'language': 'python', 'encoding': None, 'pluginsList': [], 'pagewidth': 70, 'wrap': True, 'path': 'D:\\github\\mdeCourse\\2013spring', 'delims': ('#', '', '')}
'''
mandir = d.get('path') + "/c2g1"
# 取出 d dictionary 中的 path 對應值 (也就是目前所在絕對目錄), 再加上 html, 因此 mandir 即為目前所在目錄下的 html 子目錄路徑
g.es(mandir) # 列出 html 子目錄路徑
os.chdir(mandir)  # 更換目錄到 html 子目錄
os.system('make html')  # 執行 make html
</t>
<t tx="amd_yen.20130325133433.2809"># you probably need to install several packages 
# to create pdf (e.g. jadetex)
mandir = d.get('path') + "/c2g1"
g.es(mandir)
os.chdir(mandir)
os.system('make latex')
os.chdir('_build/latex')
# 接下來要設法將 .tex 轉為 .pdf
target_name = "index"
filename = target_name+".tex"
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xelatex.exe -no-pdf -interaction=nonstopmode "+filename)
filename = target_name+".xdv"
os.system("V:\\extensions\\portableLatex\\MiKTeX\\texmf\\miktex\\bin\\xdvipdfmx.exe -vv -E "+filename)

#
#os.system(target_name.replace(".xdv", ".pdf"))
filename = target_name+".pdf"
os.system(filename)
#os.system('../../fixup.pl &lt; Leodocumentation.tex &gt; LeoDoc.tex')
#os.system('make LeoDoc.pdf')</t>
<t tx="amd_yen.20130325133433.2810"></t>
<t tx="amd_yen.20130325133433.2811"></t>
<t tx="amd_yen.20130325133433.2815"></t>
<t tx="amd_yen.20130325133433.2816">@language latex
% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}

% \pdfpagewidth 195mm
% \pdfpageheight 271mm
% \textwidth 6.0in
% \textheight 8.8in
% \oddsidemargin -0.1in
% \evensidemargin -0.1in

\textwidth 6.8in
\oddsidemargin -0.2in
\evensidemargin -0.3in

\usepackage{pdfpages}
\usepackage[BoldFont,CJKchecksingle]{xeCJK}

    \usepackage{fancyvrb}    % for frame on Verbatim
    \usepackage{fancyhdr}
    \usepackage[T1]{fontspec}    %設定字體用

\usepackage{float}
\usepackage{ccaption}
\usepackage{pifont}
% \usepackage{fancybox}
\usepackage{fontspec,xunicode,xltxtra}

\setsansfont{Times New Roman}
\setmainfont{Times New Roman}
\setmonofont{Times New Roman}
% 新細明體
% 文鼎ＰＬ新宋
% 文鼎ＰＬ明體U20-L
% 文鼎ＰＬ报宋二GBK
\setCJKsansfont[BoldFont={新細明體},ItalicFont={新細明體}]{新細明體}
\setCJKromanfont[BoldFont={新細明體},ItalicFont={新細明體}]{新細明體}
\setCJKmainfont[BoldFont={新細明體},ItalicFont={新細明體}]{新細明體}
\setCJKmonofont[BoldFont={新細明體},ItalicFont={新細明體}]{新細明體}

    \makeatletter
    \def\verbatim@font{\rmfamily\small}    %為了讓 verbatim 註解中能夠加入中文, 採用 roman family 字體
    \makeatother

\XeTeXlinebreaklocale "zh"    %讓中文自動換行
\XeTeXlinebreakskip = 0pt plus 1pt
\renewcommand{\baselinestretch}{1.3} 
\setcounter{tocdepth}{3}
\captiontitlefont{\small\sffamily}
\captiondelim{ - }
\renewcommand\today{\number\year年\number\month月\number\day日}
\makeatletter
\renewcommand*\l@subsection{\@dottedtocline{2}{2.0em}{4.0em}}
\renewcommand*\l@subsubsection{\@dottedtocline{3}{3em}{5em}}
\makeatother
\titleformat{\chapter}[display]
{\bfseries\Huge}
{\filleft \Huge 第 \hspace{2 mm} \thechapter \hspace{4 mm} 章}
{4ex}
{\titlerule
\vspace{1ex}%
\filright}
[\vspace{1ex}%
\titlerule]
%\definecolor{VerbatimBorderColor}{rgb}{0.2,0.2,0.2}
\definecolor{VerbatimColor}{rgb}{0.95,0.95,0.95}


\title{C2G1 使用者手冊}
\date{}
\release{1.0}
\author{Chiaming Yen}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{釋出}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&amp;}
\def\PYGZlt{\char`\&lt;}
\def\PYGZgt{\char`\&gt;}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


\href{http://blog.kmol.info}{KMOL's home page}


\chapter{C2G1 報告}
\label{frontmatter:kmol-s-users-guide}\label{frontmatter::doc}\label{frontmatter:c2g1}
\index{C2G1 報告}\setbox0\vbox{
\begin{minipage}{0.95\linewidth}
\textbf{Contents}

\medskip

\begin{itemize}
\item {} 
{\hyperref[frontmatter:c2g1]{C2G1 報告}}
\begin{itemize}
\item {} 
{\hyperref[frontmatter:id1]{前言}}

\item {} 
{\hyperref[frontmatter:id2]{動機}}

\end{itemize}

\end{itemize}
\end{minipage}}
\begin{center}\setlength{\fboxsep}{5pt}\shadowbox{\box0}\end{center}


\section{前言}
\label{frontmatter:id1}
這是前言內容


\section{動機}
\label{frontmatter:id2}
這是動機內容


\chapter{這是 outside 標題}
\label{fromoutside::doc}\label{fromoutside:outside}
\index{outside 標題}\setbox0\vbox{
\begin{minipage}{0.95\linewidth}
\textbf{Contents}

\medskip

\begin{itemize}
\item {} 
{\hyperref[fromoutside:outside]{這是 outside 標題}}
\begin{itemize}
\item {} 
{\hyperref[fromoutside:id1]{小標題}}

\item {} 
{\hyperref[fromoutside:id2]{小標題2}}

\end{itemize}

\end{itemize}
\end{minipage}}
\begin{center}\setlength{\fboxsep}{5pt}\shadowbox{\box0}\end{center}

以下就是 outside 的內容, 由某一位組員負責編寫

這是外部的檔案, 來自外部的內容

這是第二次從外部更新的檔案


\section{小標題}
\label{fromoutside:id1}
這是小標題之後的內容, 假如希望從網際系統取得組員的 frontouside.html.txt, 可以透過 CMSimple 的 upload 機制.


\section{小標題2}
\label{fromoutside:id2}
這是小標題2之後的內容, 經過 sphinx 處理後的 html 目錄則可以利用 mongoose 或 nginx 派送到網站上, 也可以將 html 目錄中的內容轉送到雲端網站中.

以下嘗試由 literalinclude 導入程式碼:

\begin{Verbatim}[commandchars=\\\{\}]
\# -*- coding: utf-8 -*-
\# 配合程式所使用的 @asis 會將資料存在 .leo 檔案
\# 建立虛擬的班級人員名單
import random
import string
學號碼數 = 4
姓名字數 = 3
姓氏檔案 = "lastname.txt"
名字檔案 = "firstname.txt"
學生人數 = [53, 55]
\# 讀進姓氏檔案與名字檔案
各班學生人數=random.randint(學生人數[0], 學生人數[1])
def makeNumber(學號碼數):
    return ''.join([random.choice(string.digits) for 索引 in range(學號碼數)])

開啟姓氏檔案 = open(姓氏檔案, "r", encoding="utf-8")
姓氏 = 開啟姓氏檔案.readlines()
開啟名字檔案 = open(名字檔案, "r", encoding="utf-8")
學員檔案 = open("虛設學員.txt","w",encoding='utf-8')
名字 = 開啟名字檔案.readlines()
科系碼 = makeNumber(學號碼數)
for 索引 in range(1, 各班學生人數):
    if(len(str(索引)) == 1):
        學號 = "0" + str(索引)
    else:
        學號 = str(索引)
    \# 設法製造缺號
    if random.randint(0, 100) \textgreater{} 3 :
        姓 = 姓氏[0][random.randint(0, len(姓氏[0])-1)]
        名 = 名字[0][random.randint(0, len(名字[0])-1)]
        名 += 名字[0][random.randint(0, len(名字[0])-1)]
        print("90"+科系碼+學號+" "+姓+名)
        學員檔案.write("90"+科系碼+學號+" "+姓+名+"\PYGZbs{}n")

開啟姓氏檔案.close()
開啟名字檔案.close()
學員檔案.close()

'''

以下為 lastname.txt 的內容:

趙錢孫李周吳鄭王馮陳褚衛蔣沈韓楊朱秦尤許何呂施張孔曹嚴華金魏陶薑
戚謝鄒喻柏水竇章雲蘇潘葛奚範彭郎魯韋昌馬苗鳳花方俞任袁柳酆鮑史唐
費廉岑薛雷賀倪湯滕殷羅畢郝鄔安常樂於時傅皮卞齊康伍餘元蔔顧孟平黃
和穆蕭尹姚邵湛汪祁毛禹狄米貝明臧計伏成戴談宋茅龐熊紀舒屈項祝董梁
杜阮藍閔席季麻強賈路婁危江童顏郭梅盛林刁鍾徐邱駱高夏蔡田樊胡淩霍
虞萬支柯昝管盧莫柯房裘繆幹解應宗丁宣賁鄧鬱單杭洪包諸左石崔吉鈕龔
程嵇邢滑裴陸榮翁荀羊于惠甄曲家封芮羿儲靳汲邴糜松井段富巫烏焦巴弓
牧隗山穀車侯宓蓬全郗班仰秋仲伊宮甯仇欒暴甘鈄曆戎祖武符劉景詹束龍
葉幸司韶郜黎薊溥印宿白懷蒲邰從鄂索鹹籍賴卓藺屠蒙池喬陽鬱胥能蒼雙
聞莘党翟譚貢勞逄姬申扶堵冉宰酈雍卻璩桑桂濮牛壽通邊扈燕冀浦尚農溫
別莊晏柴瞿閻充慕連茹習宦艾魚容向古易慎戈廖庾終暨居衡步都耿滿弘匡
國文寇廣祿闕東歐殳沃利蔚越夔隆師鞏厙聶晁勾敖融冷訾辛闞那簡饒空曾
毋沙乜養鞠須豐巢關蒯相查後荊紅

以下為 firstname.txt 的內容:

平燦惠歡佩泰州江揚剛乃屏珊易吟定小其菱幼函琴青博兆菁重立呈然永奕
漢義萍皓力昌妍合仲佳虹慧蓮恭石展軒啟奇秀駿晉冰政綸丹邦大冠貞生思
玄威嘉依音雲英能緯彬妙聖協法瑞恆采心友昀花樺航玫宛順儀寶婷書妮胤
彥修火雨俞孝蕙允城盈家陽琳阿紹誠倫亨星美和予念鳳凱松幸凡雯士達泓
金瑜勇必珍芷岳鈺方琬成霞麟致哲台睿賢珠瑩南克為尹妤春怡亮伯喬夫昕
亞真喜初愛清禮斌吉淳百臻寧以筠諭仕子文雅郁柏秋蓉伸福劭木宗傑丞昭
芝弘宇明月峰東聿登左祥迪蘭佑甫雄俊之卉谷玲禾茹榮堯芬姍少謙琇禎蘋
年姵勳任信旭燕苓豐惟盛發齊介芳容于維侑舜洋璇茂芃伊玉海建季雪柔汝
千富男新昱人添群欣綠馨利宜堅意名右姿智韻典竹巧坤可全潔裕毓孜仁韋
慈志琦宣希云茜辛薇梅樂妏嬌安上仰長承旺珮良鑫桓瑋光貴茵憲品綺芸天
源娟輝君銘夙來昇如泉正廷峻瑤恬靖淑瑄行秉伶康水羽治妹宥夢映霖儒枝
沛香皇一龍興延翰山卿白忠恩亭俐孟均元凌又偉強育辰萱鴻宸亦娥振中紫
倩民隆善玟紋杰旻學若華豪湖帆恒佐桂蓁穎軍德財庭琪世林純岑原尚昆妃
宏
'''
\end{Verbatim}

\href{http://blog.kmol.info}{KMOL's home page}



\renewcommand{\indexname}{索引}
\printindex
\end{document}
</t>
<t tx="amd_yen.20130325133433.2817">@language python

'''
主要用來細部修改 tex 檔案後, 再次產生所需要的 pdf 檔案
'''
</t>
<t tx="amd_yen.20130325133433.2818"></t>
<t tx="amd_yen.20130325133433.2819">@language rest
@tabwidth -4

@ @rst-options
call_docutils=False
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = True
verbose=True
@c
</t>
<t tx="amd_yen.20130325133433.2820">################################################
C2G1 報告
################################################

.. index:: C2G1 報告

.. contents::
    :depth: 3</t>
<t tx="amd_yen.20130325133433.2821">這是前言內容</t>
<t tx="amd_yen.20130325133433.2822">這是動機內容</t>
<t tx="amd_yen.20130406103207.2286">@language python
import os
d = c.scanAllDirectives(p)
# 將目錄指到 wcm
mandir = d.get('path') + "/wcm"
g.es(mandir)
os.chdir(mandir)
# 建立 mysite 專案
project_name = "mysite"
os.system("python V:/IDE/Python33/Scripts/django-admin.py startproject "+project_name)</t>
<t tx="amd_yen.20130406103207.2287">@language python
import os
d = c.scanAllDirectives(p)
# 將目錄指到 wcm
mandir = d.get('path') + "/wcm"
g.es(mandir)
os.chdir(mandir)
# 建立 mysite 專案
project_name = "mysite"
os.chdir(project_name)
os.system("python manage.py startapp polls")
#os.system("python manage.py runserver")
</t>
<t tx="amd_yen.20130406103207.2434">@language python
# 將管理者密碼設為 admin/admin
import os
d = c.scanAllDirectives(p)
# 將目錄指到 wcm
mandir = d.get('path') + "/wcm"
g.es(mandir)
os.chdir(mandir)
# 建立 mysite 專案
project_name = "mysite"
os.chdir(project_name)
os.system("python manage.py syncdb")</t>
<t tx="amd_yen.20130406103207.2437">@language python
import os
d = c.scanAllDirectives(p)
# 將目錄指到 wcm
mandir = d.get('path') + "/wcm"
g.es(mandir)
os.chdir(mandir)
# 建立 mysite 專案
project_name = "mysite"
os.chdir(project_name)
os.system("python manage.py sql polls")</t>
<t tx="amd_yen.20130406103207.2438"></t>
<t tx="amd_yen.20130406103207.2439">https://docs.djangoproject.com/en/1.5/intro/tutorial02/</t>
<t tx="amd_yen.20130406103207.2441">python manage.py runserver 127.0.0.1:8090

在 Leo 中啟動 django 與 關閉 django 的流程, 可以套用類似 pyforum exiting 的方式:

'''
# 退出函式
def exiting(self):
    print("系統即將退出!")
    print("所要終止的 PID 為:"+ str(os.getpid()))
    # 必須要使用 /F forced mode 與 /T tree mode 才能真正 kill pyforum.py 對應的 process
    os.system("taskkill /F /T /PID "+str(os.getpid()))
exiting.exposed = True
'''</t>
<t tx="amd_yen.20130406103207.2442">https://docs.djangoproject.com/en/1.5/intro/tutorial01/</t>
<t tx="amd_yen.20130406103207.2444">機械設計牽涉機械、設計與其過程所涉各項事物的管理與表達.

管理的目的在提升效能, 而表達的目標則在增進溝通, 降低過程中不同團隊成員間產生謬誤與衝突的機會.

機械設計所需的能力:

1. 產生想法與表達想法的能力 - 如何產生構想與創意、如何表達構想與創意等.

2. 評量想法所需的理論知識能力 - 評量所設計產品所需成本、採用何種方法完成某一事物、所能達到的產品品質、推出市場所需的時間、製造所需的技術等.

3. 累積經驗的能力 - 如何整理經驗、如何管理經驗過程中所積壘的資料.

4. 與其他專業團隊成員溝通的能力 - 溝通的本質在於透明與全盤托出事物的核心價值.</t>
<t tx="amd_yen.20130406103207.2445">設計就是設想然後加以評量, 最後將經過設想與評量的結果表示出來.  因此設計牽涉至少三個步驟:

1. 設想 - 所謂設想就是在尚未落實與評價之前, 對於某一事物執行過程的想法, 可以是初步的原始概念, 也可以是根據現況加以修改的想法.

2. 評量 - 就是採用各種可行方法對設想的內容加以評價, 判定想法是否可行, 或者思考或實際驗證採用哪一做法可以得到更好的預期結果.

3. 呈現出結果 - 利用其他人可以充分理解或接受的表示方法, 將設想與評量結果表達出來.

範例:

設計的動機 - 在校園裡的自行車經常會遭竊, 因此希望能夠有一種自行車在不使用時, 能夠降低遭竊的機會.

設想階段 - 根據自行車產品遭竊的流程, 就是因為自行車僅使用簡單的鎖具, 因此保全度不佳, 設計的想法之一就是加強鎖固自行車的設施.

而另一種設計的想法則是, 讓自行車"始終"在使用者的身邊, 可以再不使用時摺疊成可以隨身攜帶的狀況, 因此另外一種設計的想法就是減輕自行車的重量, 縮小摺疊後的體積.

完成基本的設想階段後, 就是評量"加強鎖固自行車的設施" 與 "輕量可摺疊隨身" 的自行車與附件產品的進一步設計構想與細節驗證等.

而最後的設計結果, 就是根據想法與驗證, 將可行方案的執行方式細節完整表達.</t>
<t tx="amd_yen.20130406103207.2446">機械為經過機巧安排的器械, 通常牽涉利用能量的轉換來達成機巧的安排, 固力的機巧安排通常為機構, 而流力的機巧安排則牽涉到熱與流體的能量交換.</t>
<t tx="amd_yen.20130406103207.2447">達成目的的最簡單做法
最經濟的做法 (整體產品生命週期過程中成本最低者)
所需時間最短的做法
產品容易使用與維修 (護) - 符合人體工學與本能操作流程
擁有最長使用壽命
外觀容易為使用者接受 (賞心悅目)
採用先進並符合潮流之技術</t>
<t tx="amd_yen.20130406103207.2448">力學 - 靜力學、動力學、材料力學、熱力學、流體力學

機構 - 機構學、機動學、機器動力學

數學 - 微積分、工程數學、工程分析、變分學

控制 - 電子學、電路學、振動學、自動控制

程式 - 程式語言、網際程式、資料庫程式、專利寫作實務

管理 - 內容管理、產品資料管理、產品生命週期管理、工廠管理

設計 - 電腦輔助設計、協同產品設計、機械元件設計、機械系統設計、系統整合設計

分析 - 電腦輔助工程分析、機械系統分析與模擬

製造 - 工廠實習、機械製圖、機械公差、夾治具設計、工具機實習、模具設計、非傳統加工
</t>
<t tx="amd_yen.20130406103207.2449">創新設計 (原創設計) - 產出前所未有的新穎與高性能設計內容, 重點在於 innovation 創新

概念設計 (重新設計) - 根據構想、方法或工具的激發, 大致安排所需的內容設計, 重點在於 concept 概念

參數設計 - 基本概念已經決定, 但是必須根據所需的產品規格來調整變化產品的設計參數, 以調配出所需的設計元件, 重點在於 parametric 改變與組合

配置設計 - 基本元件參數已經決定, 但是必須從這些基本的元件加以組合, 配置成不同的設計以進行評估及選擇, 重點在於 configuration 配置

元件細部設計 - 配置方法已經決定, 但必須從既有的標準元件中選擇適合規格與性能的設計元件, 重點在於 selection 選擇</t>
<t tx="amd_yen.20130406103207.2450">設計運算 - design computatin

設計繪圖 - design graphics

設計模擬 - design animation

設計資料管理 - design data management (包括文書處理與資料處理或轉換)</t>
<t tx="amd_yen.20130406103207.2451">設計分工以爭取時效 - 將大任務分成許多部份由多人同步開展

專業分工以提升產品品質 - 以全球觀點尋找最適合團隊 (搭配性、技術性、互補性等) 來進行產品某部分專業的設計

區域分工以降低產品成本 - 依照產品材料取得與設計、製造、行銷或回收等成本考量, 由不同地理區域團隊分工執行

策略分工以防止核心技術外流或侵權 - 依照產品技術拆解或專利部署考量, 廠商間進行交叉代工合作</t>
<t tx="amd_yen.20130406103207.2760">C Pointer and Array

註: 以下相關內容僅提供參考, 這裡不保證所提供的中英文內容, 絕對正確或完整, 使用者必須自行擔負各種可能衍生之風險與結果.

C 的介紹 -

http://en.wikiversity.org/wiki/Topic:C

http://www.eskimo.com/~scs/cclass/cclass.html

Learning GNU C

A TUTORIAL ON POINTERS AND ARRAYS IN C

C 程式語言的指標與陣列教學

pointers.pdf

作者: Ted Jensen

Version 0.1

This material is hereby placed in the public domain.
本教材謹置於公共領域

TABLE OF CONTENTS
目錄

Preface
前言

Introduction
簡介

Chapter 1: What is a Pointer?
第一章: 何謂指標?

Chapter 2: Pointer Types and Arrays.
第二章: 指標類別與陣列

Chapter 3:  Pointers and Strings
第三章: 指標與字串

Chapter 4:  More on Strings
第四章: 更多關於字串

Chapter 5:  Pointers and Structures
第五章: 指標與結構

Chapter 6:  More on Strings and Arrays of Strings
第六章: 更多關於字串與字串陣列

Chapter 7:  More on Multi-Dimensional Arrays
第七章: 更多關於多維陣列

Chapter 8:  Pointers to Arrays
第八章: 指向陣列的指標

Chapter 9:  Pointers and Dynamic Allocation of Memory
第九章: 指標與動態記憶配置

Chapter 10: Pointers to Functions
第十章: 指向函式的指標

Epilog
結語</t>
<t tx="amd_yen.20130406103207.2761">PREFACE
前言

本文件旨在向 C 程式語言的初學者介紹指標. 過去幾年, 無論是在 FidoNet 與 UseNet 有關 C 的會議場合, 特別注意到有許多 C 程式語言的初學者, 似乎對於指標的基本用法, 感到有些困難. 因此特別利用較多的範例, 希望以淺顯的說明來解釋指標的用法.

這份文件的第一版本, 如同此一版本, 是被放在公共領域. 當時是由 Bob Stout 將資料放在 PTR-HELP.TXT 的文件檔中, 並納入 SNIPPETS 的收集中加以發行. 之後, 又在原始資料中增添了許多內容並且修正了一些錯誤.

致謝

要感謝許多不為人知的使用者, 將許多問題公佈在 FidoNet 的 C Echo 論壇中,  或是 UseNet comp.lang.c 新聞群組中, 或是在其他網路上的幾個會議區,這些要感謝的人士可能無法一一列出. 其中特別要感謝 Bob Stout 肯將這份資料的第一版本放入他所收集的 SNIPPETS 檔案中.

關於作者:

Teb Jensen 是一位退休的電子工程師, 主要專注於電磁錄音領域中的硬體設計與管理職務. 程式則是自 1968 年以來閒暇時的興趣, 當時正學著如何以打卡的方式讓程式送給電腦主機執行. (那時的主機擁有 64 K 的磁心記憶體)

使用本資料:

這份資料以公共領域授權釋出. 任何人可以採用任何形式, 複製或散佈這份資料. 唯一的要求, 則是若這份資料被用於課程教學, 希望能夠完整呈現, 亦即, 包含所有章節, 包括前言與簡介. 

並且任課教師能夠利用下方的電子郵箱通知我一聲. 之所以如此要求, 主要是希望這份資料能夠對其他人有用, 況且我並不要求金錢回報. 只是希望能夠透過使用這份資料的用戶回饋, 多少確認一下這個目標能夠達成.

此外, 並非一定要是課程教學者可以寫信給我. 感謝任何覺得此份資料有用或提供建設性批評的任何人, 都能告訴我一聲, 我將會透過電子郵件回答相關問題.

Ted Jensen     tjensen@netcom.com
P.O. Box 324     1-415-365-8452
Redwood City, CA 94064
Dec. 1995</t>
<t tx="amd_yen.20130406103207.2762">INTRODUCTION
簡介

若您想要專精於利用 C 程式語言編寫程式碼, 就必須徹底了解如何使用指標. 然而, C 指標對初學者而言, 經常是一項障礙, 尤其對於從 Fortran, Pascal 或 Basic 程式語言轉進的學習者.

這份資料旨在幫助初學者了解指標. 為了能讓這份資料發揮最大功能, 使用者最好能夠實際執行文章中所列出的各個程式. 因此所有的程式碼都採 ANSI 標準, 以便讓任何符合 ANSI 標準的編譯器都能執行這些程式碼. 內文與程式碼之間, 也特別加以區分開來, 以便使用者可以直接利用複製的方式, 取的各段落的程式碼, 套用到其他系統中進行編譯. 如此才能確實了解這裡所提供的資料.</t>
<t tx="amd_yen.20130406103207.2763">Chapter 1: What is a Pointer?

第一章: 何謂指標?

C 語言初學者必須面對的難題之一, 就是指標的用法.

這份教材的目的, 就是針對初學者簡介指標及其應用.

其實初學者會對指標產生疑惑, 大多源自於在學習 C 語言時, 對於變數的概念經常一知半解.

因此這裡就由 C 變數的一般用法說起.

程式中的變數都必須加以命名, 以便存放數值.

而編譯器與連結器在處理變數時, 就會挪出電腦記憶體中的特定區域, 以存放變數的值

這些特定區域的大小, 取決於變數允許存放值的範圍.

例如, 在 32 位元電腦, 一個整數變數的存放範圍, 需要為 4 位元. 而在舊的 16 位元電腦, 整數存放需要 2 位元.

C 程式中的整數變數存放範圍大小, 在各種機器上不一定相同.

並且 C 程式中的整數變數也不只一種, 在許多 C 程式教科數中,可以發現有整數, 長整數, 短整數等. 這裡則假設使用 32 位元系統, 因此整數需要 4 位元的存放空間.

可以採用下列程式碼,在您所使用的系統中, 查探特定整數型別所需要的記憶體空間:

#include &lt;stdio.h&gt;

int main()
{
printf("size of a short is %d\n", sizeof(short));
printf("size of a int is %d\n", sizeof(int));
printf("size of a long is %d\n", sizeof(long));
}

當我們宣告一個變數時, 亦即告知編譯器兩件事, 變數名稱與變數型別. 例如, 可以透過

    int k; 

宣告名稱為 k 的整數型別變數. 當編譯器看到 "int" 的敘述值, 就會在電腦的記憶體中, 保留 4 位元的空間, 以便存放整數變數 k 的值.

此外, 電腦也會設置一個符號表, 註明符號 k 與其在記憶體中用來存放 4 位元資料的相對位址.

因此, 若在變數宣告後, 使用

    k = 2; 

2 這個數值, 就會在程式執行時, 被放在保留給 k 變數的記憶體位址中.

在 C 語言中, 整數 k 變數, 可視為一個物件. 其中有兩個值與物件 k 有關, 也就是存放的數值與存放的位址. 有些參考書中將者兩個數值稱為"右值"與"左值". (2 為右值, 而變數位址為左值)

在某些語言中, 左值只能放在指定"等號"的左邊, 而右值則只能放在右邊. 位置放錯, 例如: 2 = k, 就會出錯.

其實, C 語言中有關左值得定義, 根據 K&amp;R II (page 197): [1], 則有些變動.

"物件為儲存區域的名稱, 而左值則為指向該物件的表示式."

這裡先採引用的定義加以說明, 後續將會進一步針對指標加以說明.

接著, 假如程式碼為:

   int j, k; 

    k = 2; 
    j = 7;    &lt;-- line 1 
    k = j;    &lt;-- line 2 

編譯器會將第一行 (line 1) 的 j 解讀為變數 j 的位址 (也就是左值), 並且將值 7 放到該位址. 在第二行 (line 2), 則會將 j 視為右值 (因為在"指定"運算子的右方), 指的則是存放在 j 記憶體中的 7 這個數值. 因此第二行執行過後, 存放在 j 的 7 這個數值, 就會被放到 k 變數所對應的"左值" (記憶體位址) 中.

在這些範例中, 採用的都是將右值從一個儲存位址, 經由複製將 4 位元的資料複製到另外一個儲存位址. 假如使用 2 位元整數, 則會複製 2 位元資料.

這裡, 就會需要一種變數, 用來存放左值 (記憶體位址). 存放此一變數的值, 隨系統而異, 舊的桌上電腦總共只有 64K 的記憶體, 每存放一個整數位址會佔去 2 位元.

更多位元數的電腦 (例如 64 位元電腦), 則需要更多的位元位址來存放一個整數資料.

實際需要的記憶體大小並不重要, 需要的則是一種方法, 通知編譯器在哪一位址存放哪些資料.

這樣的變數稱為"指標變數" (隨後將說明得更清楚). 在 C 語言中定義指標變數時, 必須在變數名稱前方, 加上一個 * 符號. 而這些指標變數的型別, 隨著要存放在指標位址中的資料型別而定, 例如, 假如宣告:

   int *ptr;

ptr 為變數名稱 (與之前的整數變數名稱 k 相同). 而 "*" 符號則告知編譯器, 此一宣告為指標變數, 亦即保留出足夠的記憶體存放位址. 最前方的 int 則表示, 希望此一指標變數用來存放整數. 而此一指標稱為"指向整數". 需要特別注意的是, 當使用 int k; 時並沒有給 k 初始值, 只有在任何符合 ANSI 規範的編譯器中, 會將宣告在函式外的變數通通以 0 初始.

同樣地, ptr 也沒有初始值, 亦即, 還沒有在上述宣告之後, 在保留的位址空間上, 放入任何值. 這裡若宣告是在任何函式之外, 就會被賦予初值, 並且保證不會指向任何 C 物件或函式. 以這種方式初始的指標, 被稱為 "空"指標 (null pointer).

而空指標並不一定會被放入 "0" 值, 因為這取決於特定系統中的設定. 為了在不同系統中的不同編譯器彼此相容, 就會利用巨集 (macro) 來表示空指標. 此巨集以 NULL 命名. 因此, 若以 NULL 設定指標值, 則可以確定在不同機器上, 這些指標變數一定是空指標.

與整數是否為 0 的判斷式 if(k ==0) 相類似, 可以利用 if(ptr == NULL) 判斷是否 ptr 為空指標.

但是, 回到新變數 ptr 的應用, 假設要將整數變數 k 所對應的位址, 存入 ptr, 就必須使用"位址運算子", 寫成:

    ptr = &amp;k; 

"位址運算子"的作用是用來取 k 的左值 (位址), 即使這時 k 位於等號右邊, 上述程式會將 k 的值複製到指標 ptr 的儲存空間中. 這時, ptr 稱為"指向" k.

接著再討論另外一個運算子.

也就是所謂的"取值運算子" (dereferencing operator), 就是一個 * 符號. 使用方法如下:

    *ptr = 7; 

這行程式會將 7 這個數值,複製到 ptr 變數所指向的位址. 也就是說, 假如 ptr 指向 k (ptr 為 k 存放資料的記憶體位址), 這行程式就會將 k 的值設為 7. 換言之, * 運算子可用來改變 ptr 所指向的值, 而不是指標本身的值. (註:指標本身為位址, 也就是所謂的左變數)

因此, 可以利用:

 printf("%d\n",*ptr); 

將目前存放在 ptr 所指向位址的整數值, 給印到螢幕.

要釐清上述說明, 可以執行下列程式, 並仔細探討程式碼與其輸出.

------------ Program 1.1 --------------------------------- 

/* Program 1.1 from PTRTUT10.TXT   6/10/97 */

#include &lt;stdio.h&gt;

int j, k;
int *ptr;

int main(void)
{
    j = 1;
    k = 2;
    ptr = &amp;k;
    printf("\n");
    printf("j has the value %d and is stored at %p\n", j, (void *)&amp;j);
    printf("k has the value %d and is stored at %p\n", k, (void *)&amp;k);
    printf("ptr has the value %p and is stored at %p\n", ptr, (void *)&amp;ptr);
    printf("The value of the integer pointed to by ptr is %d\n", *ptr);

    return 0;
}

請注意: 我們還沒有談到 C 程式中的 (void *) 表示式. 這裡可以先納入您的測試程式碼中,  隨後將會加以說明.

結論:

    1. 變數宣告必須指定名稱與型別. (例如: int k;)
    2. 指標變數宣告也是指定名稱與型別. (例如: int *ptr;), 其中的 * 告知編譯器, 該名稱為 ptr 的變數, 為一個指標變數, 而其型別為該指標指向的資料型別 (這裡為整數).
    3.  一旦變數已經宣告, 可以透過變數前方的位址運算子, 取得其位址, 例如 &amp;k.
    4. 可以由指標中"取值", 亦即, 以 * 指定到指標所參照的值, 例如: *ptr.
    5. 變數的左值為被用來存放在記憶體中的位址值, 而變數的右值則式被存放在該位址的數值.

參考資料:

"The C Programming Language" 2nd Edition
B. Kernighan and D. Ritchie
Prentice Hall
ISBN 0-13-110362-8 </t>
<t tx="amd_yen.20130406103207.2764">Chapter 2: Pointer Types and Arrays.

第二章: 指標型別與陣列

接著讓我們來看看, 為何需要指定指標指向變數的型別, 例如:

int *ptr;

原因之一是, 宣告之後, 可以透過指向, 寫成:

*ptr = 2;

編譯器就會知道要配置多少記憶體給 ptr 變數, 假如 ptr 宣告為指向整數, 電腦就會複製 4 位元的資料, 其它的浮點與雙浮點變數也是相同. 定義指向變數型別的另外一個用途就是編譯器可以解譯程式碼. 例如, 記憶區中存放 10 個連續的整數資料時, 需要 40 位元的記憶體.

假如整數指標 ptr 為這些整數中的第一個變數, 若該整數位於記憶體位址 100. 當程式寫為:

ptr + 1;

因為編譯器知道 ptr 為一個指標變數 (亦即, 其值為一組位址)並且指向某一整數 (目前位址為 100, 即是該整數所在位址), 當 ptr 加上 4 而不是 1 之後, 該指標將會指向下一個整數, 也就是記憶體 104. 

相同的概念下, 若 ptr 指向短整數, 則應該加上 2  而不是 1. 對於浮點, 雙浮點或使用者自訂的資料型別 - 結構, 也是類似.

儘管這並非我們常見的"加法", 但是在 C 語言中, 可以透過指標算數進行"加法"運算, 隨後將會再予以說明.

同理, 因為 ++ptr 與 ptr++ 與 ptr + 1 等同 (儘管 ptr 增量的時機點並不一樣).

讓指標以 ++ 增量運算子進行增量, 無論是先加或後加, 由 sizeof(type) 中所得到的位址增量, 其型別均為該物件指向變數的型別 (整數為 4 位元).

由於這 10 個整數位於記憶體中連續區塊上, 指標可以被用於整數資料陣列的處理.

例如:

    int my_array[] = {1,23,17,4,-5,100}; 

陣列中帶有 6 個整數. 可以透過 my_array 的索引代表這些整數. 亦即利用 my_array[0] 到 my_array[5] 加以表示, 也可以透過指標加以表示成:

    int *ptr;
    
    ptr = &amp;my_array[0];       /* 將指標指向陣列中的第一個整數*/ 

接著就可以使用陣列索引或取值運算, 列出陣列.

下列程式可以用來展示此一應用:

-----------  Program 2.1  -----------------------------------

/* Program 2.1 from PTRTUT10.HTM   6/13/97 */

#include &lt;stdio.h&gt;

int my_array[] = {1,23,17,4,-5,100};

int *ptr;

int main(void)
{
    int i;
    ptr = &amp;my_array[0];     /* point our pointer to the first
                                      element of the array */
    printf("\n\n");
    for (i = 0; i &lt; 6; i++)
    {
      printf("my_array[%d] = %d   ",i,my_array[i]);   /*&lt;-- A */
      printf("ptr + %d = %d\n",i, *(ptr + i));        /*&lt;-- B */
    }
    return 0;
}

編譯執行上列程式就可以仔細觀察 A 行與 B 行程式分別採用兩種方法列出陣列中的同一內容.

也可以清楚看到 B 行程式如何應用"取值"運算, 亦即, 首先在指標增量後, 在新的指標中取值. 將 B 行程式改為

    printf("ptr + %d = %d\n",i, *ptr++);

之後再執行, 接著改為:

    printf("ptr + %d = %d\n",i, *(++ptr));

再執行, 執行之前先判定結果, 並與實際執行結果進行比較.

在 C 語言, 可以利用 var_name 來替代 &amp;var_name[0], 因此在程式碼中寫成:

    ptr = &amp;my_array[0];

或:

    ptr = my_array;

都會得到相同的結果.

因此許多參考書都寫道: 陣列的變數名稱就是指標. 但是比較好的想法則是: 陣列的變數名稱就是陣列中第一元件的位址. 許多初學者 (包含作者本人), 都會將其視為指標.

但是, 可以寫成:

ptr = my_array;

但是卻不能寫成:

my_array = ptr;

原因就是 ptr 為變數, 但是 my_array 卻是常數, 也就是說, my_array 第一元件的位址, 一旦在 my_array[] 完成宣告後, 就不可以改變.

先前曾討論的左值, 中引用 K&amp;R-2 中所言:

"物件為儲存區域的名稱, 而左值則為指向該物件的表示式."

這就衍生出一個有趣的議題. 因為 my_array 為儲存區域的代表名稱, 為何 my_array 在上面的指定敘述程式中, 卻不能用在左值區域?

為了說明這點, 可以將 my_array 視為"不可改變的左值".

上列範例可以將:

    ptr = &amp;my_array[0];

改為:

    ptr = my_array;

確認兩者會得到相同的結果.

至於 ptr 與 my_array 之間的差異, 有人將陣列變數名稱視為"常數指標".
為了充分了解所謂"常數"的真諦, 重回變數定義時的說明.

當變數宣告時, 用來存值的記憶體就必須加以配置. 這時變數可以透過兩個層面來看.

用在指定運算左邊時, 編譯器會視其為記憶位址, 用來指向右側所設定的值.

若被用在運算右邊時, 變數名稱會被解讀為存在該記憶體中的值.

有了以上的概念, 關注簡單的常數運算:

    int i, k;
    i = 2;

其中 i 為存放 2 常數的變數, 並非直接在資料記憶區塊中指定, 而是直接存入程式記憶區塊. 

當 k = i; 程式碼就會到 &amp;i 位址中抓取要複製到 k 的值, 而 i = 2; 只是將 2 放入程式碼, 而沒有取值的運作. 也就是說, k 與 i 都是物件, 但是 2 則非物件.

同理, 由於 my_array 為常數 (為位址值), 一旦編譯器設好用來存值得區域後, my_array[0] 存值得記憶體位址就已經確定, 因此可以使用:

    ptr = my_array;

將此在程式區段中的常數位址設給 ptr, 其中並沒有牽涉到資料區段的取值操作.

這時就可進一步說明第一章程式 1.1. 中 (void *) 的應用. 由於指標可被用來指向各種資料型別. 除了可以指向整數, 也可以指向字元, 之後還會介紹指向結構與指向指標的指標變數.

由於在不同系統中的指標儲值大小會有差別, 並且指標的記憶體空間會隨著指向物件資料型別差異而有所不同.

因此若將長整數指給短整數資料型別變數時, 就會發生問題, 也可以將某一型別的指標變數指定給其他不同型別指標變數時, 產生問題.

為了克服此一問題, C 語言提供 void 這個空的指標資料型別.

假如將某一指標設定為:

void *vptr;

空指標可以視為通用指標. 由於 C 語言不允許整數型別指標與字元型別指標之間的資料交換或比較. 這時就可以透過空指標作為中介, 在特殊情況下在指標型別間進行資料轉換.

在第一章的 1.1 程式中, 就是使用空指標將整數指標轉成能與 %p 資料相符的格式.

下列各章, 也將透過此一概念進行資料轉換.

這裡列出許多技術資料給初學者, 首次閱讀時或許不很容易理解. 因此需要前後執行幾次程式, 看看結果, 並且仔細查驗這兩個例子中的程式碼與產出結果, 才會有所突破.

接下來, 將討論指標, 字元陣列與字串間的關係.</t>
<t tx="amd_yen.20130406103207.2765">Chapter 3: Pointers and Strings

第三章: 指標與字串

字串的研究不僅對進一步理解指標與陣列的關聯有些幫助,也能用來彰顯某些標準 C 字串函數的使用. 最後也可以理解指標如何將資料傳給函式.

就 C 而言, 字串為字元所組成的陣列, 其他的語言則未必如此.
無論是 BASIC, Pascal 或是 Fortran 與其他幾種程式語言, 字串自有其資料類別.  C 則不然, 字串之於 C 被表為以 0 位元 (寫為'\0').

這裡要以幾行程式碼作為開端, 來加以說明, 如下:

    char my_string[40];

    my_string[0] = 'T';
    my_string[1] = 'e';
    my_string[2] = 'd':
    my_string[3] = '\0';

或許沒有人會用這種方法來建立字串, 以空字元作為結尾. 根據 C 語言的定義, 字串為一組以空字元結尾的字元陣列. 注意這裡的所謂空字元與 "NULL" 不同. 空字元表為以跳脫序 '\0' 表示的"零"字元. 亦即佔了記憶體中的一個位元, 而 NULL 則為用來起始空指標的巨組程式.

NULL 在 C 編譯器中, 以 #define 在標頭檔案中宣告, 而 nul 則完全無法以 #define 宣告.

由於用上述程式來宣告字串非常累人, 因此 C 允許以多種方法來完成一項工作.

首先, 可以寫成

    char my_string[40] = {'T', 'e', 'd', '\0',};    

但是光打字就有些不方便, 因此也可以寫成:

    char my_string[40] = "Ted";

若使用的是雙引號, 而不是先前的單引號, 空字元 ('\0') 會自動被加在字串最後面.

上面的例子, 結果都相同. 編譯器會保留連續的 40 位元區塊來存放 Ted\0 這四個字元.

接著看看下列程式:

------------------program 3.1-------------------------------------

/* Program 3.1 from PTRTUT10.HTM   6/13/97 */

#include &lt;stdio.h&gt;

char strA[80] = "A string to be used for demonstration purposes";
char strB[80];

int main(void)
{

    char *pA;     /* 字元型別的指標變數*/
    char *pB;     /* 另一個字元型別的指標變數 */
    puts(strA);   /* 顯示字串 A */
    pA = strA;    /* 將 pA 指向字串 A*/
    puts(pA);     /* 顯示 pA 指向的內容 */
    pB = strB;    /* 將 pB 指向字串 B */
    putchar('\n');       /* 在螢幕中向下移動一行 */
    while(*pA != '\0')   /* A 行 (詳見內文說明) */
    {
        *pB++ = *pA++;   /* B 行 (詳見內文說明) */
    }
    *pB = '\0';          /* C 行 (詳見內文說明) */
    puts(strB);          /* 將 strB 顯示在螢幕上 */
    return 0;
}

--------- end program 3.1 -------------------------------------

上述程式定義了兩個字元陣列, 各有 80 字元. 由於屬於全域變數, 一開始各字元都填入 '\0'. 然後, strA 前 42 個字元被放入所引用的字串內容.

接著的程式碼, 宣告兩個字元指標並將其字串顯示在螢幕. 將 pA 指標指向 strA, 也就是附註 strA[0] 的位址給變數 pA. 然後利用 puts() 函數顯示 pA 所指向的內容
 puts() 函式的宣告為:

    int puts(const char *s); 

現在先不用管 const, 傳給 puts() 函數的變數為指標. 其實是指標所對應的值. 而指標的值為其所指向的位址. 因此寫成 puts(strA), 表示輸入變數為 strA[0] 的位址.

同理, 當程式寫 puts(pA); 也是以相同的位址當作輸入, 因為已經透過

pA = strA;

將位址傳給 pA

因此程式執行到 while() 指令中的 A 行時, A 行內容為:

當 pA 所指向的字元並非 nul 字元時 (也就是'\0'), 執行其內容:

而 B 行程式則表示: 將 pA 指向的字元複製給 pB 所指向的字元, 接著增量 pA 後可以指向下一字元, 而 pB 則會指向下一個記憶體空間.

完成最後一個字元複製後, pA 會指向空字元, 也會終止迴圈的執行.

其中空字元並沒有複製, 但由於 C 中的字串一定要以空字元結尾, 所以在 C 行程式中再補上空字元.

執行此一程式時, 當使用者透過除錯器看著 strA, strB, pA 與 pB 一步步執行, 將非常具有教育意義.

It is even more educational if instead of simply defining strB[] as has been done above, initialize it also with something like:

更有意思的是, 若不將 strB[] 按上述方法定義時, 而是將其起始值設為:

    strB[80] = 
"12345678901234567890123456789012345678901234567890"

讓其數字個數大於 strA  的長度, 然後一步步看著這些變數設定數值. 大家一定得親自做做看.

接著再回到 puts() 的原型, 運用 "const" 作為某一參數的宣告飾詞時, 主要在告訴使用者, 該函式無法改變其由 s 所指向的字串值, 意即, 程式會將該字串視為常數.

誠然, 上述程式展示了複製字串的一種簡單方式. 一旦確實了解上述程式的用法, 接著將自行編寫可以取代標準 strcpy() 的 C 標準函式, 程式如下:

   char *my_strcpy(char *destination, char *source)
   {
       char *p = destination;
       while (*source != '\0')
       {
           *p++ = *source++;
       }
       *p = '\0';
       return destination;
   }   

在此一程式中, 同樣運用了指標的傳值.

承上述內容, 若將函式寫成可以接受兩個字元指標變數輸入, 也就是位址, 就可以將上述程式改寫為:

    int main(void)
    {
        my_strcpy(strB, strA);
        puts(strB);
    }    

雖然與標準 C 的用法有些不同, 採用了下列原型定義:

    char *my_strcpy(char *destination, const char *source);  

之所以使用 "const" 飾詞, 主要在確定該函式無法變更指向來源指標的數值. 此點可從上述函式的修改得到印證, 其原型變數, 如 "const" 飾詞所示. 接著在函式中, 增加一行試圖更改該變數由來源指標所指向的值, 意即:

    *source = 'X';

試著將該字串的第一個字元, 變更為 X. 前面的 const 飾詞就會讓這一行程式產生錯誤, 執行完後就會更加清楚有關 const 變數的使用.

接著, 繼續探討上述程式的內涵, 第一步, 將 *ptr++ 解讀為由 ptr 指標傳回值後的增量. 主要與運算子的次序有關. 假如寫成 (*ptr)++, 表示增量的部分,  並非指標, 而是該指標所指向值的增量. 也就是說, 在上述程式中, 若對第一個字元 'T' 增量, 其值就會變成 'U'. 使用者可以自行寫程式來印證此一結果.

由於字串只不過就是字元所組合而成的陣列, 並在最後一個字元補上 '\0'.  上面所進行的是用來複製陣列. 這些字元陣列的運算技巧, 也可以應用到整數陣列或浮點數陣列. 但是在這些應用中, 陣列的尾端, 並不會補上 nul 字元, 而可以放進某特定值的內容, 來表示其為終點. 例如, 可以在複製正整數時, 在尾數放入一個負值的整數來標示終點. 或者, 寫一個函式, 可以複製字串以外的陣列及其陣列位址, 就如同下列原型所示:

    void int_copy(int *ptrA, int *ptrB, int nbr);

其中 nbr 為要進行複製的整數值. 試著寫一個可以用來複製整數陣列的 int_copy() 函式, 看看是否能夠正常運作.

如此, 就可以使用函式來處理大陣列. 例如, 有一帶有 5000 個整數的陣列需要處理, 只要將該陣列的位址輸入該函式 (視情形,  可以加上其他相關變數, 如上述程式中的 nbr 變數), 而不需要輸入陣列本身, 意即, 整個陣列值並沒有在堆疊中複製後進行輸入的動作, 而只送出其位址.

此一過程與輸入某一整數給某一函式不同. 輸入整數時, 必須複製該整數, 也就是取得該整數的值, 然後放入某一堆疊當中. 這時, 該函式的處理並不影響原始的整數值, 而若以陣列及指標進行處理, 可以將變數位址輸入, 直接處理原始變數的值.</t>
<t tx="amd_yen.20130406103207.2766">Chapter 4: More on Strings

第四章: 更多關於字串的用法

好的, 在短短的時間裏, 已經介紹了不少東西! 接著再看一次第三章中有關字串複製的部分, 但是採不同的方法. 以下列函式來看:

    char *my_strcpy(char dest[], char source[])
    {
        int i = 0;
        while (source[i] != '\0')
        {
            dest[i] = source[i];
            i++;
        }
        dest[i] = '\0';
        return dest;
    }

之前曾說過, 字串就是字元所組成的陣列. 這裡我們利用陣列表示而非指標表示, 來進行資料的實質複製. 結果會與之前相同, 亦即, 採此一方法的字串複製, 其結果依然正確. 這也衍生出接下來要討論的有趣論點.

由於變數透過值進行傳遞, 可經由前述之字元指標或陣列名稱進行, 其間真正傳遞的則是每一陣列中第一個元素的位址. 亦即, 變數數值的傳遞, 可透過字元指標或陣列名稱來代表此一變數. 也可以說, source[i] 其實與 *(p+i) 的用法一樣.

事實上, 這是正確的, 亦即 a[i] 可以利用 *(a+i) 來替代, 而不會產生任何問題. 換言之, 編譯器針對這兩種情形, 會產生相同的編碼. 因此, 指標算術其實與陣列索引編碼相同. 兩種語法會產生相同結果.

但是這並非說, 指標與陣列是相同的東西, 其實不然. 這裡只是說, 利用陣列來進行特定元素辨識, 可以採用兩種不同的語法, 其一為採用陣列索引, 而另一種方法則是利用指標算術, 會得到相同的結果.

接著, 注意最後的表示式, (a+i) 的部分利用簡單的加號 + 與 C 的語法, 表示式子可以交換, 亦即 (a+i) 與 (i+a) 完全相同. 因此可以將 *(i+a) 簡化為 *(a+i).

但是 *(i+a) 可能來自 i[a]! 綜合上述, 或許會懷疑若:

    char a[20];
    int i;

寫成

    a[3] = 'x';

其實與下列表示式, 其實是一樣的.

    3[a] = 'x';

試試看! 設定一個字元陣列, 內存為整數或長整數等. 對其第三或第四元素, 以傳統方式, 給定特殊值, 接著將值印出加以確認. 然後如前述, 將陣列表示式反轉過來, 一個好編譯器將會毫無疑問的給出相同的結果, 僅只出於好奇, 別無其他用意.

程式範例:

#include &lt;stdio.h&gt;

// 每一個 C 程式都必須要有一個小寫的 main()函式
int main()
{
    // 陣列與指標的應用
    char a[20];
    int i;
    a[3] = 'x';
    printf("%c\n",a[3]);
    printf("%c\n",3[a]);
    printf("%c\n",*(a+3));
    printf("%c\n",*(3+a));
    return 0;
}

接著, 來看前面給的函數, 寫成:

    dest[i] = source[i];

由於已知陣列索引與指標算術會得到相同的結果, 因此也可以寫成:

    *(dest + i) = *(source + i);

但是, 需要對每一個值分別加上 i. 加法, 一般而言, 會比索引增量 (例如採用 ++ 運算符號的 i++) 耗費更多時間. 或許對現在最佳化的編譯器來說, 不一定就是如此, 但是採用指標通常比陣列索引來得快些.

另一個可以加速指標運算的方法, 將:

    while (*source != '\0')

簡化為

    while (*source)

兩種情形都會讓括號中為零 (FALSE).

這裡可實驗看看, 以指標的方法來寫程式. 用來處理字串應該不錯. 可以將下列標準函式改寫成自己的版本:

    strlen();
    strcat();
    strchr();

或者其他在系統中的函式.

接下來的章節, 還會再探討字串及其處理. 接下來先討論一下 structures (結構).</t>
<t tx="amd_yen.20130406103207.2767">Chapter 5: Pointers and Structures

第五章: 指標與結構

也許你已經知道, 可以利用結構的形式來宣告帶有不同資料型別的資料區塊. 例如, 人事檔案可能包含下列結構:

    struct tag {
        char lname[20];        /* 姓 */
        char fname[20];        /* 名 */
        int age;               /* 年齡 */
        float rate;            /* 例如: 每小時 100 元 */
    };
假如在磁片檔案中有許多這樣的資料, 當我們需要一筆筆讀出, 並且分別列出姓名, 以做成資料表格. 其他資料並不需要印出. 具體做法, 可以利用函式呼叫, 透過指向結構的指標作為輸入, 就可以完成處理. 這裡只利用一個結構進行示範, 並且主要在編寫函式, 而非讀檔. 這裡已經假設您知道如何進行讀檔.

複習一下, 我們可以利用點運算子來擷取結構成員, 正如:

--------------- 程式 5.1 ------------------
/* 程式 5.1 from PTRTUT10.HTM     6/13/97 */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
struct tag {
    char lname[20];      /* 姓 */
    char fname[20];      /* 名 */
    int age;             /* 年齡 */
    float rate;          /* 例如: 每小時 100 元 */
};
struct tag my_struct;       /* 宣告 my_struct　結構 */
int main(void)
{
    strcpy(my_struct.lname,"Jensen");
    strcpy(my_struct.fname,"Ted");
    printf("\n%s ",my_struct.fname);
    printf("%s\n",my_struct.lname);
    return 0;
}
-------------- 結束程式 5.1 --------------
或許這裏所使用的結構與一般 C 程式所使用的相比還要小, 為了驗證也可以加入:

    date_of_hire;                  (未顯示資料型別)
    date_of_last_raise;
    last_percent_increase;
    emergency_phone;
    medical_plan;
    Social_S_Nbr;
    等等.....
    
假如員工的數量眾多, 應該會採用函式進行資料處理. 例如, 將結構輸入該函式, 就能利用函式印出員工姓名. 但是在最原始的 C (Kernighan &amp; Ritchie, 第一版), 無法輸入結構, 只能輸入指向結構的指標. 在 ANSI C 中, 已經允許利用結構作為函式輸入. 而這裡為了進行更多有關指標的學習, 並不直接採用結構.

總之, 假如輸入整個結構, 就如同必須在函式呼叫時複製結構內容, 在仍然使用堆疊的系統中, 就等同將整個結構資料送入堆疊中. 針對大型結構時,  可能就會造成問題. 若能只輸入指標, 就可使用最少的堆疊空間.

因此這裡主要在談指標, 因此接著來看如何將指向結構的指標變數輸入函式當中.

以上面的情況為例, 建立一個能夠接受指標變數 (指向結構) 的函式, 其中我們只想要擷取該結構的部分成員. 例如, 只要印出範例結構中的人員姓名.

好, 先前我們已經知道如何宣告指向結構的指標變數 tag. 接著就可以利用 tag 結構, 來宣告指標變數:

    struct tag *st_ptr;
    
並且可以用來指向範例中的結構:

    st_ptr = &amp;my_struct;
    
接下來, 可以利用指標的分割參照, 來指定特定成員. 但是應該如何利用指標的分割參照來指向結構? 假如要利用指標來設定人員的年紀, 可以寫成:

    (*st_ptr).age = 63;
    
仔細看清楚. 此一設定表示, 若將括號中 st_ptr 所指向的內容換成 my_struct, 就會與my_struct.age 相同.

但是, 這樣經常會被用到的表示式, 就被設定為與下列表示式涵義相同:

    st_ptr-&gt;age = 63;
    
了解了之後, 參考下列程式:

------------ 程式 5.2 ---------------------
/* 程式 5.2 from PTRTUT10.HTM   6/13/97 */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
struct tag{                     /* 結構型別 */
    char lname[20];             /* 姓 */
    char fname[20];             /* 名 */
    int age;                    /* 年齡 */
    float rate;                 /* 例如: 每小時 100 元 */
};
struct tag my_struct;           /* 結構定義 */
void show_name(struct tag *p);  /* 函式原型 */
int main(void)
{
    struct tag *st_ptr;         /* 指向結構的指標變數 */
    st_ptr = &amp;my_struct;        /* 將指標指向 my_struct */
    strcpy(my_struct.lname,"Jensen");
    strcpy(my_struct.fname,"Ted");
    printf("\n%s ",my_struct.fname);
    printf("%s\n",my_struct.lname);
    my_struct.age = 63;
    show_name(st_ptr);          /* 輸入該指標 */
    return 0;
}
void show_name(struct tag *p)
{
    printf("\n%s ", p-&gt;fname);  /* p 指向結構 */
    printf("%s ", p-&gt;lname);
    printf("%d\n", p-&gt;age);
}
-------------------- 結束程式 5.2 ----------------
這裡要了解不少東西. 讀者必須實際執行一下上面的程式, 並且利用除錯器一步步觀察  my_struct 與 p 在主函式執行流程中, 才能實際了解函式執行的內容.</t>
<t tx="amd_yen.20130406103207.2768">趨勢發展:

Python 與 CUDA

http://mathema.tician.de/software/pycuda</t>
</tnodes>
</leo_file>
